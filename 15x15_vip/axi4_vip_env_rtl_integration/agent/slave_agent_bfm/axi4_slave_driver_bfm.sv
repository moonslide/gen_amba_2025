//==============================================================================
// AXI4 Slave Driver BFM - Responds to AXI interface transactions
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-09 12:32:51
//==============================================================================

module axi4_slave_driver_bfm #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 14  // Slave ID width includes concatenated master ID
)(
    input aclk, 
    input aresetn,
    axi4_if.slave axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Simple memory array for storing data
    logic [DATA_WIDTH-1:0] memory [logic [ADDR_WIDTH-1:0]];
    
    // Control signals for BFM operation
    bit bfm_enable = 1;  // Default enabled for slave to respond
    
    // Response delays (configurable)
    int aw_response_delay = 2;
    int w_response_delay = 1;
    int b_response_delay = 3;
    int ar_response_delay = 2;
    int r_response_delay = 1;
    
    // Slave response handling tasks
    task automatic handle_write_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting write transaction handling", UVM_LOW)
        
        fork
            handle_write_address_channel();
            handle_write_data_channel();
            handle_write_response_channel();
        join_none
    endtask
    
    task automatic handle_read_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting read transaction handling", UVM_LOW)
        
        fork
            handle_read_address_channel();
            handle_read_data_channel();
        join_none
    endtask
    
    // Write transaction coordination - using a proper transaction queue
    typedef struct {
        logic [ID_WIDTH-1:0] awid;
        logic [ADDR_WIDTH-1:0] awaddr;
        logic [7:0] awlen;
        logic [2:0] awsize;
        logic [1:0] awburst;
        logic addr_received;
        logic data_complete;
        logic response_sent;
    } write_transaction_t;
    
    write_transaction_t write_trans_queue[$];  // Transaction queue
    
    // Write Address Channel Handler
    task automatic handle_write_address_channel();
        write_transaction_t new_trans;
        forever begin
            axi_intf.awready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, aw_response_delay)) @(posedge aclk);
            axi_intf.awready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.awvalid && axi_intf.awready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            new_trans.awid = axi_intf.awid;
            new_trans.awaddr = axi_intf.awaddr;
            new_trans.awlen = axi_intf.awlen;
            new_trans.awsize = axi_intf.awsize;
            new_trans.awburst = axi_intf.awburst;
            new_trans.addr_received = 1'b1;
            new_trans.data_complete = 1'b0;
            new_trans.response_sent = 1'b0;
            
            // Add to transaction queue
            write_trans_queue.push_back(new_trans);
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      new_trans.awid, new_trans.awaddr, new_trans.awlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.awready <= 1'b0;
        end
    endtask
    
    // Write Data Channel Handler
    task automatic handle_write_data_channel();
        logic [ADDR_WIDTH-1:0] beat_addr;
        int write_beat_count;
        write_transaction_t current_trans;
        forever begin
            axi_intf.wready <= 1'b0;
            
            // Wait for a transaction with address but no data completion
            while (write_trans_queue.size() == 0) @(posedge aclk);
            
            // Find the oldest transaction that needs data
            current_trans = write_trans_queue[0];  // Get first transaction
            write_beat_count = 0;
            
            // Handle write data beats
            while (write_beat_count <= current_trans.awlen) begin
                // Random delay before accepting data
                repeat($urandom_range(0, w_response_delay)) @(posedge aclk);
                axi_intf.wready <= 1'b1;
                
                // Wait for valid data
                while (!axi_intf.wvalid) @(posedge aclk);
                
                // Store data in memory (simplified)
                beat_addr = current_trans.awaddr + (write_beat_count * (DATA_WIDTH/8));
                memory[beat_addr] = axi_intf.wdata;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data beat %0d accepted: addr=0x%010x, data=0x%016x, wstrb=0x%02x", 
                          write_beat_count, beat_addr, axi_intf.wdata, axi_intf.wstrb), UVM_HIGH)
                
                write_beat_count++;
                @(posedge aclk);
                axi_intf.wready <= 1'b0;
                
                if (axi_intf.wlast) break;
            end
            
            // Mark data as complete for this transaction
            write_trans_queue[0].data_complete = 1'b1;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data complete for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Write Response Channel Handler - Enhanced B-channel AXI4 flow
    task automatic handle_write_response_channel();
        int b_handshake_timeout;
        write_transaction_t current_trans;
        forever begin
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            axi_intf.bresp <= 2'b00;
            
            // Wait for a transaction that is complete but not yet responded
            while (write_trans_queue.size() == 0 || 
                   !write_trans_queue[0].addr_received || 
                   !write_trans_queue[0].data_complete ||
                   write_trans_queue[0].response_sent) @(posedge aclk);
            
            // Get the transaction to respond to
            current_trans = write_trans_queue[0];
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Starting B-channel response for id=%0d", current_trans.awid), UVM_HIGH)
            
            // Random delay before response (realistic slave behavior)
            repeat($urandom_range(1, b_response_delay)) @(posedge aclk);
            
            // Prepare write response with proper AXI4 compliance
            axi_intf.bid <= current_trans.awid;     // BID must match AWID per AXI4 spec
            axi_intf.bresp <= 2'b00;                // OKAY response (could be configurable)
            axi_intf.bvalid <= 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel response asserted: bid=%0d, bresp=2'b%02b (OKAY)", 
                      axi_intf.bid, axi_intf.bresp), UVM_MEDIUM)
            
            // Wait for BREADY handshake with timeout protection
            b_handshake_timeout = 0;
            while (!axi_intf.bready) begin
                @(posedge aclk);
                b_handshake_timeout++;
                if (b_handshake_timeout > 1000) begin
                    `uvm_error("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake timeout for id=%0d", current_trans.awid))
                    break;
                end
            end
            
            // Complete handshake - both BVALID and BREADY are high
            if (axi_intf.bready) begin
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake completed for id=%0d", current_trans.awid), UVM_HIGH)
            end
            
            // Deassert BVALID on next clock edge per AXI4 protocol
            @(posedge aclk);
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            
            // Remove completed transaction from queue
            write_trans_queue.pop_front();
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write transaction completed for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Read transaction coordination - using a proper transaction queue
    typedef struct {
        logic [ID_WIDTH-1:0] arid;
        logic [ADDR_WIDTH-1:0] araddr;
        logic [7:0] arlen;
        logic [2:0] arsize;
        logic [1:0] arburst;
        logic addr_received;
        logic data_sent;
    } read_transaction_t;
    
    read_transaction_t read_trans_queue[$];  // Transaction queue
    
    
        // Read Address Channel Handler
    task automatic handle_read_address_channel();
        read_transaction_t new_trans;
        forever begin
            axi_intf.arready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, ar_response_delay)) @(posedge aclk);
            axi_intf.arready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.arvalid && axi_intf.arready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            new_trans.arid = axi_intf.arid;
            new_trans.araddr = axi_intf.araddr;
            new_trans.arlen = axi_intf.arlen;
            new_trans.arsize = axi_intf.arsize;
            new_trans.arburst = axi_intf.arburst;
            new_trans.addr_received = 1'b1;
            new_trans.data_sent = 1'b0;
            
            // Add to transaction queue
            read_trans_queue.push_back(new_trans);
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      new_trans.arid, new_trans.araddr, new_trans.arlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.arready <= 1'b0;
        end
    endtask
    
        // Read Data Channel Handler
    task automatic handle_read_data_channel();
        int read_beat_count;
        logic [ADDR_WIDTH-1:0] beat_addr;
        logic [DATA_WIDTH-1:0] read_data;
        read_transaction_t current_trans;
        
        forever begin
            // Initialize signals to prevent unknown values
            axi_intf.rvalid <= 1'b0;
            axi_intf.rid <= '0;
            axi_intf.rdata <= '0;
            axi_intf.rresp <= 2'b00;
            axi_intf.rlast <= 1'b0;
            
            // Wait for a transaction with address received but data not sent
            while (read_trans_queue.size() == 0 || 
                   !read_trans_queue[0].addr_received || 
                   read_trans_queue[0].data_sent) @(posedge aclk);
            
            // Get the transaction to process
            current_trans = read_trans_queue[0];
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Starting R-channel response for id=%0d", current_trans.arid), UVM_HIGH)
            
            // Send read data beats
            for (read_beat_count = 0; read_beat_count <= current_trans.arlen; read_beat_count++) begin
                // Calculate beat address
                beat_addr = current_trans.araddr + (read_beat_count * (DATA_WIDTH/8));
                
                // Get data from memory (or generate if not written)
                if (memory.exists(beat_addr)) begin
                    read_data = memory[beat_addr];
                end else begin
                    // Initialize with pattern instead of random to avoid X propagation
                    read_data = {DATA_WIDTH{1'b0}} | beat_addr;  // Use address as data pattern
                end
                
                // Random delay before data
                repeat($urandom_range(0, r_response_delay)) @(posedge aclk);
                
                // Send read data with proper initialization
                axi_intf.rid <= current_trans.arid;
                axi_intf.rdata <= read_data;
                axi_intf.rresp <= 2'b00;  // OKAY response
                axi_intf.rlast <= (read_beat_count == current_trans.arlen);
                axi_intf.rvalid <= 1'b1;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read data beat %0d sent: id=%0d, addr=0x%010x, data=0x%016x, last=%0b", 
                          read_beat_count, current_trans.arid, beat_addr, read_data, axi_intf.rlast), UVM_HIGH)
                
                // Wait for rready with timeout
                begin
                    int r_timeout = 0;
                    while (!axi_intf.rready) begin
                        @(posedge aclk);
                        r_timeout++;
                        if (r_timeout > 1000) begin
                            `uvm_error("AXI_SLAVE_DRIVER_BFM", $sformatf("R-channel handshake timeout for id=%0d", current_trans.arid))
                            break;
                        end
                    end
                end
                
                @(posedge aclk);
                axi_intf.rvalid <= 1'b0;
                axi_intf.rlast <= 1'b0;
            end
            
            // Remove completed transaction from queue
            read_trans_queue.pop_front();
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read transaction completed for id=%0d", current_trans.arid), UVM_MEDIUM)
        end
    endtask
    
    // Initialize signals and start handling - ALWAYS READY approach

    // Ultra-simple slave BFM - always ready, immediate response
        // AXI4 Spec Compliant BFM - Per IHI0022D_amba_axi_protocol_spec.pdf
    initial begin
        // Initialize all response signals per spec
        axi_intf.awready = 1'b0;
        axi_intf.wready  = 1'b0; 
        axi_intf.bvalid  = 1'b0;
        axi_intf.bid     = '0;
        axi_intf.bresp   = 2'b00;
        axi_intf.arready = 1'b0;
        axi_intf.rvalid  = 1'b0;
        axi_intf.rid     = '0;
        axi_intf.rdata   = '0;
        axi_intf.rresp   = 2'b00;
        axi_intf.rlast   = 1'b0;
        
        // Wait for reset release
        wait(aresetn == 1'b1);
        #10;
        
        // Per IHI0022D - slave can be always ready or add delays
        axi_intf.awready <= 1'b1;  // Ready to accept write addresses
        axi_intf.wready  <= 1'b1;  // Ready to accept write data  
        axi_intf.arready <= 1'b1;  // Ready to accept read addresses
        
        `uvm_info("AXI4_SLAVE_BFM", "AXI4 Slave BFM initialized per IHI0022D spec", UVM_MEDIUM);
        
        // AXI4 compliant response handling
        fork
            // Write Response Handler - Per IHI0022D Section A3.3
            begin
                logic [ID_WIDTH-1:0] write_id_queue[$];
                forever begin
                    @(posedge aclk);
                    
                    // IHI0022D A3.2.2 - Capture AWID during AW handshake
                    if (axi_intf.awvalid && axi_intf.awready) begin
                        write_id_queue.push_back(axi_intf.awid);
                        `uvm_info("AXI4_SLAVE_BFM", $sformatf("Write address captured: AWID=%0d, AWADDR=0x%0h", 
                                  axi_intf.awid, axi_intf.awaddr), UVM_HIGH)
                    end
                    
                    // IHI0022D A3.2.1 - Respond when WLAST indicates end of burst
                    if (axi_intf.wvalid && axi_intf.wready && axi_intf.wlast && !axi_intf.bvalid) begin
                        if (write_id_queue.size() > 0) begin
                            automatic logic [ID_WIDTH-1:0] response_id = write_id_queue.pop_front();
                            
                            // IHI0022D A3.3.1 - BID must match AWID, BRESP indicates status
                            axi_intf.bid    <= response_id;  // Must match AWID per spec
                            axi_intf.bresp  <= 2'b00;        // OKAY response
                            axi_intf.bvalid <= 1'b1;         // Response valid
                            
                            `uvm_info("AXI4_SLAVE_BFM", $sformatf("Write response: BID=%0d, BRESP=OKAY (per IHI0022D A3.3)", 
                                      response_id), UVM_MEDIUM)
                        end else begin
                            `uvm_error("AXI4_SLAVE_BFM", "WLAST without corresponding AWID - AXI4 protocol violation")
                        end
                    end
                    
                    // IHI0022D A3.3.2 - Clear response when BREADY handshake completes
                    if (axi_intf.bvalid && axi_intf.bready) begin
                        @(posedge aclk);
                        axi_intf.bvalid <= 1'b0;
                        axi_intf.bid    <= '0;
                        `uvm_info("AXI4_SLAVE_BFM", "Write response handshake completed", UVM_HIGH)
                    end
                end
            end
            
            // Read Response Handler - Per IHI0022D Section A3.4
            begin
                forever begin
                    @(posedge aclk);
                    
                    // IHI0022D A3.4.2 - Handle read request during AR handshake
                    if (axi_intf.arvalid && axi_intf.arready && !axi_intf.rvalid) begin
                        automatic logic [ID_WIDTH-1:0] read_id = axi_intf.arid;
                        automatic logic [7:0] read_len = axi_intf.arlen;
                        automatic logic [ADDR_WIDTH-1:0] read_addr = axi_intf.araddr;
                        
                        `uvm_info("AXI4_SLAVE_BFM", $sformatf("Read request: ARID=%0d, ARADDR=0x%0h, ARLEN=%0d (per IHI0022D A3.4)", 
                                  read_id, read_addr, read_len), UVM_MEDIUM)
                        
                        // IHI0022D A3.4.1 - Send arlen+1 data beats, RLAST on final beat
                        for (int beat = 0; beat <= read_len; beat++) begin
                            @(posedge aclk);
                            
                            // IHI0022D A3.4.1 - RID must match ARID
                            axi_intf.rid    <= read_id;
                            axi_intf.rdata  <= {DATA_WIDTH{1'b0}} | (read_addr + beat * 8);  // Address pattern
                            axi_intf.rresp  <= 2'b00;              // OKAY response
                            axi_intf.rlast  <= (beat == read_len);  // RLAST on final beat per spec
                            axi_intf.rvalid <= 1'b1;               // Data valid
                            
                            `uvm_info("AXI4_SLAVE_BFM", $sformatf("Read response beat %0d/%0d: RID=%0d, RDATA=0x%0h, RLAST=%0b", 
                                      beat, read_len, read_id, axi_intf.rdata, axi_intf.rlast), UVM_HIGH)
                            
                            // IHI0022D A3.4.2 - Wait for RREADY handshake
                            while (!axi_intf.rready) @(posedge aclk);
                            @(posedge aclk);
                            
                            axi_intf.rvalid <= 1'b0;
                            axi_intf.rlast  <= 1'b0;
                        end
                        
                        `uvm_info("AXI4_SLAVE_BFM", $sformatf("Read burst completed for ARID=%0d per AXI4 spec", read_id), UVM_MEDIUM)
                    end
                end
            end
        join_none
    end

endmodule : axi4_slave_driver_bfm
