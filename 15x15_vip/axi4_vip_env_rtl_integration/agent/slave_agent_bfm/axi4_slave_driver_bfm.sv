//==============================================================================
// AXI4 Slave Driver BFM - Responds to AXI interface transactions
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-09 12:32:51
//==============================================================================

module axi4_slave_driver_bfm #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 14  // Slave ID width includes concatenated master ID
)(
    input aclk, 
    input aresetn,
    axi4_if.slave axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Simple memory array for storing data
    logic [DATA_WIDTH-1:0] memory [logic [ADDR_WIDTH-1:0]];
    
    // Control signals for BFM operation
    bit bfm_enable = 1;  // Default enabled for slave to respond
    
    // Response delays (configurable)
    int aw_response_delay = 2;
    int w_response_delay = 1;
    int b_response_delay = 3;
    int ar_response_delay = 2;
    int r_response_delay = 1;
    
    // Slave response handling tasks
    task automatic handle_write_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting write transaction handling", UVM_LOW)
        
        fork
            handle_write_address_channel();
            handle_write_data_channel();
            handle_write_response_channel();
        join_none
    endtask
    
    task automatic handle_read_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting read transaction handling", UVM_LOW)
        
        forever begin
            fork
                handle_read_address_channel();
                handle_read_data_channel();
            join_none
            @(posedge aclk);
        end
    endtask
    
    // Write transaction coordination - using a proper transaction queue
    typedef struct {
        logic [ID_WIDTH-1:0] awid;
        logic [ADDR_WIDTH-1:0] awaddr;
        logic [7:0] awlen;
        logic [2:0] awsize;
        logic [1:0] awburst;
        logic addr_received;
        logic data_complete;
        logic response_sent;
    } write_transaction_t;
    
    write_transaction_t write_trans_queue[$];  // Transaction queue
    
    // Write Address Channel Handler
    task automatic handle_write_address_channel();
        write_transaction_t new_trans;
        forever begin
            axi_intf.awready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, aw_response_delay)) @(posedge aclk);
            axi_intf.awready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.awvalid && axi_intf.awready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            new_trans.awid = axi_intf.awid;
            new_trans.awaddr = axi_intf.awaddr;
            new_trans.awlen = axi_intf.awlen;
            new_trans.awsize = axi_intf.awsize;
            new_trans.awburst = axi_intf.awburst;
            new_trans.addr_received = 1'b1;
            new_trans.data_complete = 1'b0;
            new_trans.response_sent = 1'b0;
            
            // Add to transaction queue
            write_trans_queue.push_back(new_trans);
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      new_trans.awid, new_trans.awaddr, new_trans.awlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.awready <= 1'b0;
        end
    endtask
    
    // Write Data Channel Handler
    task automatic handle_write_data_channel();
        logic [ADDR_WIDTH-1:0] beat_addr;
        int write_beat_count;
        write_transaction_t current_trans;
        forever begin
            axi_intf.wready <= 1'b0;
            
            // Wait for a transaction with address but no data completion
            while (write_trans_queue.size() == 0) @(posedge aclk);
            
            // Find the oldest transaction that needs data
            current_trans = write_trans_queue[0];  // Get first transaction
            write_beat_count = 0;
            
            // Handle write data beats
            while (write_beat_count <= current_trans.awlen) begin
                // Random delay before accepting data
                repeat($urandom_range(0, w_response_delay)) @(posedge aclk);
                axi_intf.wready <= 1'b1;
                
                // Wait for valid data
                while (!axi_intf.wvalid) @(posedge aclk);
                
                // Store data in memory (simplified)
                beat_addr = current_trans.awaddr + (write_beat_count * (DATA_WIDTH/8));
                memory[beat_addr] = axi_intf.wdata;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data beat %0d accepted: addr=0x%010x, data=0x%016x, wstrb=0x%02x", 
                          write_beat_count, beat_addr, axi_intf.wdata, axi_intf.wstrb), UVM_HIGH)
                
                write_beat_count++;
                @(posedge aclk);
                axi_intf.wready <= 1'b0;
                
                if (axi_intf.wlast) break;
            end
            
            // Mark data as complete for this transaction
            write_trans_queue[0].data_complete = 1'b1;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data complete for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Write Response Channel Handler - Enhanced B-channel AXI4 flow
    task automatic handle_write_response_channel();
        int b_handshake_timeout;
        write_transaction_t current_trans;
        forever begin
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            axi_intf.bresp <= 2'b00;
            
            // Wait for a transaction that is complete but not yet responded
            while (write_trans_queue.size() == 0 || 
                   !write_trans_queue[0].addr_received || 
                   !write_trans_queue[0].data_complete ||
                   write_trans_queue[0].response_sent) @(posedge aclk);
            
            // Get the transaction to respond to
            current_trans = write_trans_queue[0];
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Starting B-channel response for id=%0d", current_trans.awid), UVM_HIGH)
            
            // Random delay before response (realistic slave behavior)
            repeat($urandom_range(1, b_response_delay)) @(posedge aclk);
            
            // Prepare write response with proper AXI4 compliance
            axi_intf.bid <= current_trans.awid;     // BID must match AWID per AXI4 spec
            axi_intf.bresp <= 2'b00;                // OKAY response (could be configurable)
            axi_intf.bvalid <= 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel response asserted: bid=%0d, bresp=2'b%02b (OKAY)", 
                      axi_intf.bid, axi_intf.bresp), UVM_MEDIUM)
            
            // Wait for BREADY handshake with timeout protection
            b_handshake_timeout = 0;
            while (!axi_intf.bready) begin
                @(posedge aclk);
                b_handshake_timeout++;
                if (b_handshake_timeout > 1000) begin
                    `uvm_error("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake timeout for id=%0d", current_trans.awid))
                    break;
                end
            end
            
            // Complete handshake - both BVALID and BREADY are high
            if (axi_intf.bready) begin
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake completed for id=%0d", current_trans.awid), UVM_HIGH)
            end
            
            // Deassert BVALID on next clock edge per AXI4 protocol
            @(posedge aclk);
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            
            // Remove completed transaction from queue
            write_trans_queue.pop_front();
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write transaction completed for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Read Address Channel Handler
    logic read_addr_pending = 0;
    logic [ID_WIDTH-1:0] pending_arid = '0;  // Initialize to prevent 'z' values
    logic [ADDR_WIDTH-1:0] pending_araddr;
    logic [7:0] pending_arlen;
    logic [2:0] pending_arsize;
    logic [1:0] pending_arburst;
    
    task automatic handle_read_address_channel();
        forever begin
            axi_intf.arready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, ar_response_delay)) @(posedge aclk);
            axi_intf.arready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.arvalid && axi_intf.arready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            pending_arid = axi_intf.arid;
            pending_araddr = axi_intf.araddr;
            pending_arlen = axi_intf.arlen;
            pending_arsize = axi_intf.arsize;
            pending_arburst = axi_intf.arburst;
            read_addr_pending = 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      pending_arid, pending_araddr, pending_arlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.arready <= 1'b0;
        end
    endtask
    
    // Read Data Channel Handler
    task automatic handle_read_data_channel();
        int read_beat_count;
        logic [ADDR_WIDTH-1:0] beat_addr;
        logic [DATA_WIDTH-1:0] read_data;
        
        forever begin
            axi_intf.rvalid <= 1'b0;
            
            // Wait for read address to be captured
            while (!read_addr_pending) @(posedge aclk);
            
            // Send read data beats
            for (read_beat_count = 0; read_beat_count <= pending_arlen; read_beat_count++) begin
                // Calculate beat address
                beat_addr = pending_araddr + (read_beat_count * (DATA_WIDTH/8));
                
                // Get data from memory (or generate if not written)
                if (memory.exists(beat_addr)) begin
                    read_data = memory[beat_addr];
                end else begin
                    read_data = $urandom();  // Random data for unwritten addresses
                end
                
                // Random delay before data
                repeat($urandom_range(0, r_response_delay)) @(posedge aclk);
                
                // Send read data
                axi_intf.rid <= pending_arid;
                axi_intf.rdata <= read_data;
                axi_intf.rresp <= 2'b00;  // OKAY response
                axi_intf.rlast <= (read_beat_count == pending_arlen);
                axi_intf.rvalid <= 1'b1;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read data beat %0d sent: id=%0d, addr=0x%010x, data=0x%016x, last=%0b", 
                          read_beat_count, pending_arid, beat_addr, read_data, axi_intf.rlast), UVM_HIGH)
                
                // Wait for rready
                while (!axi_intf.rready) @(posedge aclk);
                
                @(posedge aclk);
                axi_intf.rvalid <= 1'b0;
                axi_intf.rlast <= 1'b0;
            end
            
            read_addr_pending = 1'b0;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read transaction complete for id=%0d", pending_arid), UVM_MEDIUM)
        end
    endtask
    
    // Initialize signals and start handling
    initial begin
        // Initialize all slave output signals
        axi_intf.awready  = '0;
        axi_intf.wready   = '0;
        axi_intf.bid      = '0;
        axi_intf.bresp    = '0;
        axi_intf.bvalid   = '0;
        axi_intf.arready  = '0;
        axi_intf.rid      = '0;
        axi_intf.rdata    = '0;
        axi_intf.rresp    = '0;
        axi_intf.rlast    = '0;
        axi_intf.rvalid   = '0;
        
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Slave BFM signals initialized", UVM_LOW)
        
        // Wait for reset deassertion
        wait(aresetn == 1'b1);
        repeat(5) @(posedge aclk);
        
        // Start handling transactions
        fork
            handle_write_transactions();
            handle_read_transactions();
        join_none
    end

endmodule : axi4_slave_driver_bfm
