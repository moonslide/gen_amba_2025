//==============================================================================
// AXI4 Slave Driver BFM - Responds to AXI interface transactions
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-09 12:32:51
//==============================================================================

module axi4_slave_driver_bfm #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 14  // Slave ID width includes concatenated master ID
)(
    input aclk, 
    input aresetn,
    axi4_if.slave axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Simple memory array for storing data
    logic [DATA_WIDTH-1:0] memory [logic [ADDR_WIDTH-1:0]];
    
    // Control signals for BFM operation
    bit bfm_enable = 1;  // Default enabled for slave to respond
    
    // Response delays (configurable)
    int aw_response_delay = 2;
    int w_response_delay = 1;
    int b_response_delay = 3;
    int ar_response_delay = 2;
    int r_response_delay = 1;
    
    // Slave response handling tasks
    task automatic handle_write_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting write transaction handling", UVM_LOW)
        
        fork
            handle_write_address_channel();
            handle_write_data_channel();
            handle_write_response_channel();
        join_none
    endtask
    
    task automatic handle_read_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting read transaction handling", UVM_LOW)
        
        fork
            handle_read_address_channel();
            handle_read_data_channel();
        join_none
    endtask
    
    // Write transaction coordination - using a proper transaction queue
    typedef struct {
        logic [ID_WIDTH-1:0] awid;
        logic [ADDR_WIDTH-1:0] awaddr;
        logic [7:0] awlen;
        logic [2:0] awsize;
        logic [1:0] awburst;
        logic addr_received;
        logic data_complete;
        logic response_sent;
    } write_transaction_t;
    
    write_transaction_t write_trans_queue[$];  // Transaction queue
    
    // Write Address Channel Handler
    task automatic handle_write_address_channel();
        write_transaction_t new_trans;
        forever begin
            axi_intf.awready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, aw_response_delay)) @(posedge aclk);
            axi_intf.awready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.awvalid && axi_intf.awready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            new_trans.awid = axi_intf.awid;
            new_trans.awaddr = axi_intf.awaddr;
            new_trans.awlen = axi_intf.awlen;
            new_trans.awsize = axi_intf.awsize;
            new_trans.awburst = axi_intf.awburst;
            new_trans.addr_received = 1'b1;
            new_trans.data_complete = 1'b0;
            new_trans.response_sent = 1'b0;
            
            // Add to transaction queue
            write_trans_queue.push_back(new_trans);
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      new_trans.awid, new_trans.awaddr, new_trans.awlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.awready <= 1'b0;
        end
    endtask
    
    // Write Data Channel Handler
    task automatic handle_write_data_channel();
        logic [ADDR_WIDTH-1:0] beat_addr;
        int write_beat_count;
        write_transaction_t current_trans;
        forever begin
            axi_intf.wready <= 1'b0;
            
            // Wait for a transaction with address but no data completion
            while (write_trans_queue.size() == 0) @(posedge aclk);
            
            // Find the oldest transaction that needs data
            current_trans = write_trans_queue[0];  // Get first transaction
            write_beat_count = 0;
            
            // Handle write data beats
            while (write_beat_count <= current_trans.awlen) begin
                // Random delay before accepting data
                repeat($urandom_range(0, w_response_delay)) @(posedge aclk);
                axi_intf.wready <= 1'b1;
                
                // Wait for valid data
                while (!axi_intf.wvalid) @(posedge aclk);
                
                // Store data in memory (simplified)
                beat_addr = current_trans.awaddr + (write_beat_count * (DATA_WIDTH/8));
                memory[beat_addr] = axi_intf.wdata;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data beat %0d accepted: addr=0x%010x, data=0x%016x, wstrb=0x%02x", 
                          write_beat_count, beat_addr, axi_intf.wdata, axi_intf.wstrb), UVM_HIGH)
                
                write_beat_count++;
                @(posedge aclk);
                axi_intf.wready <= 1'b0;
                
                if (axi_intf.wlast) break;
            end
            
            // Mark data as complete for this transaction
            write_trans_queue[0].data_complete = 1'b1;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data complete for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Write Response Channel Handler - Enhanced B-channel AXI4 flow
    task automatic handle_write_response_channel();
        int b_handshake_timeout;
        write_transaction_t current_trans;
        forever begin
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            axi_intf.bresp <= 2'b00;
            
            // Wait for a transaction that is complete but not yet responded
            while (write_trans_queue.size() == 0 || 
                   !write_trans_queue[0].addr_received || 
                   !write_trans_queue[0].data_complete ||
                   write_trans_queue[0].response_sent) @(posedge aclk);
            
            // Get the transaction to respond to
            current_trans = write_trans_queue[0];
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Starting B-channel response for id=%0d", current_trans.awid), UVM_HIGH)
            
            // Random delay before response (realistic slave behavior)
            repeat($urandom_range(1, b_response_delay)) @(posedge aclk);
            
            // Prepare write response with proper AXI4 compliance
            axi_intf.bid <= current_trans.awid;     // BID must match AWID per AXI4 spec
            axi_intf.bresp <= 2'b00;                // OKAY response (could be configurable)
            axi_intf.bvalid <= 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel response asserted: bid=%0d, bresp=2'b%02b (OKAY)", 
                      axi_intf.bid, axi_intf.bresp), UVM_MEDIUM)
            
            // Wait for BREADY handshake with timeout protection
            b_handshake_timeout = 0;
            while (!axi_intf.bready) begin
                @(posedge aclk);
                b_handshake_timeout++;
                if (b_handshake_timeout > 1000) begin
                    `uvm_error("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake timeout for id=%0d", current_trans.awid))
                    break;
                end
            end
            
            // Complete handshake - both BVALID and BREADY are high
            if (axi_intf.bready) begin
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("B-channel handshake completed for id=%0d", current_trans.awid), UVM_HIGH)
            end
            
            // Deassert BVALID on next clock edge per AXI4 protocol
            @(posedge aclk);
            axi_intf.bvalid <= 1'b0;
            axi_intf.bid <= '0;
            
            // Remove completed transaction from queue
            write_trans_queue.pop_front();
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write transaction completed for id=%0d", current_trans.awid), UVM_MEDIUM)
        end
    endtask
    
    // Read transaction coordination - using a proper transaction queue
    typedef struct {
        logic [ID_WIDTH-1:0] arid;
        logic [ADDR_WIDTH-1:0] araddr;
        logic [7:0] arlen;
        logic [2:0] arsize;
        logic [1:0] arburst;
        logic addr_received;
        logic data_sent;
    } read_transaction_t;
    
    read_transaction_t read_trans_queue[$];  // Transaction queue
    
    
        // Read Address Channel Handler
    task automatic handle_read_address_channel();
        read_transaction_t new_trans;
        forever begin
            axi_intf.arready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, ar_response_delay)) @(posedge aclk);
            axi_intf.arready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.arvalid && axi_intf.arready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            new_trans.arid = axi_intf.arid;
            new_trans.araddr = axi_intf.araddr;
            new_trans.arlen = axi_intf.arlen;
            new_trans.arsize = axi_intf.arsize;
            new_trans.arburst = axi_intf.arburst;
            new_trans.addr_received = 1'b1;
            new_trans.data_sent = 1'b0;
            
            // Add to transaction queue
            read_trans_queue.push_back(new_trans);
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      new_trans.arid, new_trans.araddr, new_trans.arlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.arready <= 1'b0;
        end
    endtask
    
        // Read Data Channel Handler
    task automatic handle_read_data_channel();
        int read_beat_count;
        logic [ADDR_WIDTH-1:0] beat_addr;
        logic [DATA_WIDTH-1:0] read_data;
        read_transaction_t current_trans;
        
        forever begin
            // Initialize signals to prevent unknown values
            axi_intf.rvalid <= 1'b0;
            axi_intf.rid <= '0;
            axi_intf.rdata <= '0;
            axi_intf.rresp <= 2'b00;
            axi_intf.rlast <= 1'b0;
            
            // Wait for a transaction with address received but data not sent
            while (read_trans_queue.size() == 0 || 
                   !read_trans_queue[0].addr_received || 
                   read_trans_queue[0].data_sent) @(posedge aclk);
            
            // Get the transaction to process
            current_trans = read_trans_queue[0];
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Starting R-channel response for id=%0d", current_trans.arid), UVM_HIGH)
            
            // Send read data beats
            for (read_beat_count = 0; read_beat_count <= current_trans.arlen; read_beat_count++) begin
                // Calculate beat address
                beat_addr = current_trans.araddr + (read_beat_count * (DATA_WIDTH/8));
                
                // Get data from memory (or generate if not written)
                if (memory.exists(beat_addr)) begin
                    read_data = memory[beat_addr];
                end else begin
                    // Initialize with pattern instead of random to avoid X propagation
                    read_data = {DATA_WIDTH{1'b0}} | beat_addr;  // Use address as data pattern
                end
                
                // Random delay before data
                repeat($urandom_range(0, r_response_delay)) @(posedge aclk);
                
                // Send read data with proper initialization
                axi_intf.rid <= current_trans.arid;
                axi_intf.rdata <= read_data;
                axi_intf.rresp <= 2'b00;  // OKAY response
                axi_intf.rlast <= (read_beat_count == current_trans.arlen);
                axi_intf.rvalid <= 1'b1;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read data beat %0d sent: id=%0d, addr=0x%010x, data=0x%016x, last=%0b", 
                          read_beat_count, current_trans.arid, beat_addr, read_data, axi_intf.rlast), UVM_HIGH)
                
                // Wait for rready with timeout
                begin
                    int r_timeout = 0;
                    while (!axi_intf.rready) begin
                        @(posedge aclk);
                        r_timeout++;
                        if (r_timeout > 1000) begin
                            `uvm_error("AXI_SLAVE_DRIVER_BFM", $sformatf("R-channel handshake timeout for id=%0d", current_trans.arid))
                            break;
                        end
                    end
                end
                
                @(posedge aclk);
                axi_intf.rvalid <= 1'b0;
                axi_intf.rlast <= 1'b0;
            end
            
            // Remove completed transaction from queue
            read_trans_queue.pop_front();
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read transaction completed for id=%0d", current_trans.arid), UVM_MEDIUM)
        end
    endtask
    
    // Initialize signals and start handling - ALWAYS READY approach

    // Ultra-simple slave BFM - always ready, immediate response
    initial begin
        // Initialize signals
        axi_intf.awready = '0;
        axi_intf.wready  = '0;
        axi_intf.bvalid  = '0;
        axi_intf.arready = '0;
        axi_intf.rvalid  = '0;
        
        // Wait for reset
        wait(aresetn == 1'b1);
        #10;
        
        // Set always ready
        axi_intf.awready <= 1'b1;
        axi_intf.wready  <= 1'b1;
        axi_intf.arready <= 1'b1;
        
        // Enhanced response loop for proper B and R channels
        fork
            // Write response handler
            begin
                logic [ID_WIDTH-1:0] write_id_queue[$];
                forever begin
                    @(posedge aclk);
                    
                    // Capture write address ID
                    if (axi_intf.awvalid && axi_intf.awready) begin
                        write_id_queue.push_back(axi_intf.awid);
                    end
                    
                    // Send write response when wlast received
                    if (axi_intf.wvalid && axi_intf.wready && axi_intf.wlast && !axi_intf.bvalid) begin
                        if (write_id_queue.size() > 0) begin
                            axi_intf.bid    <= write_id_queue.pop_front();
                            axi_intf.bresp  <= 2'b00;  // OKAY
                            axi_intf.bvalid <= 1'b1;
                        end
                    end
                    
                    // Clear response when accepted
                    if (axi_intf.bvalid && axi_intf.bready) begin
                        @(posedge aclk);
                        axi_intf.bvalid <= 1'b0;
                        axi_intf.bid <= '0;
                    end
                end
            end
            
            // Read response handler
            begin
                forever begin
                    @(posedge aclk);
                    
                    // Handle read request
                    if (axi_intf.arvalid && axi_intf.arready && !axi_intf.rvalid) begin
                        automatic logic [ID_WIDTH-1:0] read_id = axi_intf.arid;
                        automatic logic [7:0] read_len = axi_intf.arlen;
                        automatic logic [ADDR_WIDTH-1:0] read_addr = axi_intf.araddr;
                        
                        // Send read data beats
                        for (int i = 0; i <= read_len; i++) begin
                            @(posedge aclk);
                            axi_intf.rid    <= read_id;
                            axi_intf.rdata  <= {DATA_WIDTH{1'b0}} | (read_addr + i*8);  // Address-based pattern
                            axi_intf.rresp  <= 2'b00;  // OKAY
                            axi_intf.rlast  <= (i == read_len);
                            axi_intf.rvalid <= 1'b1;
                            
                            // Wait for ready
                            while (!axi_intf.rready) @(posedge aclk);
                            @(posedge aclk);
                            axi_intf.rvalid <= 1'b0;
                            axi_intf.rlast  <= 1'b0;
                        end
                    end
                end
            end
        join_none
    end

endmodule : axi4_slave_driver_bfm
