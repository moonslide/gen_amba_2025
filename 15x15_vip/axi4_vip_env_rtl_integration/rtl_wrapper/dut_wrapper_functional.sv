//==============================================================================
// DUT Wrapper for 15x15 RTL Integration with Functional Interconnect
// Provides basic routing functionality for testing
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-09
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 10,
    parameter NUM_MASTERS = 15,
    parameter NUM_SLAVES = 15
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave master_if[NUM_MASTERS],  // Master interfaces from VIP
    axi4_if.master slave_if[NUM_SLAVES]    // Slave interfaces to VIP slave BFMs
);

    // Instantiate functional interconnect
    axi_interconnect_functional #(
        .ADDR_WIDTH(ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH),
        .NUM_MASTERS(NUM_MASTERS),
        .NUM_SLAVES(NUM_SLAVES)
    ) axi_interconnect (
        .aclk(clk),
        .aresetn(rst_n),
        .master_if(master_if),
        .slave_if(slave_if)
    );
    
    initial begin
        $display("[%0t] DUT Wrapper: 15x15 Configuration with Functional Interconnect", $time);
        $display("[%0t] DUT Wrapper: Basic routing enabled for testing", $time);
    end

endmodule : dut_wrapper

//==============================================================================
// Functional AXI Interconnect Module
// Provides basic routing - connects each master to a corresponding slave
//==============================================================================

module axi_interconnect_functional #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 10,
    parameter NUM_MASTERS = 15,
    parameter NUM_SLAVES = 15
) (
    input  logic aclk,
    input  logic aresetn,
    axi4_if.slave master_if[NUM_MASTERS],  // Master interfaces from VIP
    axi4_if.master slave_if[NUM_SLAVES]    // Slave interfaces to VIP slave BFMs
);

    // Simple routing strategy for testing:
    // Route each master to slave based on address bits
    // Default: Master 0 -> Slave 0, Master 1 -> Slave 1, etc.
    // If address[43:40] != 0, route to that slave number
    
    genvar m, s;
    generate
        // For each master, route to appropriate slave
        for (m = 0; m < NUM_MASTERS; m++) begin : gen_master_routing
            // Determine target slave based on address
            logic [3:0] target_slave_aw;
            logic [3:0] target_slave_ar;
            
            always_comb begin
                // Default routing: master m -> slave m (modulo NUM_SLAVES)
                target_slave_aw = m % NUM_SLAVES;
                target_slave_ar = m % NUM_SLAVES;
                
                // Override based on address bits if non-zero
                if (master_if[m].awaddr[43:40] != 0 && master_if[m].awaddr[43:40] < NUM_SLAVES) begin
                    target_slave_aw = master_if[m].awaddr[43:40];
                end
                if (master_if[m].araddr[43:40] != 0 && master_if[m].araddr[43:40] < NUM_SLAVES) begin
                    target_slave_ar = master_if[m].araddr[43:40];
                end
            end
            
            // Connect master responses back
            always_comb begin
                // Default: no response
                master_if[m].awready = 1'b0;
                master_if[m].wready = 1'b0;
                master_if[m].bid = '0;
                master_if[m].bresp = 2'b00;
                master_if[m].bvalid = 1'b0;
                master_if[m].arready = 1'b0;
                master_if[m].rid = '0;
                master_if[m].rdata = '0;
                master_if[m].rresp = 2'b00;
                master_if[m].rlast = 1'b0;
                master_if[m].rvalid = 1'b0;
                
                // Connect to target slaves
                for (int s = 0; s < NUM_SLAVES; s++) begin
                    if (s == target_slave_aw) begin
                        master_if[m].awready = slave_if[s].awready;
                        master_if[m].wready = slave_if[s].wready;
                        master_if[m].bid = slave_if[s].bid;
                        master_if[m].bresp = slave_if[s].bresp;
                        master_if[m].bvalid = slave_if[s].bvalid;
                    end
                    if (s == target_slave_ar) begin
                        master_if[m].arready = slave_if[s].arready;
                        master_if[m].rid = slave_if[s].rid;
                        master_if[m].rdata = slave_if[s].rdata;
                        master_if[m].rresp = slave_if[s].rresp;
                        master_if[m].rlast = slave_if[s].rlast;
                        master_if[m].rvalid = slave_if[s].rvalid;
                    end
                end
            end
        end
        
        // For each slave, connect from appropriate master
        for (s = 0; s < NUM_SLAVES; s++) begin : gen_slave_routing
            // Track which master is connected
            logic [3:0] connected_master_aw;
            logic [3:0] connected_master_ar;
            logic master_connected_aw;
            logic master_connected_ar;
            
            always_comb begin
                // Check which master wants to connect to this slave
                connected_master_aw = 0;
                connected_master_ar = 0;
                master_connected_aw = 1'b0;
                master_connected_ar = 1'b0;
                
                for (int m = 0; m < NUM_MASTERS; m++) begin
                    // Check write address channel
                    if ((m % NUM_SLAVES == s) || 
                        (master_if[m].awaddr[43:40] == s && master_if[m].awaddr[43:40] != 0)) begin
                        if (master_if[m].awvalid && !master_connected_aw) begin
                            connected_master_aw = m;
                            master_connected_aw = 1'b1;
                        end
                    end
                    // Check read address channel
                    if ((m % NUM_SLAVES == s) || 
                        (master_if[m].araddr[43:40] == s && master_if[m].araddr[43:40] != 0)) begin
                        if (master_if[m].arvalid && !master_connected_ar) begin
                            connected_master_ar = m;
                            master_connected_ar = 1'b1;
                        end
                    end
                end
                
                // Connect slave to the selected master
                if (master_connected_aw) begin
                    slave_if[s].awid = master_if[connected_master_aw].awid;
                    slave_if[s].awaddr = master_if[connected_master_aw].awaddr;
                    slave_if[s].awlen = master_if[connected_master_aw].awlen;
                    slave_if[s].awsize = master_if[connected_master_aw].awsize;
                    slave_if[s].awburst = master_if[connected_master_aw].awburst;
                    slave_if[s].awlock = master_if[connected_master_aw].awlock;
                    slave_if[s].awcache = master_if[connected_master_aw].awcache;
                    slave_if[s].awprot = master_if[connected_master_aw].awprot;
                    slave_if[s].awqos = master_if[connected_master_aw].awqos;
                    slave_if[s].awregion = master_if[connected_master_aw].awregion;
                    slave_if[s].awvalid = master_if[connected_master_aw].awvalid;
                    
                    slave_if[s].wdata = master_if[connected_master_aw].wdata;
                    slave_if[s].wstrb = master_if[connected_master_aw].wstrb;
                    slave_if[s].wlast = master_if[connected_master_aw].wlast;
                    slave_if[s].wvalid = master_if[connected_master_aw].wvalid;
                    
                    slave_if[s].bready = master_if[connected_master_aw].bready;
                end else begin
                    // No master connected - drive safe defaults
                    slave_if[s].awid = '0;
                    slave_if[s].awaddr = '0;
                    slave_if[s].awlen = '0;
                    slave_if[s].awsize = '0;
                    slave_if[s].awburst = '0;
                    slave_if[s].awlock = '0;
                    slave_if[s].awcache = '0;
                    slave_if[s].awprot = '0;
                    slave_if[s].awqos = '0;
                    slave_if[s].awregion = '0;
                    slave_if[s].awvalid = 1'b0;
                    
                    slave_if[s].wdata = '0;
                    slave_if[s].wstrb = '0;
                    slave_if[s].wlast = 1'b0;
                    slave_if[s].wvalid = 1'b0;
                    
                    slave_if[s].bready = 1'b1;
                end
                
                if (master_connected_ar) begin
                    slave_if[s].arid = master_if[connected_master_ar].arid;
                    slave_if[s].araddr = master_if[connected_master_ar].araddr;
                    slave_if[s].arlen = master_if[connected_master_ar].arlen;
                    slave_if[s].arsize = master_if[connected_master_ar].arsize;
                    slave_if[s].arburst = master_if[connected_master_ar].arburst;
                    slave_if[s].arlock = master_if[connected_master_ar].arlock;
                    slave_if[s].arcache = master_if[connected_master_ar].arcache;
                    slave_if[s].arprot = master_if[connected_master_ar].arprot;
                    slave_if[s].arqos = master_if[connected_master_ar].arqos;
                    slave_if[s].arregion = master_if[connected_master_ar].arregion;
                    slave_if[s].arvalid = master_if[connected_master_ar].arvalid;
                    
                    slave_if[s].rready = master_if[connected_master_ar].rready;
                end else begin
                    // No master connected - drive safe defaults
                    slave_if[s].arid = '0;
                    slave_if[s].araddr = '0;
                    slave_if[s].arlen = '0;
                    slave_if[s].arsize = '0;
                    slave_if[s].arburst = '0;
                    slave_if[s].arlock = '0;
                    slave_if[s].arcache = '0;
                    slave_if[s].arprot = '0;
                    slave_if[s].arqos = '0;
                    slave_if[s].arregion = '0;
                    slave_if[s].arvalid = 1'b0;
                    
                    slave_if[s].rready = 1'b1;
                end
            end
        end
    endgenerate
    
    // Monitor connectivity
    initial begin
        $display("[%0t] AXI Interconnect Functional: Instantiated", $time);
        @(posedge aclk);
        $display("[%0t] AXI Interconnect Functional: Clock detected", $time);
        @(posedge aresetn);
        $display("[%0t] AXI Interconnect Functional: Reset released", $time);
        $display("[%0t] AXI Interconnect Functional: Routing enabled - Master N -> Slave N (default)", $time);
    end

endmodule : axi_interconnect_functional