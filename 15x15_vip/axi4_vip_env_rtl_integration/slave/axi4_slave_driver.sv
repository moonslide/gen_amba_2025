//==============================================================================
// AXI4 Slave Driver with Proper BID Response Handling
// Fixed to echo AWID as BID per AXI4 specification
// Generated by AMBA Bus Matrix Configuration Tool - BID Response Fix  
//==============================================================================

    class axi4_slave_driver extends uvm_driver #(axi4_slave_tx);
        `uvm_component_utils(axi4_slave_driver)
        
        virtual axi4_if vif;
        
        function new(string name = "axi4_slave_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
                `uvm_fatal("NOVIF", "Virtual interface not found in config_db")
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting slave driver with proper BID response", UVM_LOW)
            
            // Always ready for transactions
            vif.awready <= 1'b1;
            vif.wready <= 1'b1;
            vif.arready <= 1'b1;
            
            fork
                handle_write_transactions();
                handle_read_transactions();
            join
        endtask
        
        virtual task handle_write_transactions();
            bit [3:0] captured_awid;
            
            forever begin
                // Capture AWID during AW handshake
                @(posedge vif.aclk);
                if (vif.awvalid && vif.awready) begin
                    captured_awid = vif.awid;
                    `uvm_info(get_type_name(), $sformatf("Write address captured: AWID=%0d, ADDR=0x%0h", captured_awid, vif.awaddr), UVM_MEDIUM)
                    
                    // Wait for WLAST to complete data phase
                    while (!(vif.wvalid && vif.wready && vif.wlast)) begin
                        @(posedge vif.aclk);
                    end
                    
                    // Drive write response with matching BID
                    @(posedge vif.aclk);
                    vif.bid <= captured_awid;    // IHI0022D: BID must match AWID
                    vif.bresp <= 2'b00;          // OKAY response
                    vif.bvalid <= 1'b1;
                    
                    `uvm_info(get_type_name(), $sformatf("B-response: BID=%0d (matching AWID), BRESP=OKAY", captured_awid), UVM_MEDIUM)
                    
                    // Wait for BREADY handshake
                    while (!vif.bready) @(posedge vif.aclk);
                    
                    @(posedge vif.aclk);
                    vif.bvalid <= 1'b0;
                    vif.bid <= '0;
                    vif.bresp <= '0;
                    
                    `uvm_info(get_type_name(), $sformatf("Write transaction complete for BID=%0d", captured_awid), UVM_MEDIUM)
                end
            end
        endtask
        
        virtual task handle_read_transactions();
            bit [3:0] captured_arid;
            bit [7:0] captured_arlen;
            
            forever begin
                @(posedge vif.aclk);
                if (vif.arvalid && vif.arready) begin
                    captured_arid = vif.arid;
                    captured_arlen = vif.arlen;
                    `uvm_info(get_type_name(), $sformatf("Read address: ARID=%0d, ADDR=0x%0h, LEN=%0d", captured_arid, vif.araddr, captured_arlen), UVM_MEDIUM)
                    
                    // Drive read data response
                    for (int beat = 0; beat <= captured_arlen; beat++) begin
                        @(posedge vif.aclk);
                        vif.rid <= captured_arid;     // RID must match ARID
                        vif.rdata <= {DATA_WIDTH{1'b0}} | beat; // Simple data pattern
                        vif.rresp <= 2'b00;           // OKAY response
                        vif.rlast <= (beat == captured_arlen);
                        vif.rvalid <= 1'b1;
                        
                        while (!vif.rready) @(posedge vif.aclk);
                        `uvm_info(get_type_name(), $sformatf("Read beat %0d: RID=%0d, RLAST=%0b", beat, captured_arid, vif.rlast), UVM_HIGH)
                    end
                    
                    @(posedge vif.aclk);
                    vif.rvalid <= 1'b0;
                    vif.rid <= '0;
                    vif.rdata <= '0;
                    vif.rresp <= '0;
                    vif.rlast <= 1'b0;
                    
                    `uvm_info(get_type_name(), $sformatf("Read transaction complete for RID=%0d", captured_arid), UVM_MEDIUM)
                end
            end
        endtask
        
    endclass