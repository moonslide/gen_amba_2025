//==============================================================================
// AXI4 Master Monitor with Analysis Port Transaction Broadcasting  
// Fixed to properly send transactions to scoreboard analysis fifos
// Generated by AMBA Bus Matrix Configuration Tool - Analysis Port Fix
//==============================================================================

    class axi4_master_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_master_monitor)
        
        // Virtual interface handle
        virtual axi4_if vif;
        
        // Analysis port to send transactions to scoreboard
        uvm_analysis_port #(axi4_master_tx) analysis_port;
        
        function new(string name = "axi4_master_monitor", uvm_component parent = null);
            super.new(name, parent);
            analysis_port = new("analysis_port", this);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            // Get virtual interface from config_db
            if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
                `uvm_fatal("NOVIF", "Virtual interface not found in config_db")
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master monitor with analysis port broadcasting", UVM_LOW)
            
            fork
                monitor_write_transactions();
                monitor_read_transactions();
            join
        endtask
        
        virtual task monitor_write_transactions();
            axi4_master_tx tx;
            bit [ADDRESS_WIDTH-1:0] addr;
            bit [7:0] len;
            bit [3:0] id;
            
            forever begin
                // Monitor AW channel handshake
                @(posedge vif.aclk);
                if (vif.awvalid && vif.awready) begin
                    addr = vif.awaddr;
                    len = vif.awlen; 
                    id = vif.awid;
                    
                    `uvm_info(get_type_name(), $sformatf("AW handshake detected: AWID=%0d, ADDR=0x%0h, LEN=%0d", 
                              id, addr, len), UVM_MEDIUM)
                    
                    // Create transaction object for scoreboard
                    tx = axi4_master_tx::type_id::create("monitored_tx");
                    tx.tx_type = axi4_master_tx::WRITE;
                    tx.awaddr = addr;
                    tx.awlen = len;
                    tx.awid = id;
                    tx.awsize = vif.awsize;
                    tx.awburst = vif.awburst;
                    tx.awlock = vif.awlock;
                    tx.awcache = vif.awcache;
                    tx.awprot = vif.awprot;
                    tx.awqos = vif.awqos;
                    tx.awregion = vif.awregion;
                    
                    // Wait for complete write transaction (including WLAST)
                    wait_for_write_completion(tx);
                    
                    // Broadcast to scoreboard via analysis port
                    analysis_port.write(tx);
                    `uvm_info(get_type_name(), $sformatf("*** WRITE TX BROADCAST *** to scoreboard: ID=%0d", tx.awid), UVM_MEDIUM)
                end
            end
        endtask
        
        virtual task wait_for_write_completion(axi4_master_tx tx);
            // Monitor all write data beats until WLAST
            int beat_count = 0;
            
            while (beat_count <= tx.awlen) begin
                @(posedge vif.aclk);
                if (vif.wvalid && vif.wready) begin
                    `uvm_info(get_type_name(), $sformatf("Write beat %0d: WLAST=%0b", beat_count, vif.wlast), UVM_HIGH)
                    
                    if (vif.wlast) begin
                        `uvm_info(get_type_name(), $sformatf("WLAST observed for AWID=%0d after %0d beats", tx.awid, beat_count), UVM_MEDIUM)
                        break;
                    end
                    beat_count++;
                end
            end
            
            // Wait for B-channel response
            @(posedge vif.aclk);
            while (!vif.bvalid) @(posedge vif.aclk);
            `uvm_info(get_type_name(), $sformatf("Write transaction complete: AWID=%0d, BID=%0d", tx.awid, vif.bid), UVM_MEDIUM)
        endtask
        
        virtual task monitor_read_transactions();
            axi4_master_tx tx;
            
            forever begin
                // Monitor AR channel handshake
                @(posedge vif.aclk);
                if (vif.arvalid && vif.arready) begin
                    // Create read transaction for scoreboard
                    tx = axi4_master_tx::type_id::create("monitored_read_tx");
                    tx.tx_type = axi4_master_tx::READ;
                    tx.araddr = vif.araddr;
                    tx.arlen = vif.arlen;
                    tx.arid = vif.arid;
                    tx.arsize = vif.arsize;
                    tx.arburst = vif.arburst;
                    tx.arlock = vif.arlock;
                    tx.arcache = vif.arcache;
                    tx.arprot = vif.arprot;
                    tx.arqos = vif.arqos;
                    tx.arregion = vif.arregion;
                    
                    // Wait for read completion
                    wait_for_read_completion(tx);
                    
                    // Broadcast to scoreboard
                    analysis_port.write(tx);
                    `uvm_info(get_type_name(), $sformatf("*** READ TX BROADCAST *** to scoreboard: ID=%0d", tx.arid), UVM_MEDIUM)
                end
            end
        endtask
        
        virtual task wait_for_read_completion(axi4_master_tx tx);
            int beat_count = 0;
            
            while (beat_count <= tx.arlen) begin
                @(posedge vif.aclk);
                if (vif.rvalid && vif.rready) begin
                    if (vif.rlast) begin
                        `uvm_info(get_type_name(), $sformatf("Read transaction complete: ARID=%0d, RID=%0d", tx.arid, vif.rid), UVM_MEDIUM)
                        break;
                    end
                    beat_count++;
                end
            end
        endtask
        
    endclass