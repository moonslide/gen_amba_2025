//==============================================================================
// AXI4 Configuration Reader - Interface between GUI and UVM simulation
// Reads JSON configuration files generated by the GUI
//==============================================================================

`ifndef AXI4_CONFIG_READER_SV
`define AXI4_CONFIG_READER_SV

class axi4_config_reader extends uvm_object;
    
    `uvm_object_utils(axi4_config_reader)
    
    // Configuration data structure
    typedef struct {
        string name;
        bit [63:0] base_addr;
        bit [63:0] size_bytes;
        int priority;
        bit secure_only;
        bit privileged_only;
        string memory_type;
        int read_latency_min;
        int read_latency_max;
        int write_latency_min;
        int write_latency_max;
    } slave_config_t;
    
    typedef struct {
        string name;
        int id_width;
        int priority;
        bit qos_support;
        bit exclusive_support;
        int user_width;
        bit [2:0] default_prot;
        bit [3:0] default_cache;
        bit [3:0] default_region;
    } master_config_t;
    
    typedef struct {
        string bus_type;        // "AXI4", "AXI3", "AHB", "APB"
        int addr_width;
        int data_width;
        int id_width;
        int user_width;
        string arbitration;     // "FIXED", "RR", "QOS", "WRR"
        string vip_mode;        // "BEHAVIORAL" or "RTL"
        string rtl_path;        // Path to RTL file when vip_mode=RTL
        master_config_t masters[];
        slave_config_t slaves[];
    } bus_config_t;
    
    // Configuration storage
    bus_config_t bus_config;
    string config_file_path;
    bit config_loaded;
    
    // Statistics
    int num_masters;
    int num_slaves;
    bit [63:0] total_memory_size;
    
    function new(string name = "axi4_config_reader");
        super.new(name);
        config_loaded = 0;
        num_masters = 0;
        num_slaves = 0;
        total_memory_size = 0;
    endfunction
    
    // Load configuration from JSON file generated by GUI
    virtual function bit load_config_from_file(string file_path);
        int file_handle;
        string line;
        string json_content = "";
        
        config_file_path = file_path;
        
        `uvm_info(get_type_name(), $sformatf("Loading configuration from: %s", file_path), UVM_MEDIUM)
        
        // Open and read the JSON file
        file_handle = $fopen(file_path, "r");
        if (file_handle == 0) begin
            `uvm_error(get_type_name(), $sformatf("Failed to open config file: %s", file_path))
            return 0;
        end
        
        // Read entire file content
        while (!$feof(file_handle)) begin
            $fgets(line, file_handle);
            json_content = {json_content, line};
        end
        $fclose(file_handle);
        
        // Parse JSON content (simplified parser for demonstration)
        if (!parse_json_config(json_content)) begin
            `uvm_error(get_type_name(), "Failed to parse JSON configuration")
            return 0;
        end
        
        config_loaded = 1;
        calculate_statistics();
        print_config_summary();
        
        `uvm_info(get_type_name(), "Configuration loaded successfully", UVM_MEDIUM)
        return 1;
    endfunction
    
    // Simplified JSON parser (in real implementation, use proper JSON library)
    virtual function bit parse_json_config(string json_content);
        // This is a simplified parser - in a real implementation,
        // you would use a proper JSON parsing library or DPI calls
        
        // For demonstration, set default values
        bus_config.bus_type = "AXI4";
        bus_config.addr_width = 32;
        bus_config.data_width = 64;
        bus_config.id_width = 4;
        bus_config.user_width = 1;
        bus_config.arbitration = "QOS";
        bus_config.vip_mode = "BEHAVIORAL";
        bus_config.rtl_path = "";
        
        // Parse masters (simplified)
        num_masters = 2; // Default
        bus_config.masters = new[num_masters];
        bus_config.masters[0].name = "CPU_MASTER";
        bus_config.masters[0].priority = 10;
        bus_config.masters[0].qos_support = 1;
        bus_config.masters[0].exclusive_support = 1;
        
        bus_config.masters[1].name = "DMA_MASTER";
        bus_config.masters[1].priority = 5;
        bus_config.masters[1].qos_support = 1;
        bus_config.masters[1].exclusive_support = 0;
        
        // Parse slaves (simplified)
        num_slaves = 3; // Default
        bus_config.slaves = new[num_slaves];
        bus_config.slaves[0].name = "MEMORY";
        bus_config.slaves[0].base_addr = 64'h1000_0000;
        bus_config.slaves[0].size_bytes = 64'h1000_0000; // 256MB
        bus_config.slaves[0].memory_type = "Memory";
        bus_config.slaves[0].read_latency_min = 1;
        bus_config.slaves[0].read_latency_max = 5;
        bus_config.slaves[0].write_latency_min = 1;
        bus_config.slaves[0].write_latency_max = 5;
        
        bus_config.slaves[1].name = "PERIPHERAL1";
        bus_config.slaves[1].base_addr = 64'h2000_0000;
        bus_config.slaves[1].size_bytes = 64'h0010_0000; // 1MB
        bus_config.slaves[1].memory_type = "Peripheral";
        bus_config.slaves[1].read_latency_min = 2;
        bus_config.slaves[1].read_latency_max = 10;
        
        bus_config.slaves[2].name = "PERIPHERAL2";
        bus_config.slaves[2].base_addr = 64'h3000_0000;
        bus_config.slaves[2].size_bytes = 64'h0010_0000; // 1MB
        bus_config.slaves[2].memory_type = "Peripheral";
        
        return 1;
    endfunction
    
    // Load configuration from command line arguments
    virtual function bit load_config_from_args();
        string config_path;
        
        // Check for +CONFIG_FILE argument
        if ($value$plusargs("CONFIG_FILE=%s", config_path)) begin
            return load_config_from_file(config_path);
        end
        
        // Check for individual configuration arguments
        if ($test$plusargs("BUS_TYPE")) begin
            $value$plusargs("BUS_TYPE=%s", bus_config.bus_type);
        end else begin
            bus_config.bus_type = "AXI4";
        end
        
        if ($test$plusargs("ADDR_WIDTH")) begin
            $value$plusargs("ADDR_WIDTH=%d", bus_config.addr_width);
        end else begin
            bus_config.addr_width = 32;
        end
        
        if ($test$plusargs("DATA_WIDTH")) begin
            $value$plusargs("DATA_WIDTH=%d", bus_config.data_width);
        end else begin
            bus_config.data_width = 64;
        end
        
        // Set default configuration if no file provided
        set_default_config();
        config_loaded = 1;
        
        return 1;
    endfunction
    
    // Set default configuration for standalone testing
    virtual function void set_default_config();
        bus_config.bus_type = "AXI4";
        bus_config.addr_width = 32;
        bus_config.data_width = 64;
        bus_config.id_width = 4;
        bus_config.user_width = 1;
        bus_config.arbitration = "QOS";
        bus_config.vip_mode = "BEHAVIORAL";
        bus_config.rtl_path = "";
        
        // Default masters
        num_masters = 1;
        bus_config.masters = new[1];
        bus_config.masters[0].name = "TEST_MASTER";
        bus_config.masters[0].priority = 10;
        bus_config.masters[0].qos_support = 1;
        bus_config.masters[0].exclusive_support = 1;
        
        // Default slaves
        num_slaves = 1;
        bus_config.slaves = new[1];
        bus_config.slaves[0].name = "TEST_SLAVE";
        bus_config.slaves[0].base_addr = 64'h1000_0000;
        bus_config.slaves[0].size_bytes = 64'h1000_0000;
        bus_config.slaves[0].memory_type = "Memory";
        bus_config.slaves[0].read_latency_min = 1;
        bus_config.slaves[0].read_latency_max = 10;
        bus_config.slaves[0].write_latency_min = 1;
        bus_config.slaves[0].write_latency_max = 10;
        
        calculate_statistics();
    endfunction
    
    // Apply configuration to UVM environment
    virtual function void apply_to_uvm_config();
        if (!config_loaded) begin
            `uvm_warning(get_type_name(), "Configuration not loaded, using defaults")
            set_default_config();
        end
        
        // Set global configuration in UVM config DB
        uvm_config_db#(string)::set(null, "*", "bus_type", bus_config.bus_type);
        uvm_config_db#(int)::set(null, "*", "addr_width", bus_config.addr_width);
        uvm_config_db#(int)::set(null, "*", "data_width", bus_config.data_width);
        uvm_config_db#(int)::set(null, "*", "id_width", bus_config.id_width);
        uvm_config_db#(int)::set(null, "*", "user_width", bus_config.user_width);
        uvm_config_db#(string)::set(null, "*", "vip_mode", bus_config.vip_mode);
        uvm_config_db#(string)::set(null, "*", "rtl_path", bus_config.rtl_path);
        
        // Configure slave agents
        for (int i = 0; i < num_slaves; i++) begin
            string slave_path = $sformatf("*slave_agent_%0d*", i);
            uvm_config_db#(bit [63:0])::set(null, slave_path, "base_address", bus_config.slaves[i].base_addr);
            uvm_config_db#(bit [63:0])::set(null, slave_path, "size_bytes", bus_config.slaves[i].size_bytes);
            uvm_config_db#(string)::set(null, slave_path, "agent_name", bus_config.slaves[i].name);
            
            // Set latency parameters
            uvm_config_db#(int)::set(null, {slave_path, ".s_driver"}, "read_latency_min", bus_config.slaves[i].read_latency_min);
            uvm_config_db#(int)::set(null, {slave_path, ".s_driver"}, "read_latency_max", bus_config.slaves[i].read_latency_max);
            uvm_config_db#(int)::set(null, {slave_path, ".s_driver"}, "write_latency_min", bus_config.slaves[i].write_latency_min);
            uvm_config_db#(int)::set(null, {slave_path, ".s_driver"}, "write_latency_max", bus_config.slaves[i].write_latency_max);
        end
        
        // Configure master agents
        for (int i = 0; i < num_masters; i++) begin
            string master_path = $sformatf("*master_agent_%0d*", i);
            uvm_config_db#(string)::set(null, master_path, "agent_name", bus_config.masters[i].name);
        end
        
        `uvm_info(get_type_name(), "Configuration applied to UVM environment", UVM_MEDIUM)
    endfunction
    
    // Calculate statistics
    virtual function void calculate_statistics();
        total_memory_size = 0;
        for (int i = 0; i < num_slaves; i++) begin
            total_memory_size += bus_config.slaves[i].size_bytes;
        end
    endfunction
    
    // Print configuration summary
    virtual function void print_config_summary();
        `uvm_info(get_type_name(), "=== AXI4 Configuration Summary ===", UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Bus Type: %s", bus_config.bus_type), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Address Width: %0d bits", bus_config.addr_width), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Data Width: %0d bits", bus_config.data_width), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("ID Width: %0d bits", bus_config.id_width), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Masters: %0d", num_masters), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Slaves: %0d", num_slaves), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Total Memory: %0d MB", total_memory_size/(1024*1024)), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("Arbitration: %s", bus_config.arbitration), UVM_LOW)
        `uvm_info(get_type_name(), $sformatf("VIP Mode: %s", bus_config.vip_mode), UVM_LOW)
        if (bus_config.vip_mode == "RTL" && bus_config.rtl_path != "") begin
            `uvm_info(get_type_name(), $sformatf("RTL Path: %s", bus_config.rtl_path), UVM_LOW)
        end
        
        // Print slave details
        `uvm_info(get_type_name(), "--- Slave Configuration ---", UVM_LOW)
        for (int i = 0; i < num_slaves; i++) begin
            `uvm_info(get_type_name(), $sformatf("  [%0d] %s: 0x%0h - 0x%0h (%0d MB)", 
                                                 i, bus_config.slaves[i].name,
                                                 bus_config.slaves[i].base_addr,
                                                 bus_config.slaves[i].base_addr + bus_config.slaves[i].size_bytes - 1,
                                                 bus_config.slaves[i].size_bytes/(1024*1024)), UVM_LOW)
        end
        
        // Print master details
        `uvm_info(get_type_name(), "--- Master Configuration ---", UVM_LOW)
        for (int i = 0; i < num_masters; i++) begin
            `uvm_info(get_type_name(), $sformatf("  [%0d] %s: Priority=%0d, QoS=%0b, Exclusive=%0b", 
                                                 i, bus_config.masters[i].name,
                                                 bus_config.masters[i].priority,
                                                 bus_config.masters[i].qos_support,
                                                 bus_config.masters[i].exclusive_support), UVM_LOW)
        end
        
        `uvm_info(get_type_name(), "=================================", UVM_LOW)
    endfunction
    
    // Get configuration data
    virtual function bus_config_t get_bus_config();
        return bus_config;
    endfunction
    
    virtual function slave_config_t get_slave_config(int index);
        if (index >= 0 && index < num_slaves) begin
            return bus_config.slaves[index];
        end else begin
            `uvm_error(get_type_name(), $sformatf("Invalid slave index: %0d", index))
            return bus_config.slaves[0]; // Return first as fallback
        end
    endfunction
    
    virtual function master_config_t get_master_config(int index);
        if (index >= 0 && index < num_masters) begin
            return bus_config.masters[index];
        end else begin
            `uvm_error(get_type_name(), $sformatf("Invalid master index: %0d", index))
            return bus_config.masters[0]; // Return first as fallback
        end
    endfunction
    
    // Validation functions
    virtual function bit validate_config();
        bit valid = 1;
        
        // Check address overlaps
        for (int i = 0; i < num_slaves; i++) begin
            for (int j = i+1; j < num_slaves; j++) begin
                bit [63:0] end_i = bus_config.slaves[i].base_addr + bus_config.slaves[i].size_bytes - 1;
                bit [63:0] end_j = bus_config.slaves[j].base_addr + bus_config.slaves[j].size_bytes - 1;
                
                if ((bus_config.slaves[i].base_addr <= end_j) && 
                    (bus_config.slaves[j].base_addr <= end_i)) begin
                    `uvm_error(get_type_name(), $sformatf("Address overlap between %s and %s", 
                                                          bus_config.slaves[i].name, bus_config.slaves[j].name))
                    valid = 0;
                end
            end
        end
        
        // Check bus type support
        if (!(bus_config.bus_type inside {"AXI4", "AXI3", "AHB", "APB"})) begin
            `uvm_error(get_type_name(), $sformatf("Unsupported bus type: %s", bus_config.bus_type))
            valid = 0;
        end
        
        // Check data width
        if (!(bus_config.data_width inside {32, 64, 128, 256, 512})) begin
            `uvm_error(get_type_name(), $sformatf("Unsupported data width: %0d", bus_config.data_width))
            valid = 0;
        end
        
        return valid;
    endfunction
    
    // Export configuration to file (for GUI integration)
    virtual function bit export_config_to_file(string file_path);
        int file_handle;
        
        file_handle = $fopen(file_path, "w");
        if (file_handle == 0) begin
            `uvm_error(get_type_name(), $sformatf("Failed to create export file: %s", file_path))
            return 0;
        end
        
        // Write JSON format (simplified)
        $fwrite(file_handle, "{\n");
        $fwrite(file_handle, "  \"bus_type\": \"%s\",\n", bus_config.bus_type);
        $fwrite(file_handle, "  \"addr_width\": %0d,\n", bus_config.addr_width);
        $fwrite(file_handle, "  \"data_width\": %0d,\n", bus_config.data_width);
        $fwrite(file_handle, "  \"id_width\": %0d,\n", bus_config.id_width);
        $fwrite(file_handle, "  \"arbitration\": \"%s\",\n", bus_config.arbitration);
        
        // Write slaves
        $fwrite(file_handle, "  \"slaves\": [\n");
        for (int i = 0; i < num_slaves; i++) begin
            $fwrite(file_handle, "    {\n");
            $fwrite(file_handle, "      \"name\": \"%s\",\n", bus_config.slaves[i].name);
            $fwrite(file_handle, "      \"base_addr\": \"0x%0h\",\n", bus_config.slaves[i].base_addr);
            $fwrite(file_handle, "      \"size_bytes\": \"0x%0h\",\n", bus_config.slaves[i].size_bytes);
            $fwrite(file_handle, "      \"memory_type\": \"%s\"\n", bus_config.slaves[i].memory_type);
            $fwrite(file_handle, "    }%s\n", (i == num_slaves-1) ? "" : ",");
        end
        $fwrite(file_handle, "  ],\n");
        
        // Write masters
        $fwrite(file_handle, "  \"masters\": [\n");
        for (int i = 0; i < num_masters; i++) begin
            $fwrite(file_handle, "    {\n");
            $fwrite(file_handle, "      \"name\": \"%s\",\n", bus_config.masters[i].name);
            $fwrite(file_handle, "      \"priority\": %0d,\n", bus_config.masters[i].priority);
            $fwrite(file_handle, "      \"qos_support\": %0b,\n", bus_config.masters[i].qos_support);
            $fwrite(file_handle, "      \"exclusive_support\": %0b\n", bus_config.masters[i].exclusive_support);
            $fwrite(file_handle, "    }%s\n", (i == num_masters-1) ? "" : ",");
        end
        $fwrite(file_handle, "  ]\n");
        $fwrite(file_handle, "}\n");
        
        $fclose(file_handle);
        `uvm_info(get_type_name(), $sformatf("Configuration exported to: %s", file_path), UVM_MEDIUM)
        return 1;
    endfunction
    
endclass : axi4_config_reader

`endif // AXI4_CONFIG_READER_SV