//==============================================================================
// AXI4 Master Driver BFM - Drives AXI interface signals for visibility
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-04
//==============================================================================

module axi4_master_driver_bfm #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 64,
    parameter ID_WIDTH   = 4
)(
    input aclk, 
    input aresetn,
    axi4_if.master axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Control signals for BFM operation
    bit enable_auto_drive = 0;
    bit bfm_enable = 0;
    int transaction_count = 0;
    
    // Driver task to generate AXI transactions for visibility
    task automatic drive_axi_transactions();
        int transaction_id = 0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", "Starting AXI transaction generation for waveform visibility", UVM_LOW)
        
        // Wait for reset deassertion
        wait(aresetn == 1'b1);
        repeat(10) @(posedge aclk);
        
        forever begin
            transaction_id++;
            
            // Random delay between transactions
            repeat($urandom_range(5, 20)) @(posedge aclk);
            
            // Generate write transaction
            drive_write_transaction(transaction_id);
            
            // Random delay
            repeat($urandom_range(5, 15)) @(posedge aclk);
            
            // Generate read transaction
            drive_read_transaction(transaction_id);
            
            // Increment transaction counter
            transaction_count++;
            
            // Limit transaction rate and check if still enabled
            repeat($urandom_range(20, 50)) @(posedge aclk);
            
            // Exit if BFM is disabled
            if (!bfm_enable) begin
                `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving disabled, stopping transactions", UVM_LOW)
                break;
            end
        end
    endtask
    
    // Drive a write transaction
    task automatic drive_write_transaction(int trans_id);
        logic [ADDR_WIDTH-1:0] addr;
        logic [7:0] len;
        logic [2:0] size;
        logic [1:0] burst;
        logic [ID_WIDTH-1:0] id;
        int slave_sel;
        
        // Generate transaction parameters
        // Select a random slave (0-8) and generate address in its range
        slave_sel = $urandom_range(0, 8);
        case (slave_sel)
            0: addr = 32'h0000_0000 + ($urandom() & 32'h0000_1FFF);
            1: addr = 32'h0000_2000 + ($urandom() & 32'h0000_1FFF);
            2: addr = 32'h0000_4000 + ($urandom() & 32'h0000_1FFF);
            3: addr = 32'h0000_6000 + ($urandom() & 32'h0000_1FFF);
            4: addr = 32'h0000_8000 + ($urandom() & 32'h0000_1FFF);
            5: addr = 32'h0000_A000 + ($urandom() & 32'h0000_1FFF);
            6: addr = 32'h0000_C000 + ($urandom() & 32'h0000_1FFF);
            7: addr = 32'h0000_E000 + ($urandom() & 32'h0000_1FFF);
            8: addr = 32'h0001_0000 + ($urandom() & 32'h0000_1FFF);
            default: addr = 32'h0000_0000 + ($urandom() & 32'h0000_1FFF);
        endcase
        
        len   = $urandom_range(0, 15);  // 1-16 beats
        size  = $urandom_range(0, $clog2(DATA_WIDTH/8));  // Up to full data width
        burst = $urandom_range(0, 2);   // FIXED, INCR, WRAP
        id    = $urandom_range(0, (1<<ID_WIDTH)-1);
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write Transaction %0d: addr=0x%08x, len=%0d, size=%0d, burst=%0d, id=%0d", 
                  trans_id, addr, len, size, burst, id), UVM_MEDIUM)
        
        // Write Address Phase
        @(posedge aclk);
        axi_intf.awid    <= id;
        axi_intf.awaddr  <= addr;
        axi_intf.awlen   <= len;
        axi_intf.awsize  <= size;
        axi_intf.awburst <= burst;
        axi_intf.awlock  <= 1'b0;
        axi_intf.awcache <= 4'b0000;
        axi_intf.awprot  <= 3'b000;
        axi_intf.awqos   <= 4'b0000;
        axi_intf.awregion <= 4'b0000;
        axi_intf.awvalid <= 1'b1;
        
        // Wait for awready
        while (!axi_intf.awready) @(posedge aclk);
        @(posedge aclk);
        axi_intf.awvalid <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write address accepted for transaction %0d", trans_id), UVM_HIGH)
        
        // Write Data Phase
        for (int beat = 0; beat <= len; beat++) begin
            @(posedge aclk);
            axi_intf.wdata  <= $urandom();
            axi_intf.wstrb  <= {DATA_WIDTH/8{1'b1}};  // All bytes valid
            axi_intf.wlast  <= (beat == len);
            axi_intf.wvalid <= 1'b1;
            
            // Wait for wready
            while (!axi_intf.wready) @(posedge aclk);
            `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write data beat %0d sent for transaction %0d, data=0x%016x", 
                      beat, trans_id, axi_intf.wdata), UVM_HIGH)
        end
        
        @(posedge aclk);
        axi_intf.wvalid <= 1'b0;
        axi_intf.wlast  <= 1'b0;
        
        // Write Response Phase
        axi_intf.bready <= 1'b1;
        while (!axi_intf.bvalid) @(posedge aclk);
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write response received for transaction %0d, bresp=%0d", 
                  trans_id, axi_intf.bresp), UVM_MEDIUM)
        
        @(posedge aclk);
        axi_intf.bready <= 1'b0;
    endtask
    
    // Drive a read transaction
    task automatic drive_read_transaction(int trans_id);
        logic [ADDR_WIDTH-1:0] addr;
        logic [7:0] len;
        logic [2:0] size;
        logic [1:0] burst;
        logic [ID_WIDTH-1:0] id;
        int beat_count;
        int slave_sel;
        
        // Generate transaction parameters
        // Select a random slave (0-8) and generate address in its range
        slave_sel = $urandom_range(0, 8);
        case (slave_sel)
            0: addr = 32'h0000_0000 + ($urandom() & 32'h0000_1FFF);
            1: addr = 32'h0000_2000 + ($urandom() & 32'h0000_1FFF);
            2: addr = 32'h0000_4000 + ($urandom() & 32'h0000_1FFF);
            3: addr = 32'h0000_6000 + ($urandom() & 32'h0000_1FFF);
            4: addr = 32'h0000_8000 + ($urandom() & 32'h0000_1FFF);
            5: addr = 32'h0000_A000 + ($urandom() & 32'h0000_1FFF);
            6: addr = 32'h0000_C000 + ($urandom() & 32'h0000_1FFF);
            7: addr = 32'h0000_E000 + ($urandom() & 32'h0000_1FFF);
            8: addr = 32'h0001_0000 + ($urandom() & 32'h0000_1FFF);
            default: addr = 32'h0000_0000 + ($urandom() & 32'h0000_1FFF);
        endcase
        
        len   = $urandom_range(0, 15);  // 1-16 beats
        size  = $urandom_range(0, $clog2(DATA_WIDTH/8));  // Up to full data width
        burst = $urandom_range(0, 2);   // FIXED, INCR, WRAP
        id    = $urandom_range(0, (1<<ID_WIDTH)-1);
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read Transaction %0d: addr=0x%08x, len=%0d, size=%0d, burst=%0d, id=%0d", 
                  trans_id, addr, len, size, burst, id), UVM_MEDIUM)
        
        // Read Address Phase
        @(posedge aclk);
        axi_intf.arid    <= id;
        axi_intf.araddr  <= addr;
        axi_intf.arlen   <= len;
        axi_intf.arsize  <= size;
        axi_intf.arburst <= burst;
        axi_intf.arlock  <= 1'b0;
        axi_intf.arcache <= 4'b0000;
        axi_intf.arprot  <= 3'b000;
        axi_intf.arqos   <= 4'b0000;
        axi_intf.arregion <= 4'b0000;
        axi_intf.arvalid <= 1'b1;
        
        // Wait for arready
        while (!axi_intf.arready) @(posedge aclk);
        @(posedge aclk);
        axi_intf.arvalid <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read address accepted for transaction %0d", trans_id), UVM_HIGH)
        
        // Read Data Phase
        axi_intf.rready <= 1'b1;
        beat_count = 0;
        
        while (beat_count <= len) begin
            while (!axi_intf.rvalid) @(posedge aclk);
            
            `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read data beat %0d received for transaction %0d, data=0x%016x, rresp=%0d", 
                      beat_count, trans_id, axi_intf.rdata, axi_intf.rresp), UVM_HIGH)
            
            @(posedge aclk);
            beat_count++;
            
            if (axi_intf.rlast) break;
        end
        
        axi_intf.rready <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read transaction %0d completed", trans_id), UVM_MEDIUM)
    endtask
    
    // Initialize signals and start driving if enabled
    initial begin
        // Initialize all master output signals
        axi_intf.awid     = '0;
        axi_intf.awaddr   = '0;
        axi_intf.awlen    = '0;
        axi_intf.awsize   = '0;
        axi_intf.awburst  = '0;
        axi_intf.awlock   = '0;
        axi_intf.awcache  = '0;
        axi_intf.awprot   = '0;
        axi_intf.awqos    = '0;
        axi_intf.awregion = '0;
        axi_intf.awvalid  = '0;
        
        axi_intf.wdata    = '0;
        axi_intf.wstrb    = '0;
        axi_intf.wlast    = '0;
        axi_intf.wvalid   = '0;
        
        axi_intf.bready   = '0;
        
        axi_intf.arid     = '0;
        axi_intf.araddr   = '0;
        axi_intf.arlen    = '0;
        axi_intf.arsize   = '0;
        axi_intf.arburst  = '0;
        axi_intf.arlock   = '0;
        axi_intf.arcache  = '0;
        axi_intf.arprot   = '0;
        axi_intf.arqos    = '0;
        axi_intf.arregion = '0;
        axi_intf.arvalid  = '0;
        
        axi_intf.rready   = '0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", "Master BFM signals initialized", UVM_LOW)
        
        // Check if auto-drive is enabled via plusarg or start immediately for testing
        if ($value$plusargs("BFM_AUTO_DRIVE=%d", enable_auto_drive)) begin
            if (enable_auto_drive) begin
                `uvm_info("AXI_MASTER_DRIVER_BFM", "Auto-drive mode enabled via plusarg", UVM_LOW)
                bfm_enable = 1;
            end
        end else begin
            // Default: enable BFM driving for signal visibility
            `uvm_info("AXI_MASTER_DRIVER_BFM", "Enabling BFM driving for signal visibility", UVM_LOW)
            bfm_enable = 1;
        end
        
        if (bfm_enable) begin
            fork
                drive_axi_transactions();
            join_none
        end
    end
    
    // Task to enable/disable driving from external control  
    task set_enable(bit en);
        bfm_enable = en;
        if (en) begin
            `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving enabled", UVM_LOW)
            fork
                drive_axi_transactions();
            join_none
        end else begin
            `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving disabled", UVM_LOW)
        end
    endtask

endmodule : axi4_master_driver_bfm
