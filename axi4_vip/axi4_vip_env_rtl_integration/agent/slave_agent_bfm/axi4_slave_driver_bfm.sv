//==============================================================================
// AXI4 Slave Driver BFM - Responds to AXI interface transactions
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-05 14:57:06
//==============================================================================

module axi4_slave_driver_bfm #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 128,
    parameter ID_WIDTH   = 11  // Slave ID width includes concatenated master ID
)(
    input aclk, 
    input aresetn,
    axi4_if.slave axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Simple memory array for storing data
    logic [DATA_WIDTH-1:0] memory [logic [ADDR_WIDTH-1:0]];
    
    // Control signals for BFM operation
    bit bfm_enable = 1;  // Default enabled for slave to respond
    
    // Response delays (configurable)
    int aw_response_delay = 2;
    int w_response_delay = 1;
    int b_response_delay = 3;
    int ar_response_delay = 2;
    int r_response_delay = 1;
    
    // Slave response handling tasks
    task automatic handle_write_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting write transaction handling", UVM_LOW)
        
        forever begin
            fork
                handle_write_address_channel();
                handle_write_data_channel();
                handle_write_response_channel();
            join_none
            @(posedge aclk);
        end
    endtask
    
    task automatic handle_read_transactions();
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Starting read transaction handling", UVM_LOW)
        
        forever begin
            fork
                handle_read_address_channel();
                handle_read_data_channel();
            join_none
            @(posedge aclk);
        end
    endtask
    
    // Write Address Channel Handler
    logic write_addr_pending = 0;
    logic [ID_WIDTH-1:0] pending_awid;
    logic [ADDR_WIDTH-1:0] pending_awaddr;
    logic [7:0] pending_awlen;
    logic [2:0] pending_awsize;
    logic [1:0] pending_awburst;
    
    task automatic handle_write_address_channel();
        forever begin
            axi_intf.awready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, aw_response_delay)) @(posedge aclk);
            axi_intf.awready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.awvalid && axi_intf.awready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            pending_awid = axi_intf.awid;
            pending_awaddr = axi_intf.awaddr;
            pending_awlen = axi_intf.awlen;
            pending_awsize = axi_intf.awsize;
            pending_awburst = axi_intf.awburst;
            write_addr_pending = 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      pending_awid, pending_awaddr, pending_awlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.awready <= 1'b0;
        end
    endtask
    
    // Write Data Channel Handler
    logic write_data_complete = 0;
    int write_beat_count = 0;
    
    task automatic handle_write_data_channel();
        forever begin
            axi_intf.wready <= 1'b0;
            write_data_complete = 1'b0;
            write_beat_count = 0;
            
            // Wait for write address to be captured
            while (!write_addr_pending) @(posedge aclk);
            
            // Handle write data beats
            while (write_beat_count <= pending_awlen) begin
                // Random delay before accepting data
                repeat($urandom_range(0, w_response_delay)) @(posedge aclk);
                axi_intf.wready <= 1'b1;
                
                // Wait for valid data
                while (!axi_intf.wvalid) @(posedge aclk);
                
                // Store data in memory (simplified)
                automatic logic [ADDR_WIDTH-1:0] beat_addr = pending_awaddr + (write_beat_count * (DATA_WIDTH/8));
                memory[beat_addr] = axi_intf.wdata;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data beat %0d accepted: addr=0x%010x, data=0x%016x, wstrb=0x%02x", 
                          write_beat_count, beat_addr, axi_intf.wdata, axi_intf.wstrb), UVM_HIGH)
                
                write_beat_count++;
                @(posedge aclk);
                axi_intf.wready <= 1'b0;
                
                if (axi_intf.wlast) break;
            end
            
            write_data_complete = 1'b1;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write data complete for id=%0d", pending_awid), UVM_MEDIUM)
        end
    endtask
    
    // Write Response Channel Handler
    task automatic handle_write_response_channel();
        forever begin
            axi_intf.bvalid <= 1'b0;
            
            // Wait for both address and data to complete
            while (!write_addr_pending || !write_data_complete) @(posedge aclk);
            
            // Random delay before response
            repeat($urandom_range(1, b_response_delay)) @(posedge aclk);
            
            // Send write response
            axi_intf.bid <= pending_awid;
            axi_intf.bresp <= 2'b00;  // OKAY response
            axi_intf.bvalid <= 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Write response sent: id=%0d, bresp=OKAY", pending_awid), UVM_MEDIUM)
            
            // Wait for bready
            while (!axi_intf.bready) @(posedge aclk);
            
            @(posedge aclk);
            axi_intf.bvalid <= 1'b0;
            write_addr_pending = 1'b0;
            write_data_complete = 1'b0;
        end
    endtask
    
    // Read Address Channel Handler
    logic read_addr_pending = 0;
    logic [ID_WIDTH-1:0] pending_arid;
    logic [ADDR_WIDTH-1:0] pending_araddr;
    logic [7:0] pending_arlen;
    logic [2:0] pending_arsize;
    logic [1:0] pending_arburst;
    
    task automatic handle_read_address_channel();
        forever begin
            axi_intf.arready <= 1'b0;
            
            // Random delay before accepting
            repeat($urandom_range(0, ar_response_delay)) @(posedge aclk);
            axi_intf.arready <= 1'b1;
            
            // Wait for valid address and ready handshake
            while (!(axi_intf.arvalid && axi_intf.arready)) @(posedge aclk);
            
            // Capture address information during the handshake (signals are stable)
            pending_arid = axi_intf.arid;
            pending_araddr = axi_intf.araddr;
            pending_arlen = axi_intf.arlen;
            pending_arsize = axi_intf.arsize;
            pending_arburst = axi_intf.arburst;
            read_addr_pending = 1'b1;
            
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read address accepted: id=%0d, addr=0x%010x, len=%0d", 
                      pending_arid, pending_araddr, pending_arlen), UVM_MEDIUM)
            
            @(posedge aclk);
            axi_intf.arready <= 1'b0;
        end
    endtask
    
    // Read Data Channel Handler
    task automatic handle_read_data_channel();
        int read_beat_count;
        logic [ADDR_WIDTH-1:0] beat_addr;
        logic [DATA_WIDTH-1:0] read_data;
        
        forever begin
            axi_intf.rvalid <= 1'b0;
            
            // Wait for read address to be captured
            while (!read_addr_pending) @(posedge aclk);
            
            // Send read data beats
            for (read_beat_count = 0; read_beat_count <= pending_arlen; read_beat_count++) begin
                // Calculate beat address
                beat_addr = pending_araddr + (read_beat_count * (DATA_WIDTH/8));
                
                // Get data from memory (or generate if not written)
                if (memory.exists(beat_addr)) begin
                    read_data = memory[beat_addr];
                end else begin
                    read_data = $urandom();  // Random data for unwritten addresses
                end
                
                // Random delay before data
                repeat($urandom_range(0, r_response_delay)) @(posedge aclk);
                
                // Send read data
                axi_intf.rid <= pending_arid;
                axi_intf.rdata <= read_data;
                axi_intf.rresp <= 2'b00;  // OKAY response
                axi_intf.rlast <= (read_beat_count == pending_arlen);
                axi_intf.rvalid <= 1'b1;
                
                `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read data beat %0d sent: id=%0d, addr=0x%010x, data=0x%016x, last=%0b", 
                          read_beat_count, pending_arid, beat_addr, read_data, axi_intf.rlast), UVM_HIGH)
                
                // Wait for rready
                while (!axi_intf.rready) @(posedge aclk);
                
                @(posedge aclk);
                axi_intf.rvalid <= 1'b0;
                axi_intf.rlast <= 1'b0;
            end
            
            read_addr_pending = 1'b0;
            `uvm_info("AXI_SLAVE_DRIVER_BFM", $sformatf("Read transaction complete for id=%0d", pending_arid), UVM_MEDIUM)
        end
    endtask
    
    // Initialize signals and start handling
    initial begin
        // Initialize all slave output signals
        axi_intf.awready  = '0;
        axi_intf.wready   = '0;
        axi_intf.bid      = '0;
        axi_intf.bresp    = '0;
        axi_intf.bvalid   = '0;
        axi_intf.arready  = '0;
        axi_intf.rid      = '0;
        axi_intf.rdata    = '0;
        axi_intf.rresp    = '0;
        axi_intf.rlast    = '0;
        axi_intf.rvalid   = '0;
        
        `uvm_info("AXI_SLAVE_DRIVER_BFM", "Slave BFM signals initialized", UVM_LOW)
        
        // Wait for reset deassertion
        wait(aresetn == 1'b1);
        repeat(5) @(posedge aclk);
        
        // Start handling transactions
        fork
            handle_write_transactions();
            handle_read_transactions();
        join_none
    end

endmodule : axi4_slave_driver_bfm
