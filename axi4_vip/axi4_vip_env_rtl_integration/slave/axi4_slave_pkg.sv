//==============================================================================
// AXI4 Slave Package  
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-05 14:57:06
//==============================================================================

package axi4_slave_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_slave_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_slave_tx)
        
        // Transaction type (mirrors master)
        typedef enum {WRITE, READ} tx_type_e;
        tx_type_e tx_type;
        
        // Address and burst info (copied from master request)
        bit [ADDRESS_WIDTH-1:0] addr;
        bit [7:0] burst_length;
        bit [2:0] burst_size;
        bit [1:0] burst_type;
        bit [ID_WIDTH-1:0] id;
        
        // Response fields
        rand bit [1:0] bresp;
        rand bit [1:0] rresp;
        
        // Data size for throughput calculation
        int data_bytes;
        
        function new(string name = "axi4_slave_tx");
            super.new(name);
        endfunction
    endclass
    
    // Slave agent config
    class axi4_slave_agent_config extends uvm_object;
        `uvm_object_utils(axi4_slave_agent_config)
        
        bit is_active = UVM_ACTIVE;
        bit slave_memory_mode_enable = 1;
        
        // Address mapping
        bit [31:0] start_addr = 32'h0;
        bit [31:0] end_addr = 32'hFFFF_FFFF;
        
        function new(string name = "axi4_slave_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_slave_sequencer extends uvm_sequencer #(axi4_slave_tx);
        `uvm_component_utils(axi4_slave_sequencer)
        
        function new(string name = "axi4_slave_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Driver class with monitor integration
    class axi4_slave_driver extends uvm_driver #(axi4_slave_tx);
        `uvm_component_utils(axi4_slave_driver)
        
        axi4_slave_monitor monitor_h;  // Reference to monitor
        
        function new(string name = "axi4_slave_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            axi4_slave_tx trans_clone;
            forever begin
                seq_item_port.get_next_item(req);
                `uvm_info(get_type_name(), $sformatf("Got %s response - addr=0x%0h, len=%0d", 
                    req.tx_type.name(), req.addr, req.burst_length), UVM_MEDIUM)
                
                // Clone transaction for monitor
                $cast(trans_clone, req.clone());
                
                // Simulate response delay
                #100ns;
                
                // Send transaction to monitor for scoreboard reporting
                if (monitor_h != null) begin
                    monitor_h.transaction_queue.push_back(trans_clone);
                end
                
                seq_item_port.item_done();
            end
        endtask
    endclass
    
    // Monitor class - Captures transactions from driver
    class axi4_slave_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_slave_monitor)
        
        uvm_analysis_port #(axi4_slave_tx) item_collected_port;
        axi4_slave_agent_config cfg;
        
        // Transaction capture queue shared with driver
        axi4_slave_tx transaction_queue[$];
        
        function new(string name = "axi4_slave_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            if(!uvm_config_db#(axi4_slave_agent_config)::get(this, "", "cfg", cfg))
                `uvm_error("CONFIG", "Cannot get cfg from uvm_config_db")
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            axi4_slave_tx trans;
            `uvm_info(get_type_name(), "Starting slave monitor run_phase", UVM_LOW)
            
            forever begin
                // Wait for transaction from shared queue (populated by driver)
                wait(transaction_queue.size() > 0);
                trans = transaction_queue.pop_front();
                
                // Send to analysis port for scoreboard
                `uvm_info(get_type_name(), 
                    $sformatf("Collected slave transaction: %s addr=0x%h, len=%0d, id=%0d", 
                        trans.tx_type.name(), trans.addr, trans.burst_length, trans.id), 
                    UVM_MEDIUM)
                    
                item_collected_port.write(trans);
            end
        endtask
    endclass
    
    // Agent class
    class axi4_slave_agent extends uvm_agent;
        `uvm_component_utils(axi4_slave_agent)
        
        axi4_slave_agent_config cfg;
        axi4_slave_sequencer sequencer;
        axi4_slave_driver driver;
        axi4_slave_monitor monitor;
        
        function new(string name = "axi4_slave_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            `uvm_info(get_type_name(), "Building slave agent components", UVM_LOW)
            
            // Get configuration
            if(!uvm_config_db#(axi4_slave_agent_config)::get(this, "", "cfg", cfg))
                `uvm_fatal("CONFIG", "Cannot get slave agent config from uvm_config_db")
            
            `uvm_info(get_type_name(), $sformatf("Slave agent mode: %s", 
                (cfg.is_active == UVM_ACTIVE) ? "ACTIVE" : "PASSIVE"), UVM_MEDIUM)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_slave_sequencer::type_id::create("sequencer", this);
                driver = axi4_slave_driver::type_id::create("driver", this);
                `uvm_info(get_type_name(), "Created sequencer and driver for active agent", UVM_HIGH)
            end
            monitor = axi4_slave_monitor::type_id::create("monitor", this);
            `uvm_info(get_type_name(), "Created monitor", UVM_HIGH)
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            `uvm_info(get_type_name(), "Connecting slave agent components", UVM_LOW)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
                `uvm_info(get_type_name(), "Connected driver to sequencer", UVM_HIGH)
                
                // Connect driver to monitor for transaction reporting
                driver.monitor_h = monitor;
                `uvm_info(get_type_name(), "Connected driver to monitor for transaction capture", UVM_HIGH)
            end
        endfunction
    endclass
    
endpackage : axi4_slave_pkg
