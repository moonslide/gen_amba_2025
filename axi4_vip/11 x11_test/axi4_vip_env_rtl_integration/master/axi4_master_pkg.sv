//==============================================================================
// AXI4 Master Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-05 10:17:54
//==============================================================================

package axi4_master_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_master_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_master_tx)
        
        // Transaction type
        typedef enum {WRITE, READ} tx_type_e;
        rand tx_type_e tx_type;
        
        // Address channel
        rand bit [ADDRESS_WIDTH-1:0] awaddr;
        rand bit [7:0] awlen;
        rand bit [2:0] awsize;
        rand bit [1:0] awburst;
        rand bit [3:0] awid;
        rand bit [3:0] awqos;
        rand bit [3:0] awregion;
        rand bit awlock;
        rand bit [3:0] awcache;
        rand bit [2:0] awprot;
        
        // Data channel
        rand bit [DATA_WIDTH-1:0] wdata[];
        
        // Read address channel  
        rand bit [ADDRESS_WIDTH-1:0] araddr;
        rand bit [7:0] arlen;
        rand bit [2:0] arsize;
        rand bit [1:0] arburst;
        rand bit [3:0] arid;
        rand bit [3:0] arqos;
        rand bit [3:0] arregion;
        rand bit arlock;
        rand bit [3:0] arcache;
        rand bit [2:0] arprot;
        
        // Read data
        bit [DATA_WIDTH-1:0] rdata[];
        bit [1:0] rresp[];
        
        function new(string name = "axi4_master_tx");
            super.new(name);
        endfunction
    endclass
    
    // Master agent config
    class axi4_master_agent_config extends uvm_object;
        `uvm_object_utils(axi4_master_agent_config)
        
        bit is_active = UVM_ACTIVE;
        
        function new(string name = "axi4_master_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_master_sequencer extends uvm_sequencer #(axi4_master_tx);
        `uvm_component_utils(axi4_master_sequencer)
        
        function new(string name = "axi4_master_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Driver class with throughput monitoring
    class axi4_master_driver extends uvm_driver #(axi4_master_tx);
        `uvm_component_utils(axi4_master_driver)
        
        // Transaction counters
        static int write_count[10];
        static longint write_bytes[10];
        static int read_count[10];
        static longint read_bytes[10];
        static bit initialized = 0;
        
        int agent_id;
        
        function new(string name = "axi4_master_driver", uvm_component parent = null);
            super.new(name, parent);
            
            // Initialize static arrays once
            if (!initialized) begin
                foreach(write_count[i]) begin
                    write_count[i] = 0;
                    write_bytes[i] = 0;
                    read_count[i] = 0;
                    read_bytes[i] = 0;
                end
                initialized = 1;
            end
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            // Extract agent ID from parent's name (the agent that contains this driver)
            begin
                string parent_name;
                uvm_component parent;
                int idx;
                
                parent = get_parent();
                if (parent != null) begin
                    parent_name = parent.get_name();
                    `uvm_info(get_type_name(), $sformatf("Parent name: %s", parent_name), UVM_MEDIUM)
                    
                    // Look for pattern like "master_agent[N]" in parent name
                    for (int i = 0; i < 10; i++) begin
                        if (parent_name == $sformatf("master_agent[%0d]", i)) begin
                            agent_id = i;
                            `uvm_info(get_type_name(), $sformatf("Detected agent ID: %0d", agent_id), UVM_LOW)
                            break;
                        end
                    end
                end else begin
                    `uvm_warning(get_type_name(), "Could not determine parent component")
                end
            end
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            int burst_length;
            int data_width_bytes;
            int total_bytes;
            
            `uvm_info(get_type_name(), "Starting master driver run_phase", UVM_LOW)
            forever begin
                `uvm_info(get_type_name(), "Waiting for next transaction from sequencer", UVM_HIGH)
                seq_item_port.get_next_item(req);
                
                `uvm_info(get_type_name(), $sformatf("Got %s transaction - addr=0x%0h, len=%0d, size=%0d, burst=%0d", 
                    req.tx_type.name(), 
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awaddr : req.araddr,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awlen : req.arlen,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awsize : req.arsize,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awburst : req.arburst), UVM_MEDIUM)
                
                `uvm_info(get_type_name(), $sformatf("Transaction details - id=%0d, qos=%0d, region=%0d, cache=0x%0h, prot=%0d",
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awid : req.arid,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awqos : req.arqos,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awregion : req.arregion,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awcache : req.arcache,
                    (req.tx_type == axi4_master_tx::WRITE) ? req.awprot : req.arprot), UVM_HIGH)
                
                if (req.tx_type == axi4_master_tx::WRITE && req.wdata.size() > 0) begin
                    `uvm_info(get_type_name(), $sformatf("Write data: %0d beats, first_data=0x%0h", 
                        req.wdata.size(), req.wdata[0]), UVM_HIGH)
                end
                
                `uvm_info(get_type_name(), "Driving transaction to BFM interface", UVM_HIGH)
                
                // Calculate transaction bytes
                
                if (req.tx_type == axi4_master_tx::WRITE) begin
                    `uvm_info(get_type_name(), $sformatf("Driving WRITE transaction - addr=0x%0h, len=%0d, id=%0d", 
                        req.awaddr, req.awlen, req.awid), UVM_MEDIUM)
                    
                    // Calculate bytes
                    burst_length = req.awlen + 1;
                    data_width_bytes = 1 << req.awsize;
                    total_bytes = burst_length * data_width_bytes;
                    
                    // Update counters
                    write_count[agent_id]++;
                    write_bytes[agent_id] += total_bytes;
                    
                    // For now, just delay - BFM will drive synthetic transactions
                    #100ns;
                end else begin
                    `uvm_info(get_type_name(), $sformatf("Driving READ transaction - addr=0x%0h, len=%0d, id=%0d", 
                        req.araddr, req.arlen, req.arid), UVM_MEDIUM)
                    
                    // Calculate bytes  
                    burst_length = req.arlen + 1;
                    data_width_bytes = 1 << req.arsize;
                    total_bytes = burst_length * data_width_bytes;
                    
                    // Update counters
                    read_count[agent_id]++;
                    read_bytes[agent_id] += total_bytes;
                    
                    // For now, just delay - BFM will drive synthetic transactions
                    #100ns;
                end
                
                `uvm_info(get_type_name(), "Transaction completed, signaling item_done", UVM_HIGH)
                seq_item_port.item_done();
            end
        endtask
        
        // Static function to get transaction counts
        static function void get_transaction_stats(int master_id, 
                                                  output int writes, 
                                                  output longint write_data,
                                                  output int reads,
                                                  output longint read_data);
            writes = write_count[master_id];
            write_data = write_bytes[master_id];
            reads = read_count[master_id];
            read_data = read_bytes[master_id];
        endfunction
    endclass
    
    // Monitor class - FIXED: No direct interface access
    class axi4_master_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_master_monitor)
        
        uvm_analysis_port #(axi4_master_tx) item_collected_port;
        
        function new(string name = "axi4_master_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master monitor run_phase", UVM_LOW)
            `uvm_info(get_type_name(), "Monitoring AXI4 master interface for transactions", UVM_MEDIUM)
            
            // Monitor stub - just log activity without interface access
            forever begin
                #100ns;
                `uvm_info(get_type_name(), "Monitor active - checking for transactions", UVM_HIGH)
            end
        endtask
    endclass
    
    // Agent class
    class axi4_master_agent extends uvm_agent;
        `uvm_component_utils(axi4_master_agent)
        
        axi4_master_agent_config cfg;
        axi4_master_sequencer sequencer;
        axi4_master_driver driver;
        axi4_master_monitor monitor;
        
        function new(string name = "axi4_master_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            `uvm_info(get_type_name(), "Building master agent components", UVM_LOW)
            
            // Get configuration
            if(!uvm_config_db#(axi4_master_agent_config)::get(this, "", "cfg", cfg))
                `uvm_fatal("CONFIG", "Cannot get master agent config from uvm_config_db")
            
            `uvm_info(get_type_name(), $sformatf("Master agent mode: %s", 
                (cfg.is_active == UVM_ACTIVE) ? "ACTIVE" : "PASSIVE"), UVM_MEDIUM)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_master_sequencer::type_id::create("sequencer", this);
                driver = axi4_master_driver::type_id::create("driver", this);
                `uvm_info(get_type_name(), "Created sequencer and driver for active agent", UVM_HIGH)
            end
            monitor = axi4_master_monitor::type_id::create("monitor", this);
            `uvm_info(get_type_name(), "Created monitor", UVM_HIGH)
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            `uvm_info(get_type_name(), "Connecting master agent components", UVM_LOW)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
                `uvm_info(get_type_name(), "Connected driver to sequencer", UVM_HIGH)
            end
        endfunction
    endclass
    
endpackage : axi4_master_pkg
