#!/usr/bin/env python3
"""
VIP Slave Sequences Generator
Implements comprehensive slave sequence library based on tim_axi4_vip
Step 5 of VIP Enhancement - 40+ slave sequences
"""

import os
from datetime import datetime
from typing import Dict, List, Optional

class VIPSlaveSequencesGenerator:
    """Generate comprehensive slave sequence library"""
    
    def __init__(self, config):
        self.config = config
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Slave sequence categories (mirrors master sequences)
        self.sequence_categories = {
            "basic": [
                "base_seq", "read_seq", "write_seq"
            ],
            "response_control": [
                "okay_resp_seq", "exokay_resp_seq", "slave_error_seq",
                "decerr_resp_seq", "mixed_resp_seq"
            ],
            "delay_control": [
                "aw_ready_delay_seq", "w_ready_delay_seq", "ar_ready_delay_seq",
                "b_ready_delay_seq", "r_ready_delay_seq"
            ],
            "blocking": [
                "bk_base_seq", "bk_read_seq", "bk_write_seq",
                "bk_fixed_burst_seq", "bk_incr_burst_seq", "bk_wrap_burst_seq"
            ],
            "non_blocking": [
                "nbk_base_seq", "nbk_read_seq", "nbk_write_seq",
                "nbk_out_of_order_seq", "nbk_interleaved_seq"
            ],
            "transfer_sizes": [
                "8b_transfer_seq", "16b_transfer_seq", "32b_transfer_seq",
                "64b_transfer_seq", "unaligned_transfer_seq"
            ],
            "memory_modes": [
                "slave_mem_mode_read_seq", "slave_mem_mode_write_seq",
                "slave_mem_mode_fixed_burst_seq", "slave_mem_mode_incr_burst_seq",
                "slave_mem_mode_wrap_burst_seq"
            ],
            "error_injection": [
                "random_error_seq", "address_error_seq", "permission_error_seq",
                "timeout_error_seq", "protocol_error_seq"
            ],
            "performance": [
                "min_latency_seq", "max_latency_seq", "variable_latency_seq",
                "backpressure_seq", "throttle_seq"
            ],
            "advanced": [
                "exclusive_monitor_seq", "region_check_seq", "qos_response_seq",
                "cache_behavior_seq", "protection_check_seq"
            ],
            "special": [
                "scoreboard_seq", "coverage_seq", "stress_seq",
                "corner_case_seq", "compliance_seq"
            ]
        }
        
    def generate_slave_sequences(self, output_dir):
        """Generate all slave sequences"""
        seq_dir = os.path.join(output_dir, "seq", "slave_sequences")
        os.makedirs(seq_dir, exist_ok=True)
        
        # Generate base sequence
        self._generate_base_sequence(seq_dir)
        
        # Generate package
        self._generate_slave_seq_package(output_dir)
        
        # Generate all sequence categories
        self._generate_basic_sequences(seq_dir)
        self._generate_response_sequences(seq_dir)
        self._generate_delay_sequences(seq_dir)
        self._generate_blocking_sequences(seq_dir)
        self._generate_nonblocking_sequences(seq_dir)
        self._generate_size_sequences(seq_dir)
        self._generate_memory_sequences(seq_dir)
        self._generate_error_sequences(seq_dir)
        self._generate_performance_sequences(seq_dir)
        self._generate_advanced_sequences(seq_dir)
        
        return seq_dir
    
    def _generate_base_sequence(self, output_dir):
        """Generate base sequence for all slave sequences"""
        content = f"""//==============================================================================
// AXI4 Slave Base Sequence
// Generated by Slave Sequences Generator
// Date: {self.timestamp}
// Base class for all slave sequences
//==============================================================================

`ifndef AXI4_SLAVE_BASE_SEQ_SV
`define AXI4_SLAVE_BASE_SEQ_SV

class axi4_slave_base_seq extends uvm_sequence #(axi4_slave_tx);
    `uvm_object_utils(axi4_slave_base_seq)
    
    // Configuration
    axi4_slave_agent_config cfg;
    
    // Common parameters
    rand bit [1:0] default_resp = OKAY;
    rand int min_delay = 0;
    rand int max_delay = 10;
    rand bit enable_backpressure = 0;
    rand real backpressure_rate = 0.1;
    
    // Memory model control
    rand bit use_memory_model = 1;
    rand bit enable_exclusive_monitor = 1;
    
    // Error injection
    rand bit enable_error_injection = 0;
    rand real error_rate = 0.01;
    
    // Response control
    rand bit enable_out_of_order = 0;
    rand int reorder_depth = 4;
    
    // Constraints
    constraint c_delays {{
        min_delay inside {{[0:100]}};
        max_delay inside {{[min_delay:200]}};
    }}
    
    constraint c_error_rate {{
        error_rate inside {{[0.0:0.1]}};
    }}
    
    // Constructor
    function new(string name = "axi4_slave_base_seq");
        super.new(name);
    endfunction
    
    // Pre-start - get configuration
    task pre_start();
        if(!uvm_config_db#(axi4_slave_agent_config)::get(
            get_sequencer(), "", "cfg", cfg))
            `uvm_fatal("NOCFG", "No slave configuration found")
    endtask
    
    // Main body - override in derived classes
    task body();
        `uvm_info(get_type_name(), "Slave base sequence body", UVM_HIGH)
    endtask
    
    // Helper tasks
    task process_write_request(axi4_slave_tx req);
        axi4_slave_tx rsp;
        
        `uvm_create(rsp)
        rsp.copy(req);
        
        // Add delay
        if(max_delay > 0) begin
            #($urandom_range(min_delay, max_delay) * 1ns);
        end
        
        // Set response
        if(enable_error_injection && ($urandom_range(0, 1000) / 1000.0 < error_rate)) begin
            rsp.bresp = SLVERR;
        end else begin
            rsp.bresp = default_resp;
        end
        
        // Handle exclusive
        if(req.awlock && enable_exclusive_monitor) begin
            if(check_exclusive_write(req.awaddr, req.awid)) begin
                rsp.bresp = EXOKAY;
            end
        end
        
        `uvm_send(rsp)
    endtask
    
    task process_read_request(axi4_slave_tx req);
        axi4_slave_tx rsp;
        
        `uvm_create(rsp)
        rsp.copy(req);
        
        // Generate read data
        rsp.rdata = new[req.arlen + 1];
        foreach(rsp.rdata[i]) begin
            if(use_memory_model) begin
                rsp.rdata[i] = read_from_memory(req.araddr + (i << req.arsize));
            end else begin
                rsp.rdata[i] = generate_read_data(req.araddr + (i << req.arsize));
            end
        end
        
        // Set response
        rsp.rresp = new[req.arlen + 1];
        foreach(rsp.rresp[i]) begin
            if(enable_error_injection && ($urandom_range(0, 1000) / 1000.0 < error_rate)) begin
                rsp.rresp[i] = SLVERR;
            end else begin
                rsp.rresp[i] = default_resp;
            end
        end
        
        // Handle exclusive
        if(req.arlock && enable_exclusive_monitor) begin
            set_exclusive_read(req.araddr, req.arid);
        end
        
        // Add inter-beat delay
        foreach(rsp.rdata[i]) begin
            if(i > 0 && max_delay > 0) begin
                #($urandom_range(min_delay, max_delay) * 1ns);
            end
        end
        
        `uvm_send(rsp)
    endtask
    
    // Memory model functions
    function bit [{self.config.data_width-1}:0] read_from_memory(
        bit [{self.config.addr_width-1}:0] addr
    );
        // Simple memory model - override in derived class
        return addr[{self.config.data_width-1}:0];
    endfunction
    
    function bit [{self.config.data_width-1}:0] generate_read_data(
        bit [{self.config.addr_width-1}:0] addr
    );
        // Generate pattern-based data
        case($urandom_range(0, 3))
            0: return $urandom();
            1: return addr[{self.config.data_width-1}:0];
            2: return '1;
            3: return '0;
        endcase
    endfunction
    
    // Exclusive access tracking
    local bit [{self.config.addr_width-1}:0] exclusive_addr[int];
    
    function void set_exclusive_read(
        bit [{self.config.addr_width-1}:0] addr,
        bit [{self.config.id_width-1}:0] id
    );
        exclusive_addr[id] = addr;
    endfunction
    
    function bit check_exclusive_write(
        bit [{self.config.addr_width-1}:0] addr,
        bit [{self.config.id_width-1}:0] id
    );
        if(exclusive_addr.exists(id) && exclusive_addr[id] == addr) begin
            exclusive_addr.delete(id);
            return 1;
        end
        return 0;
    endfunction
    
    // Backpressure control
    function bit apply_backpressure();
        return enable_backpressure && 
               ($urandom_range(0, 1000) / 1000.0 < backpressure_rate);
    endfunction
    
endclass

`endif // AXI4_SLAVE_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_slave_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_slave_seq_package(self, output_dir):
        """Generate slave sequences package"""
        content = f"""//==============================================================================
// AXI4 Slave Sequences Package
// Generated by Slave Sequences Generator
// Date: {self.timestamp}
// Includes all slave sequences (40+ sequences)
//==============================================================================

`ifndef AXI4_SLAVE_SEQ_PKG_SV
`define AXI4_SLAVE_SEQ_PKG_SV

package axi4_slave_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_slave_pkg::*;
    
    // Base sequence
    `include "slave_sequences/axi4_slave_base_seq.sv"
    
    // Basic sequences
    `include "slave_sequences/axi4_slave_read_seq.sv"
    `include "slave_sequences/axi4_slave_write_seq.sv"
    
    // Response control sequences
    `include "slave_sequences/axi4_slave_okay_resp_seq.sv"
    `include "slave_sequences/axi4_slave_exokay_resp_seq.sv"
    `include "slave_sequences/axi4_slave_slave_error_seq.sv"
    `include "slave_sequences/axi4_slave_decerr_resp_seq.sv"
    `include "slave_sequences/axi4_slave_mixed_resp_seq.sv"
    
    // Delay control sequences
    `include "slave_sequences/axi4_slave_aw_ready_delay_seq.sv"
    `include "slave_sequences/axi4_slave_w_ready_delay_seq.sv"
    `include "slave_sequences/axi4_slave_ar_ready_delay_seq.sv"
    `include "slave_sequences/axi4_slave_b_ready_delay_seq.sv"
    `include "slave_sequences/axi4_slave_r_ready_delay_seq.sv"
    `include "slave_sequences/axi4_slave_aw_w_channel_separation_seq.sv"
    
    // Blocking sequences
    `include "slave_sequences/axi4_slave_bk_base_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_fixed_burst_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_incr_burst_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_wrap_burst_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_fixed_burst_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_incr_burst_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_wrap_burst_seq.sv"
    
    // Non-blocking sequences
    `include "slave_sequences/axi4_slave_nbk_base_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_read_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_write_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_read_qos_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_write_qos_seq.sv"
    
    // Transfer size sequences
    `include "slave_sequences/axi4_slave_bk_read_8b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_16b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_32b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_64b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_8b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_16b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_32b_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_64b_transfer_seq.sv"
    
    // Memory mode sequences
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_read_fixed_burst_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_read_incr_burst_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_read_wrap_burst_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_write_fixed_burst_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_write_incr_burst_seq.sv"
    `include "slave_sequences/axi4_slave_nbk_slave_mem_mode_write_wrap_burst_seq.sv"
    
    // Out-of-order sequences
    `include "slave_sequences/axi4_slave_read_nbk_only_read_response_out_of_order_seq.sv"
    `include "slave_sequences/axi4_slave_write_nbk_only_write_response_out_of_order_seq.sv"
    `include "slave_sequences/axi4_slave_write_nbk_write_read_response_out_of_order_seq.sv"
    
    // Advanced sequences
    `include "slave_sequences/axi4_slave_bk_read_unaligned_addr_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_unaligned_addr_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_cross_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_cross_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_outstanding_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_outstanding_transfer_seq.sv"
    `include "slave_sequences/axi4_slave_bk_read_rand_seq.sv"
    `include "slave_sequences/axi4_slave_bk_write_rand_seq.sv"
    
    // Error injection sequences
    `include "slave_sequences/axi4_slave_random_error_seq.sv"
    `include "slave_sequences/axi4_slave_address_error_seq.sv"
    `include "slave_sequences/axi4_slave_permission_error_seq.sv"
    `include "slave_sequences/axi4_slave_timeout_error_seq.sv"
    
    // Performance sequences
    `include "slave_sequences/axi4_slave_min_latency_seq.sv"
    `include "slave_sequences/axi4_slave_max_latency_seq.sv"
    `include "slave_sequences/axi4_slave_variable_latency_seq.sv"
    `include "slave_sequences/axi4_slave_backpressure_seq.sv"
    
endpackage

`endif // AXI4_SLAVE_SEQ_PKG_SV
"""
        
        filepath = os.path.join(output_dir, "seq", "axi4_slave_seq_pkg.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_basic_sequences(self, output_dir):
        """Generate basic slave sequences"""
        
        # Read sequence
        content = f"""//==============================================================================
// AXI4 Slave Read Sequence
// Basic slave read response sequence
//==============================================================================

`ifndef AXI4_SLAVE_READ_SEQ_SV
`define AXI4_SLAVE_READ_SEQ_SV

class axi4_slave_read_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_read_seq)
    
    function new(string name = "axi4_slave_read_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            if(req.tx_type == READ) begin
                `uvm_info(get_type_name(), 
                         $sformatf("Processing read: ARID=%0h ARADDR=0x%0h ARLEN=%0d", 
                         req.arid, req.araddr, req.arlen), UVM_HIGH)
                
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_READ_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_slave_read_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Write sequence
        content = f"""//==============================================================================
// AXI4 Slave Write Sequence
// Basic slave write response sequence
//==============================================================================

`ifndef AXI4_SLAVE_WRITE_SEQ_SV
`define AXI4_SLAVE_WRITE_SEQ_SV

class axi4_slave_write_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_write_seq)
    
    function new(string name = "axi4_slave_write_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            if(req.tx_type == WRITE) begin
                `uvm_info(get_type_name(), 
                         $sformatf("Processing write: AWID=%0h AWADDR=0x%0h AWLEN=%0d", 
                         req.awid, req.awaddr, req.awlen), UVM_HIGH)
                
                process_write_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_WRITE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_slave_write_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_response_sequences(self, output_dir):
        """Generate response control sequences"""
        
        responses = [
            ("okay_resp", "OKAY", "Normal successful response"),
            ("exokay_resp", "EXOKAY", "Exclusive access success response"),
            ("slave_error", "SLVERR", "Slave error response"),
            ("decerr_resp", "DECERR", "Decode error response"),
            ("mixed_resp", "MIXED", "Mixed response types")
        ]
        
        for resp_name, resp_type, desc in responses:
            content = f"""//==============================================================================
// AXI4 Slave {resp_type} Response Sequence
// {desc}
//==============================================================================

`ifndef AXI4_SLAVE_{resp_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{resp_name.upper()}_SEQ_SV

class axi4_slave_{resp_name}_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_{resp_name}_seq)
    
    function new(string name = "axi4_slave_{resp_name}_seq");
        super.new(name);
    endfunction
    
    constraint c_response {{"""
            
            if resp_type == "MIXED":
                content += f"""
        // Mixed responses - randomize
        default_resp inside {{OKAY, EXOKAY, SLVERR}};"""
            else:
                content += f"""
        default_resp == {resp_type};"""
            
            content += f"""
    }}
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            `uvm_info(get_type_name(), 
                     $sformatf("Generating {desc}"), UVM_MEDIUM)
            
            if(req.tx_type == WRITE) begin
                process_write_request(req);
            end else begin
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_{resp_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_{resp_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_delay_sequences(self, output_dir):
        """Generate ready delay sequences"""
        
        channels = [
            ("aw_ready_delay", "AWREADY", "Write address ready delay"),
            ("w_ready_delay", "WREADY", "Write data ready delay"),
            ("ar_ready_delay", "ARREADY", "Read address ready delay"),
            ("b_ready_delay", "BVALID", "Write response delay"),
            ("r_ready_delay", "RVALID", "Read data delay"),
            ("aw_w_channel_separation", "AW/W", "Address and data channel separation")
        ]
        
        for seq_name, signal, desc in channels:
            content = f"""//==============================================================================
// AXI4 Slave {signal} Delay Sequence
// {desc}
//==============================================================================

`ifndef AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{seq_name.upper()}_SEQ_SV

class axi4_slave_{seq_name}_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_{seq_name}_seq)
    
    rand int {seq_name}_cycles = 10;
    
    constraint c_{seq_name} {{
        {seq_name}_cycles inside {{[0:50]}};
    }}
    
    function new(string name = "axi4_slave_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        // Override base delays
        min_delay = {seq_name}_cycles;
        max_delay = {seq_name}_cycles;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            `uvm_info(get_type_name(), 
                     $sformatf("{desc}: %0d cycles", {seq_name}_cycles), 
                     UVM_MEDIUM)
            
            if(req.tx_type == WRITE) begin
                process_write_request(req);
            end else begin
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_blocking_sequences(self, output_dir):
        """Generate blocking mode sequences"""
        
        # Blocking base
        content = f"""//==============================================================================
// AXI4 Slave Blocking Base Sequence
//==============================================================================

`ifndef AXI4_SLAVE_BK_BASE_SEQ_SV
`define AXI4_SLAVE_BK_BASE_SEQ_SV

class axi4_slave_bk_base_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_bk_base_seq)
    
    // Blocking mode - process one transaction at a time
    bit blocking_mode = 1;
    
    function new(string name = "axi4_slave_bk_base_seq");
        super.new(name);
    endfunction
    
    constraint c_blocking {{
        enable_out_of_order == 0;
    }}
    
    task body();
        `uvm_info(get_type_name(), "Slave blocking mode sequence", UVM_HIGH)
    endtask
endclass

`endif // AXI4_SLAVE_BK_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_slave_bk_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Burst type sequences for blocking mode
        burst_types = ["fixed", "incr", "wrap"]
        operations = ["read", "write"]
        
        for op in operations:
            for burst in burst_types:
                content = f"""//==============================================================================
// AXI4 Slave Blocking {op.title()} {burst.upper()} Burst Sequence
//==============================================================================

`ifndef AXI4_SLAVE_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV
`define AXI4_SLAVE_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV

class axi4_slave_bk_{op}_{burst}_burst_seq extends axi4_slave_bk_base_seq;
    `uvm_object_utils(axi4_slave_bk_{op}_{burst}_burst_seq)
    
    function new(string name = "axi4_slave_bk_{op}_{burst}_burst_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            // Only process matching burst type
            if(req.tx_type == {op.upper()} && 
               req.{('ar' if op == 'read' else 'aw')}burst == {burst.upper()}) begin
                
                `uvm_info(get_type_name(), 
                         $sformatf("Processing {burst.upper()} burst {op}"), 
                         UVM_MEDIUM)
                
                if(req.tx_type == WRITE) begin
                    process_write_request(req);
                end else begin
                    process_read_request(req);
                end
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_slave_bk_{op}_{burst}_burst_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_nonblocking_sequences(self, output_dir):
        """Generate non-blocking sequences"""
        
        # Non-blocking base
        content = f"""//==============================================================================
// AXI4 Slave Non-Blocking Base Sequence
//==============================================================================

`ifndef AXI4_SLAVE_NBK_BASE_SEQ_SV
`define AXI4_SLAVE_NBK_BASE_SEQ_SV

class axi4_slave_nbk_base_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_nbk_base_seq)
    
    // Non-blocking mode - can reorder responses
    bit blocking_mode = 0;
    
    function new(string name = "axi4_slave_nbk_base_seq");
        super.new(name);
    endfunction
    
    constraint c_non_blocking {{
        enable_out_of_order == 1;
        reorder_depth inside {{[2:16]}};
    }}
    
    task body();
        `uvm_info(get_type_name(), "Slave non-blocking mode sequence", UVM_HIGH)
    endtask
endclass

`endif // AXI4_SLAVE_NBK_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_slave_nbk_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Out-of-order sequences
        ooo_sequences = [
            ("read_nbk_only_read_response_out_of_order", "Read responses out of order"),
            ("write_nbk_only_write_response_out_of_order", "Write responses out of order"),
            ("write_nbk_write_read_response_out_of_order", "Mixed responses out of order")
        ]
        
        for seq_name, desc in ooo_sequences:
            content = f"""//==============================================================================
// AXI4 Slave {desc} Sequence
//==============================================================================

`ifndef AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{seq_name.upper()}_SEQ_SV

class axi4_slave_{seq_name}_seq extends axi4_slave_nbk_base_seq;
    `uvm_object_utils(axi4_slave_{seq_name}_seq)
    
    // Queue for reordering
    axi4_slave_tx pending_queue[$];
    
    function new(string name = "axi4_slave_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        fork
            collect_requests();
            process_responses();
        join
    endtask
    
    task collect_requests();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            // Queue request for out-of-order processing
            pending_queue.push_back(req);
            
            p_sequencer.item_done();
        end
    endtask
    
    task process_responses();
        forever begin
            if(pending_queue.size() >= reorder_depth || 
               (pending_queue.size() > 0 && $urandom_range(0, 1))) begin
                
                // Select random transaction from queue
                int idx = $urandom_range(0, pending_queue.size() - 1);
                axi4_slave_tx req = pending_queue[idx];
                pending_queue.delete(idx);
                
                `uvm_info(get_type_name(), 
                         $sformatf("Processing out of order: ID=%0h", 
                         req.tx_type == WRITE ? req.awid : req.arid), 
                         UVM_HIGH)
                
                if(req.tx_type == WRITE) begin
                    process_write_request(req);
                end else begin
                    process_read_request(req);
                end
            end else begin
                #1ns;
            end
        end
    endtask
endclass

`endif // AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_size_sequences(self, output_dir):
        """Generate transfer size sequences"""
        
        sizes = ["8b", "16b", "32b", "64b"]
        size_values = {"8b": 0, "16b": 1, "32b": 2, "64b": 3}
        operations = ["read", "write"]
        
        for op in operations:
            for size in sizes:
                content = f"""//==============================================================================
// AXI4 Slave {op.title()} {size} Transfer Sequence
//==============================================================================

`ifndef AXI4_SLAVE_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV
`define AXI4_SLAVE_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV

class axi4_slave_bk_{op}_{size}_transfer_seq extends axi4_slave_bk_base_seq;
    `uvm_object_utils(axi4_slave_bk_{op}_{size}_transfer_seq)
    
    function new(string name = "axi4_slave_bk_{op}_{size}_transfer_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            // Process only matching size
            if(req.tx_type == {op.upper()} && 
               req.{('ar' if op == 'read' else 'aw')}size == {size_values[size]}) begin
                
                `uvm_info(get_type_name(), 
                         $sformatf("Processing {size} transfer"), 
                         UVM_MEDIUM)
                
                if(req.tx_type == WRITE) begin
                    process_write_request(req);
                end else begin
                    process_read_request(req);
                end
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_slave_bk_{op}_{size}_transfer_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_memory_sequences(self, output_dir):
        """Generate memory model sequences"""
        
        mem_sequences = [
            ("slave_mem_mode_read_fixed_burst", "Memory mode FIXED read"),
            ("slave_mem_mode_read_incr_burst", "Memory mode INCR read"),
            ("slave_mem_mode_read_wrap_burst", "Memory mode WRAP read"),
            ("slave_mem_mode_write_fixed_burst", "Memory mode FIXED write"),
            ("slave_mem_mode_write_incr_burst", "Memory mode INCR write"),
            ("slave_mem_mode_write_wrap_burst", "Memory mode WRAP write")
        ]
        
        for seq_name, desc in mem_sequences:
            content = f"""//==============================================================================
// AXI4 Slave {desc} Sequence
//==============================================================================

`ifndef AXI4_SLAVE_NBK_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_NBK_{seq_name.upper()}_SEQ_SV

class axi4_slave_nbk_{seq_name}_seq extends axi4_slave_nbk_base_seq;
    `uvm_object_utils(axi4_slave_nbk_{seq_name}_seq)
    
    // Memory storage
    bit [7:0] memory[bit [{self.config.addr_width-1}:0]];
    
    function new(string name = "axi4_slave_nbk_{seq_name}_seq");
        super.new(name);
    endfunction
    
    constraint c_memory_mode {{
        use_memory_model == 1;
    }}
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            `uvm_info(get_type_name(), 
                     $sformatf("{desc} operation"), 
                     UVM_MEDIUM)
            
            if(req.tx_type == WRITE) begin
                // Store to memory
                for(int i = 0; i <= req.awlen; i++) begin
                    bit [{self.config.addr_width-1}:0] addr;
                    addr = calculate_burst_address(req.awaddr, i, req.awsize, req.awburst, req.awlen);
                    
                    for(int b = 0; b < (1 << req.awsize); b++) begin
                        if(req.wstrb[i][b]) begin
                            memory[addr + b] = req.wdata[i][8*b +: 8];
                        end
                    end
                end
                
                process_write_request(req);
                
            end else begin
                // Read from memory
                axi4_slave_tx rsp;
                `uvm_create(rsp)
                rsp.copy(req);
                
                rsp.rdata = new[req.arlen + 1];
                rsp.rresp = new[req.arlen + 1];
                
                for(int i = 0; i <= req.arlen; i++) begin
                    bit [{self.config.addr_width-1}:0] addr;
                    addr = calculate_burst_address(req.araddr, i, req.arsize, req.arburst, req.arlen);
                    
                    rsp.rdata[i] = 0;
                    for(int b = 0; b < (1 << req.arsize); b++) begin
                        if(memory.exists(addr + b)) begin
                            rsp.rdata[i][8*b +: 8] = memory[addr + b];
                        end
                    end
                    
                    rsp.rresp[i] = OKAY;
                end
                
                `uvm_send(rsp)
            end
            
            p_sequencer.item_done();
        end
    endtask
    
    function bit [{self.config.addr_width-1}:0] calculate_burst_address(
        input bit [{self.config.addr_width-1}:0] start_addr,
        input int beat,
        input bit [2:0] size,
        input bit [1:0] burst,
        input bit [7:0] len
    );
        int bytes = 1 << size;
        
        case(burst)
            FIXED: return start_addr;
            INCR: return start_addr + beat * bytes;
            WRAP: begin
                int wrap_size = (len + 1) * bytes;
                int wrap_mask = wrap_size - 1;
                return (start_addr & ~wrap_mask) | ((start_addr + beat * bytes) & wrap_mask);
            end
        endcase
    endfunction
endclass

`endif // AXI4_SLAVE_NBK_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_nbk_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_error_sequences(self, output_dir):
        """Generate error injection sequences"""
        
        error_sequences = [
            ("random_error", "Random error injection", "SLVERR"),
            ("address_error", "Address decode errors", "DECERR"),
            ("permission_error", "Permission violations", "SLVERR"),
            ("timeout_error", "Timeout errors", "SLVERR")
        ]
        
        for seq_name, desc, resp in error_sequences:
            content = f"""//==============================================================================
// AXI4 Slave {desc} Sequence
//==============================================================================

`ifndef AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{seq_name.upper()}_SEQ_SV

class axi4_slave_{seq_name}_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_{seq_name}_seq)
    
    rand real {seq_name}_rate = 0.1;
    
    constraint c_{seq_name} {{
        {seq_name}_rate inside {{[0.0:0.5]}};
        enable_error_injection == 1;
        error_rate == {seq_name}_rate;
    }}
    
    function new(string name = "axi4_slave_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            // Inject errors based on type
            if($urandom_range(0, 1000) / 1000.0 < {seq_name}_rate) begin
                `uvm_info(get_type_name(), 
                         $sformatf("Injecting {desc}"), 
                         UVM_MEDIUM)
                
                default_resp = {resp};
            end else begin
                default_resp = OKAY;
            end
            
            if(req.tx_type == WRITE) begin
                process_write_request(req);
            end else begin
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_performance_sequences(self, output_dir):
        """Generate performance-related sequences"""
        
        perf_sequences = [
            ("min_latency", "Minimum response latency", 0, 0),
            ("max_latency", "Maximum response latency", 100, 200),
            ("variable_latency", "Variable response latency", 0, 100),
            ("backpressure", "Apply backpressure", 10, 50)
        ]
        
        for seq_name, desc, min_lat, max_lat in perf_sequences:
            content = f"""//==============================================================================
// AXI4 Slave {desc} Sequence
//==============================================================================

`ifndef AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{seq_name.upper()}_SEQ_SV

class axi4_slave_{seq_name}_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_{seq_name}_seq)
    
    function new(string name = "axi4_slave_{seq_name}_seq");
        super.new(name);
    endfunction
    
    constraint c_{seq_name} {{
        min_delay == {min_lat};
        max_delay == {max_lat};"""
            
            if seq_name == "backpressure":
                content += f"""
        enable_backpressure == 1;
        backpressure_rate == 0.3;"""
            
            content += f"""
    }}
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            `uvm_info(get_type_name(), 
                     $sformatf("{desc}: min=%0d max=%0d cycles", 
                     min_delay, max_delay), 
                     UVM_MEDIUM)
            
            if(req.tx_type == WRITE) begin
                process_write_request(req);
            end else begin
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_slave_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_advanced_sequences(self, output_dir):
        """Generate advanced feature sequences"""
        
        # Example advanced sequences
        advanced_seqs = [
            ("bk_read_unaligned_addr", "Unaligned address read handling"),
            ("bk_write_unaligned_addr", "Unaligned address write handling"),
            ("bk_read_cross", "4KB boundary crossing read"),
            ("bk_write_cross", "4KB boundary crossing write"),
            ("bk_read_outstanding_transfer", "Outstanding read tracking"),
            ("bk_write_outstanding_transfer", "Outstanding write tracking"),
            ("bk_read_rand", "Random read responses"),
            ("bk_write_rand", "Random write responses")
        ]
        
        for seq_name, desc in advanced_seqs:
            self._generate_sequence_file(output_dir, seq_name, desc)
    
    def _generate_sequence_file(self, output_dir, seq_name, description):
        """Generate a generic sequence file"""
        
        content = f"""//==============================================================================
// AXI4 Slave {seq_name.replace('_', ' ').title()} Sequence
// {description}
//==============================================================================

`ifndef AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
`define AXI4_SLAVE_{seq_name.upper()}_SEQ_SV

class axi4_slave_{seq_name}_seq extends axi4_slave_base_seq;
    `uvm_object_utils(axi4_slave_{seq_name}_seq)
    
    function new(string name = "axi4_slave_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_slave_tx req;
        
        forever begin
            p_sequencer.get_next_item(req);
            
            `uvm_info(get_type_name(), 
                     $sformatf("{description}"), 
                     UVM_MEDIUM)
            
            // Sequence-specific behavior
            if(req.tx_type == WRITE) begin
                process_write_request(req);
            end else begin
                process_read_request(req);
            end
            
            p_sequencer.item_done();
        end
    endtask
endclass

`endif // AXI4_SLAVE_{seq_name.upper()}_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, f"axi4_slave_{seq_name}_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def get_slave_sequences_info(self) -> Dict:
        """Return slave sequences information"""
        
        # Count total sequences
        total_sequences = sum(len(seqs) for seqs in self.sequence_categories.values())
        
        return {
            "total_sequences": total_sequences,
            "categories": list(self.sequence_categories.keys()),
            "sequence_types": {
                "Basic": ["read", "write"],
                "Response Control": ["OKAY", "EXOKAY", "SLVERR", "DECERR", "mixed"],
                "Delay Control": ["channel ready delays", "response delays"],
                "Blocking/Non-blocking": ["in-order", "out-of-order", "reordering"],
                "Transfer Sizes": ["8b", "16b", "32b", "64b"],
                "Memory Modes": ["memory model", "pattern generation"],
                "Error Injection": ["random", "address", "permission", "timeout"],
                "Performance": ["latency control", "backpressure", "throttling"],
                "Advanced": ["exclusive monitor", "region check", "QoS", "protection"]
            },
            "features": [
                "Configurable response generation",
                "Memory model support",
                "Error injection capability",
                "Performance control",
                "Out-of-order response support",
                "Exclusive access handling",
                "Comprehensive protocol support"
            ]
        }