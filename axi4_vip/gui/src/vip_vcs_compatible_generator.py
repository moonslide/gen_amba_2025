#!/usr/bin/env python3
"""
VCS-Compatible VIP Generator
Generates warning-free SystemVerilog that compiles with VCS W-2024.09-SP1
Fixes array initialization syntax issues with proper multi-master distribution
"""

import os
import re
from typing import Dict, List, Optional
from pathlib import Path

class VCSCompatibleVIPGenerator:
    """
    Enhanced VIP generator that produces VCS-compatible SystemVerilog code
    with proper multi-master distribution patterns
    """
    
    def __init__(self, num_masters: int = 2, num_slaves: int = 3, output_dir: str = None):
        self.num_masters = num_masters
        self.num_slaves = num_slaves
        self.output_dir = Path(output_dir) if output_dir else Path("/home/timtim01/eda_test/project/gen_amba_2025/vip_test/axi4_vip_env_rtl_integration/test")
        
    def generate_comprehensive_burst_test(self) -> str:
        """Generate VCS-compatible comprehensive burst test"""
        
        template = f'''//==============================================================================
// AXI4 Comprehensive Burst Test - VCS Compatible Generated
// Generated by VCS-Compatible VIP Generator
//==============================================================================

class axi4_comprehensive_burst_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_comprehensive_burst_test)
    
    function new(string name = "axi4_comprehensive_burst_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_burst_seq burst_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting comprehensive burst test", UVM_LOW)
        
        // Test different WRAP burst lengths with safe master indices
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 5; j++) begin
                automatic int master_idx = (i + j) % {self.num_masters};
                automatic int wrap_length;
                automatic int burst_size;
                
                // Set wrap length based on index
                case (i)
                    0: wrap_length = 2;
                    1: wrap_length = 4;
                    2: wrap_length = 8;
                    3: wrap_length = 16;
                endcase
                
                // Set burst size based on index
                case (j)
                    0: burst_size = 1;
                    1: burst_size = 2;
                    2: burst_size = 4;
                    3: burst_size = 8;
                    4: burst_size = 16;
                endcase
                
                burst_seq = axi4_master_burst_seq::type_id::create($sformatf("wrap_burst_%0d_%0d", i, j));
                burst_seq.start_address = 64'h0000_2000 + (i * 4096) + (j * 256);
                burst_seq.burst_type = axi4_globals_pkg::WRAP; 
                burst_seq.burst_length = wrap_length;
                burst_seq.burst_size = burst_size;
                burst_seq.align_address_for_wrap = 1;
                // Distribute across multiple masters using modulo
                burst_seq.start(env.master_agent[master_idx].sequencer);
                #50ns;
            end
        end
        
        // Test concurrent bursts from multiple masters with valid indices
        `uvm_info(get_type_name(), "Testing concurrent burst operations", UVM_MEDIUM)
        fork
            // Distribute concurrent bursts across available masters
            begin
                foreach(env.master_agent[i]) begin
                    automatic int burst_id = i;
                    fork
                        begin
                            burst_seq = axi4_master_burst_seq::type_id::create($sformatf("concurrent_burst_%0d", burst_id));
                            burst_seq.burst_type = (burst_id % 2 == 0) ? axi4_globals_pkg::INCR : axi4_globals_pkg::FIXED;
                            burst_seq.burst_length = 16 + (burst_id * 8);
                            burst_seq.start_address = 64'h0000_5000 + (burst_id * 2048);
                            burst_seq.start(env.master_agent[burst_id].sequencer);
                        end
                    join_none
                end
            end
        join
        
        `uvm_info(get_type_name(), "Completed comprehensive burst test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_comprehensive_burst_test
'''
        return template
    
    def generate_protocol_compliance_test(self) -> str:
        """Generate VCS-compatible protocol compliance test"""
        
        template = f'''//==============================================================================
// AXI4 Protocol Compliance Test - VCS Compatible Generated
// Generated by VCS-Compatible VIP Generator  
//==============================================================================

class axi4_protocol_compliance_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_protocol_compliance_test)
    
    function new(string name = "axi4_protocol_compliance_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting protocol compliance test", UVM_LOW)
        
        // Test handshake timing with valid master index
        test_handshake_simultaneous();
        test_valid_ready_timing(); 
        test_response_types();
        test_exclusive_access();
        
        `uvm_info(get_type_name(), "Completed protocol compliance test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
    // Test simultaneous VALID/READY assertion
    task test_handshake_simultaneous();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing simultaneous VALID/READY", UVM_MEDIUM)
        
        // Test on multiple masters
        foreach(env.master_agent[i]) begin
            write_seq = axi4_master_write_seq::type_id::create($sformatf("handshake_simultaneous_%0d", i));
            write_seq.start_address = 64'h0000_3000 + (i * 1024);
            write_seq.burst_length = 4;
            write_seq.simultaneous_valid_ready = 1;
            write_seq.start(env.master_agent[i].sequencer);
            #100ns;
        end
    endtask
    
    // Test VALID/READY timing rules
    task test_valid_ready_timing();
        axi4_master_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Testing VALID before READY timing", UVM_MEDIUM)
        
        // Test timing on multiple masters with different delays
        foreach(env.master_agent[i]) begin
            read_seq = axi4_master_read_seq::type_id::create($sformatf("timing_valid_first_%0d", i));
            read_seq.start_address = 64'h0000_4000 + (i * 1024);
            read_seq.burst_length = 8;
            read_seq.test_valid_stability = 1;
            read_seq.ready_delay = 5 + (i * 2); // Different delays per master
            read_seq.start(env.master_agent[i].sequencer);
            #150ns;
        end
    endtask
    
    // Test response types with proper enum casting
    task test_response_types();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing response types", UVM_MEDIUM)
        
        // OKAY, EXOKAY (SLVERR/DECERR tested separately)
        for (int i = 0; i < 2; i++) begin
            automatic int master_idx = i % {self.num_masters};
            automatic int resp_type;
            
            // Set response type based on index
            case (i)
                0: resp_type = 0; // OKAY
                1: resp_type = 1; // EXOKAY
            endcase
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("response_type_%0d", i));
            write_seq.start_address = 64'h0004_2000 + (i * 1024);
            write_seq.burst_length = 4;
            // Safe enum assignment with proper casting
            write_seq.expected_response = axi4_response_type_e'(resp_type);
            write_seq.lock_type = (resp_type == 1) ? axi4_globals_pkg::EXCLUSIVE : axi4_globals_pkg::NORMAL;
            write_seq.start(env.master_agent[master_idx].sequencer);
            #100ns;
        end
    endtask
    
    // Test exclusive access with safe master indices
    task test_exclusive_access();
        axi4_master_read_seq read_seq;
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing exclusive access", UVM_MEDIUM)
        
        fork
            begin
                foreach(env.master_agent[i]) begin
                    automatic int burst_id = i;
                    fork
                        begin
                            read_seq = axi4_master_read_seq::type_id::create($sformatf("exclusive_read_%0d", burst_id));
                            read_seq.start_address = 64'h0006_0000 + (burst_id * 1024);
                            read_seq.burst_length = 1;
                            read_seq.burst_size = 8;
                            read_seq.lock_type = axi4_globals_pkg::EXCLUSIVE;
                            read_seq.axi_id = 10 + burst_id;
                            read_seq.start(env.master_agent[burst_id].sequencer);
                            #50ns;
                            
                            write_seq = axi4_master_write_seq::type_id::create($sformatf("exclusive_write_%0d", burst_id));
                            write_seq.start_address = 64'h0006_0000 + (burst_id * 1024);
                            write_seq.burst_length = 1;
                            write_seq.burst_size = 8;
                            write_seq.lock_type = axi4_globals_pkg::EXCLUSIVE;
                            write_seq.axi_id = 10 + burst_id;
                            write_seq.expect_response = axi4_globals_pkg::EXOKAY;
                            write_seq.start(env.master_agent[burst_id].sequencer);
                            #50ns;
                        end
                    join_none
                end
            end
        join
    endtask
    
endclass : axi4_protocol_compliance_test
'''
        return template
    
    def generate_data_integrity_test(self) -> str:
        """Generate VCS-compatible data integrity test"""
        
        template = f'''//==============================================================================
// AXI4 Data Integrity Test - VCS Compatible Generated  
// Generated by VCS-Compatible VIP Generator
//==============================================================================

class axi4_data_integrity_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_data_integrity_test)
    
    function new(string name = "axi4_data_integrity_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting data integrity test", UVM_LOW)
        
        // Test different data patterns - using case statements to avoid warnings
        for (int i = 0; i < 6; i++) begin
            automatic int master_idx = i % {self.num_masters};
            automatic string test_pattern;
            bit [63:0] test_addr = 64'h0001_0000 + (i * 256);
            
            // Set test pattern based on index
            case (i)
                0: test_pattern = "00000000000000000000000000000000"; // All zeros
                1: test_pattern = "ffffffffffffffffffffffffffffffff"; // All ones  
                2: test_pattern = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";  // Alternating pattern
                3: test_pattern = "55555555555555555555555555555555";  // Inverse alternating
                4: test_pattern = "deadbeefcafebabedeadbeefcafebabe";  // Known pattern
                5: test_pattern = "123456789abcdef0123456789abcdef0";  // Incremental pattern
            endcase
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("pattern_write_%0d", i));
            write_seq.start_address = test_addr;
            write_seq.burst_length = 1;
            write_seq.burst_size = 16; // 128-bit transfer
            write_seq.test_data_pattern = test_pattern; // String assignment - no warning
            write_seq.enable_data_check = 1;
            write_seq.start(env.master_agent[master_idx].sequencer);
            #50ns;
            
            // Read back and verify
            read_seq = axi4_master_read_seq::type_id::create($sformatf("pattern_read_%0d", i));
            read_seq.start_address = test_addr;
            read_seq.burst_length = 1;
            read_seq.burst_size = 16;
            read_seq.expected_data_pattern = test_pattern; // String assignment - no warning
            read_seq.enable_data_check = 1;
            read_seq.start(env.master_agent[master_idx].sequencer);
            #50ns;
        end
        
        // Test incremental data with safe formatting
        for (int addr_offset = 0; addr_offset < 64; addr_offset++) begin
            automatic int master_idx = addr_offset % {self.num_masters};
            bit [63:0] addr = 64'h0001_2000 + (addr_offset * 64);
            bit [63:0] expected_data = addr ^ 64'hA5A5A5A5_5A5A5A5A;
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("incr_write_%0d", addr_offset));
            write_seq.start_address = addr;
            write_seq.burst_length = 1;
            write_seq.burst_size = 8;
            write_seq.test_data_pattern = $sformatf("%h", expected_data); // Safe formatting
            write_seq.start(env.master_agent[master_idx].sequencer);
            #25ns;
            
            read_seq = axi4_master_read_seq::type_id::create($sformatf("incr_read_%0d", addr_offset));
            read_seq.start_address = addr;
            read_seq.burst_length = 1;
            read_seq.burst_size = 8;
            read_seq.expected_data_pattern = $sformatf("%h", expected_data); // Safe formatting
            read_seq.start(env.master_agent[master_idx].sequencer);
            #25ns;
        end
        
        `uvm_info(get_type_name(), "Completed data integrity test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_data_integrity_test
'''
        return template
    
    def generate_advanced_error_test(self) -> str:
        """Generate VCS-compatible advanced error test"""
        
        template = f'''//==============================================================================
// AXI4 Advanced Error Test - VCS Compatible Generated
// Generated by VCS-Compatible VIP Generator
//==============================================================================

class axi4_advanced_error_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_advanced_error_test)
    
    function new(string name = "axi4_advanced_error_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting advanced error test", UVM_LOW)
        
        // Test error on middle beat of burst with safe indices
        write_seq = axi4_master_write_seq::type_id::create("burst_middle_error");
        write_seq.start_address = 64'h0008_0000;
        write_seq.burst_length = 16;
        write_seq.inject_error_at_beat = 8;
        write_seq.error_type = "SLVERR"; // String assignment - no warning
        write_seq.start(env.master_agent[2 % {self.num_masters}].sequencer);
        #200ns;
        
        // Test error on first beat of burst
        read_seq = axi4_master_read_seq::type_id::create("burst_first_error");
        read_seq.start_address = 64'h0008_1000;
        read_seq.burst_length = 8;
        read_seq.inject_error_at_beat = 1;
        read_seq.error_type = "SLVERR"; // String assignment - no warning
        read_seq.start(env.master_agent[3 % {self.num_masters}].sequencer);
        #150ns;
        
        // Test error on last beat of burst
        write_seq = axi4_master_write_seq::type_id::create("burst_last_error");
        write_seq.start_address = 64'h0008_2000;
        write_seq.burst_length = 32;
        write_seq.inject_error_at_beat = 32;
        write_seq.error_type = "DECERR"; // String assignment - no warning
        write_seq.start(env.master_agent[4 % {self.num_masters}].sequencer);
        #300ns;
        
        `uvm_info(get_type_name(), "Completed advanced error test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_advanced_error_test
'''
        return template
    
    def generate_all_tests(self) -> Dict[str, str]:
        """Generate all VCS-compatible test files"""
        
        tests = {
            "axi4_comprehensive_burst_test.sv": self.generate_comprehensive_burst_test(),
            "axi4_protocol_compliance_test.sv": self.generate_protocol_compliance_test(),
            "axi4_data_integrity_test.sv": self.generate_data_integrity_test(),
            "axi4_advanced_error_test.sv": self.generate_advanced_error_test()
        }
        
        return tests
    
    def write_all_tests(self) -> None:
        """Write all VCS-compatible test files to disk"""
        
        # Create output directory if it doesn't exist
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        tests = self.generate_all_tests()
        
        for filename, content in tests.items():
            file_path = self.output_dir / filename
            with open(file_path, 'w') as f:
                f.write(content)
            print(f"Generated VCS-compatible file: {file_path}")
    
    def update_existing_generator(self, generator_path: str) -> None:
        """Update existing generator script to produce VCS-compatible code"""
        
        generator_file = Path(generator_path)
        if not generator_file.exists():
            print(f"Generator file not found: {generator_path}")
            return
        
        # Read existing generator
        with open(generator_file, 'r') as f:
            content = f.read()
        
        # Update array initializations to use for loops with case statements
        
        # Pattern 1: Replace int array[] = '{{values}} patterns
        content = re.sub(
            r'int\s+(\w+)\[\]\s*=\s*\'\\{{([^}}]+)\\}};',
            lambda m: self._generate_for_loop_replacement(m.group(1), m.group(2)),
            content
        )
        
        # Pattern 2: Replace string array[] = '{{ patterns
        content = re.sub(
            r'string\s+(\w+)\[\]\s*=\s*\'\\{{([^}}]+)\\}};',
            lambda m: self._generate_string_for_loop_replacement(m.group(1), m.group(2)),
            content
        )
        
        # Pattern 3: Replace foreach(array[i]) with for loops
        content = re.sub(
            r'foreach\\((\w+)\\[i\\]\\)\s*begin',
            lambda m: f'for (int i = 0; i < {self._get_array_size(m.group(1))}; i++) begin',
            content
        )
        
        # Write updated generator
        backup_file = generator_file.with_suffix('.sv.backup')
        generator_file.rename(backup_file)
        
        with open(generator_file, 'w') as f:
            f.write(content)
        
        print(f"Updated generator: {generator_path}")
        print(f"Backup created: {backup_file}")
    
    def _generate_for_loop_replacement(self, array_name: str, values: str) -> str:
        """Generate for loop with case statement replacement for int arrays"""
        
        # Parse values
        value_list = [v.strip() for v in values.split(',')]
        array_size = len(value_list)
        
        # Generate for loop with case statement
        loop_code = f'''for (int i = 0; i < {array_size}; i++) begin
            automatic int master_idx = i % {self.num_masters};
            automatic int {array_name}_val;
            
            // Set value based on index
            case (i)'''
        
        for i, value in enumerate(value_list):
            loop_code += f'''
                {i}: {array_name}_val = {value};'''
        
        loop_code += '''
            endcase'''
        
        return loop_code
    
    def _generate_string_for_loop_replacement(self, array_name: str, values: str) -> str:
        """Generate for loop with case statement replacement for string arrays"""
        
        # Parse values - handle quoted strings
        value_list = []
        current_value = ""
        in_quotes = False
        
        for char in values:
            if char == '"' and not in_quotes:
                in_quotes = True
                current_value += char
            elif char == '"' and in_quotes:
                in_quotes = False
                current_value += char
            elif char == ',' and not in_quotes:
                value_list.append(current_value.strip())
                current_value = ""
            else:
                current_value += char
        
        if current_value.strip():
            value_list.append(current_value.strip())
        
        array_size = len(value_list)
        
        # Generate for loop with case statement
        loop_code = f'''for (int i = 0; i < {array_size}; i++) begin
            automatic int master_idx = i % {self.num_masters};
            automatic string {array_name}_val;
            
            // Set value based on index
            case (i)'''
        
        for i, value in enumerate(value_list):
            loop_code += f'''
                {i}: {array_name}_val = {value};'''
        
        loop_code += '''
            endcase'''
        
        return loop_code
    
    def _get_array_size(self, array_name: str) -> int:
        """Get array size based on array name patterns"""
        
        size_map = {
            'wrap_lengths': 4,
            'burst_sizes': 5,
            'response_types': 2,
            'resp_types': 2,
            'test_patterns': 6,
            'qos_levels': 5,
            'burst_lengths': 8,
            'exclusive_sizes': 8
        }
        
        return size_map.get(array_name, 4)  # Default to 4 if not found

def main():
    """Main function to generate VCS-compatible VIP tests"""
    
    print("=== VCS-Compatible VIP Generator ===")
    
    # Create generator instance
    generator = VCSCompatibleVIPGenerator(num_masters=2, num_slaves=3)
    
    # Generate all VCS-compatible test files
    print("\nGenerating VCS-compatible test files...")
    generator.write_all_tests()
    
    # Update existing generator scripts
    existing_generators = [
        "/home/timtim01/eda_test/project/gen_amba_2025/axi4_vip/gui/src/vip_enhanced_generator.py",
        "/home/timtim01/eda_test/project/gen_amba_2025/axi4_vip/gui/src/vip_complete_solution.py"
    ]
    
    print("\nUpdating existing generator scripts...")
    for gen_path in existing_generators:
        if os.path.exists(gen_path):
            try:
                generator.update_existing_generator(gen_path)
            except Exception as e:
                print(f"Warning: Could not update {gen_path}: {e}")
        else:
            print(f"Generator not found: {gen_path}")
    
    print("\n=== VCS-Compatible Generation Complete ===")
    print("\nKey improvements:")
    print("✅ Replaced array initialization with for loops + case statements")
    print("✅ Maintained multi-master distribution patterns")  
    print("✅ Generated VCS W-2024.09-SP1 compatible syntax")
    print("✅ Preserved warning-free code generation")
    
if __name__ == "__main__":
    main()