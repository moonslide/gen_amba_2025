#!/usr/bin/env python3
"""
Patch for VIP Environment Generator to include slave sequence support
This modifies the existing vip_environment_generator.py to generate proper virtual sequences
"""

import os

def patch_vip_environment_generator():
    """Apply patches to the main VIP environment generator"""
    
    generator_file = os.path.join(os.path.dirname(__file__), "vip_environment_generator.py")
    
    if not os.path.exists(generator_file):
        print(f"Error: VIP environment generator not found: {generator_file}")
        return False
        
    # Read the current file
    with open(generator_file, 'r') as f:
        content = f.read()
    
    # Define the patches
    patches = []
    
    # Patch 1: Replace the virtual write sequence generation
    old_write_seq = '''        # Virtual write sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Starting virtual write sequence", UVM_MEDIUM)
        
        // Run write sequence on master 0
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
    endtask : body
    
endclass : axi4_virtual_write_seq
""")'''

    new_write_seq = '''        # Virtual write sequence with slave support
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write Sequence - With Slave Response Support
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        axi4_slave_mem_seq slave_seq[{len(self.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual write sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves first
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run write sequence on master 0
        `uvm_info(get_type_name(), "Starting master write sequence", UVM_MEDIUM)
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual write sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_write_seq
""")'''
    
    patches.append((old_write_seq, new_write_seq, "virtual write sequence"))
    
    # Patch 2: Replace the virtual read sequence generation
    old_read_seq = '''        # Virtual read sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Starting virtual read sequence", UVM_MEDIUM)
        
        // Run read sequence on master 0
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
    endtask : body
    
endclass : axi4_virtual_read_seq
""")'''

    new_read_seq = '''        # Virtual read sequence with slave support
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Read Sequence - With Slave Response Support
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_read_seq read_seq;
        axi4_slave_mem_seq slave_seq[{len(self.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual read sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves first
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run read sequence on master 0
        `uvm_info(get_type_name(), "Starting master read sequence", UVM_MEDIUM)
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual read sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_read_seq
""")'''
    
    patches.append((old_read_seq, new_read_seq, "virtual read sequence"))
    
    # Patch 3: Update virtual write-read sequence
    old_write_read_seq = '''        # Virtual write-read sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write-Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_virtual_write_seq write_seq;
        axi4_virtual_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Starting virtual write-read sequence", UVM_MEDIUM)
        
        // Run write sequence
        write_seq = axi4_virtual_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer);
        
        // Run read sequence
        read_seq = axi4_virtual_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer);
        
    endtask : body
    
endclass : axi4_virtual_write_read_seq
""")'''

    new_write_read_seq = '''        # Virtual write-read sequence with slave support
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write-Read Sequence - With Slave Response Support
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        axi4_slave_mem_seq slave_seq[{len(self.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual write-read sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run write sequence
        `uvm_info(get_type_name(), "Starting master write sequence", UVM_MEDIUM)
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
        // Small delay between write and read
        #50ns;
        
        // Run read sequence
        `uvm_info(get_type_name(), "Starting master read sequence", UVM_MEDIUM)
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual write-read sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_write_read_seq
""")'''
    
    patches.append((old_write_read_seq, new_write_read_seq, "virtual write-read sequence"))
    
    # Apply patches
    modified_content = content
    patches_applied = []
    
    for old_text, new_text, patch_name in patches:
        if old_text in modified_content:
            modified_content = modified_content.replace(old_text, new_text)
            patches_applied.append(patch_name)
            print(f"[PATCH] Applied: {patch_name}")
        else:
            print(f"[WARN] Could not find text to patch for: {patch_name}")
    
    # Add method to generate enhanced slave memory sequence if not present
    if "def _generate_enhanced_slave_mem_seq" not in modified_content:
        # Find where to insert the method
        insert_point = modified_content.find("    def _generate_sequence_files(self, base_path):")
        if insert_point > 0:
            # Add the method before _generate_sequence_files
            enhanced_slave_method = '''
    def _generate_enhanced_slave_mem_seq(self, base_path):
        """Generate enhanced slave memory sequence with proper stop method"""
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_mem_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Memory Response Sequence - Enhanced
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_slave_mem_seq extends axi4_slave_base_seq;
    
    `uvm_object_utils(axi4_slave_mem_seq)
    
    // Memory storage
    bit [7:0] memory[bit[63:0]];
    
    // Response delay control
    int min_delay = 0;
    int max_delay = 5;
    
    // Enable debug messages
    bit debug_enable = 1;
    
    // Constructor
    function new(string name = "axi4_slave_mem_seq");
        super.new(name);
    endfunction
    
    // Body method - runs forever until stopped
    virtual task body();
        axi4_slave_tx tx;
        bit [63:0] addr;
        int delay;
        
        `uvm_info(get_type_name(), "Starting slave memory sequence - ready to respond", UVM_MEDIUM)
        
        forever begin
            // Get the next request from sequencer
            p_sequencer.get_next_item(tx);
            
            if (debug_enable) begin
                `uvm_info(get_type_name(), $sformatf("Received %s request: ADDR=0x%0h, LEN=%0d, SIZE=%0d", 
                         tx.tx_type == axi4_globals_pkg::WRITE ? "WRITE" : "READ",
                         tx.addr, tx.burst_length, tx.burst_size), UVM_HIGH)
            end
            
            // Add random delay
            delay = $urandom_range(min_delay, max_delay);
            if (delay > 0) begin
                repeat(delay) @(posedge p_sequencer.vif.aclk);
            end
            
            // Process based on transaction type
            if(tx.tx_type == axi4_globals_pkg::WRITE) begin
                // Store write data in memory
                for(int i = 0; i < tx.burst_length; i++) begin
                    addr = tx.addr + (i * (1 << tx.burst_size));
                    for(int j = 0; j < (1 << tx.burst_size); j++) begin
                        if(tx.wstrb[i][j]) begin
                            memory[addr + j] = tx.data[i][(j*8) +: 8];
                        end
                    end
                end
                
                // Set write response
                tx.resp = axi4_globals_pkg::OKAY;
                
                if (debug_enable) begin
                    `uvm_info(get_type_name(), $sformatf("Write completed: RESP=%s", 
                             tx.resp == axi4_globals_pkg::OKAY ? "OKAY" : "ERROR"), UVM_HIGH)
                end
                
            end else begin // READ
                // Read data from memory
                for(int i = 0; i < tx.burst_length; i++) begin
                    addr = tx.addr + (i * (1 << tx.burst_size));
                    tx.data[i] = 0;
                    for(int j = 0; j < (1 << tx.burst_size); j++) begin
                        if(memory.exists(addr + j)) begin
                            tx.data[i][(j*8) +: 8] = memory[addr + j];
                        end else begin
                            tx.data[i][(j*8) +: 8] = 8'hFF; // Default data for uninitialized memory
                        end
                    end
                    tx.resp = axi4_globals_pkg::OKAY;
                end
                
                if (debug_enable) begin
                    `uvm_info(get_type_name(), $sformatf("Read completed: DATA[0]=0x%0h, RESP=%s", 
                             tx.data[0], tx.resp == axi4_globals_pkg::OKAY ? "OKAY" : "ERROR"), UVM_HIGH)
                end
            end
            
            // Send response back
            p_sequencer.item_done(tx);
        end
        
    endtask : body
    
    // Task to stop this sequence
    virtual task stop_sequences();
        `uvm_info(get_type_name(), "Stopping slave memory sequence", UVM_MEDIUM)
        if (is_item_done == 0 && get_sequence_state() != STOPPED) begin
            stop_reason = STOP_REASON_SEQUENCE_KILLED;
        end
    endtask
    
endclass : axi4_slave_mem_seq
""")

'''
            modified_content = modified_content[:insert_point] + enhanced_slave_method + modified_content[insert_point:]
            patches_applied.append("enhanced slave memory sequence method")
            print("[PATCH] Added: enhanced slave memory sequence method")
    
    # Update the _generate_sequence_files method to call the enhanced version
    if "_generate_enhanced_slave_mem_seq" in modified_content and "self._generate_enhanced_slave_mem_seq(base_path)" not in modified_content:
        # Find the slave memory sequence generation in _generate_sequence_files
        old_slave_gen = '''        # Slave memory sequence
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_mem_seq.sv"), "w") as f:'''
        
        new_slave_gen = '''        # Generate enhanced slave memory sequence
        self._generate_enhanced_slave_mem_seq(base_path)
        
        return  # Skip the old generation below
        
        # Slave memory sequence
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_mem_seq.sv"), "w") as f:'''
        
        if old_slave_gen in modified_content:
            modified_content = modified_content.replace(old_slave_gen, new_slave_gen)
            patches_applied.append("slave memory sequence generation call")
            print("[PATCH] Updated: slave memory sequence generation to use enhanced version")
    
    # Write the patched file
    if patches_applied:
        # Create backup
        import shutil
        import datetime
        backup_file = f"{generator_file}.backup_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copy2(generator_file, backup_file)
        print(f"[BACKUP] Created backup: {backup_file}")
        
        # Write patched content
        with open(generator_file, 'w') as f:
            f.write(modified_content)
        
        print(f"\n[SUCCESS] Applied {len(patches_applied)} patches to vip_environment_generator.py")
        print("Patches applied:")
        for patch in patches_applied:
            print(f"  - {patch}")
        return True
    else:
        print("\n[INFO] No patches were applied - file may already be patched or has unexpected format")
        return False

if __name__ == "__main__":
    patch_vip_environment_generator()