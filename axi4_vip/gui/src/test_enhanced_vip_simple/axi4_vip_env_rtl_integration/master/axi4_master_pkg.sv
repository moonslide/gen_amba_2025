//==============================================================================
// AXI4 Master Package - Enhanced with BFM Integration
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-03 23:14:02
//==============================================================================

package axi4_master_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_master_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_master_tx)
        
        // Transaction type
        typedef enum {WRITE, READ} tx_type_e;
        rand tx_type_e tx_type;
        
        // Address channel
        rand bit [ADDRESS_WIDTH-1:0] awaddr;
        rand bit [7:0] awlen;
        rand bit [2:0] awsize;
        rand bit [1:0] awburst;
        rand bit [3:0] awid;
        rand bit [3:0] awqos;
        rand bit [3:0] awregion;
        rand bit awlock;
        rand bit [3:0] awcache;
        rand bit [2:0] awprot;
        
        // Data channel
        rand bit [DATA_WIDTH-1:0] wdata[];
        
        // Read address channel  
        rand bit [ADDRESS_WIDTH-1:0] araddr;
        rand bit [7:0] arlen;
        rand bit [2:0] arsize;
        rand bit [1:0] arburst;
        rand bit [3:0] arid;
        rand bit [3:0] arqos;
        rand bit [3:0] arregion;
        rand bit arlock;
        rand bit [3:0] arcache;
        rand bit [2:0] arprot;
        
        // Read data
        bit [DATA_WIDTH-1:0] rdata[];
        bit [1:0] rresp[];
        
        function new(string name = "axi4_master_tx");
            super.new(name);
        endfunction
    endclass
    
    // Master agent config
    class axi4_master_agent_config extends uvm_object;
        `uvm_object_utils(axi4_master_agent_config)
        
        bit is_active = UVM_ACTIVE;
        
        function new(string name = "axi4_master_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_master_sequencer extends uvm_sequencer #(axi4_master_tx);
        `uvm_component_utils(axi4_master_sequencer)
        
        function new(string name = "axi4_master_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Enhanced Driver class with BFM integration
    class axi4_master_driver extends uvm_driver #(axi4_master_tx);
        `uvm_component_utils(axi4_master_driver)
        
        // Virtual interface handle to BFM
        virtual axi4_master_driver_bfm vif;
        
        // Configuration
        axi4_master_agent_config cfg;
        
        // Transaction counter
        int unsigned trans_cnt = 0;
        
        function new(string name = "axi4_master_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            `uvm_info(get_type_name(), "Building master driver with BFM", UVM_LOW)
            
            // Get configuration
            if(!uvm_config_db#(axi4_master_agent_config)::get(this, "", "cfg", cfg))
                `uvm_fatal("CONFIG", "Cannot get master agent config from uvm_config_db")
                
            // Get virtual interface
            if(!uvm_config_db#(virtual axi4_master_driver_bfm)::get(this, "", "vif", vif))
                `uvm_fatal("NOVIF", "Virtual interface not set in config_db")
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master driver run_phase with BFM", UVM_LOW)
            
            // Wait for reset
            @(posedge vif.aresetn);
            `uvm_info(get_type_name(), "Reset released, driver ready", UVM_MEDIUM)
            
            forever begin
                `uvm_info(get_type_name(), "Waiting for next transaction from sequencer", UVM_HIGH)
                seq_item_port.get_next_item(req);
                trans_cnt++;
                
                `uvm_info(get_type_name(), $sformatf("Transaction #%0d: Got %s transaction", 
                    trans_cnt, req.tx_type.name()), UVM_MEDIUM)
                
                // Drive the transaction
                drive_transaction(req);
                
                `uvm_info(get_type_name(), $sformatf("Transaction #%0d completed", trans_cnt), UVM_MEDIUM)
                seq_item_port.item_done();
            end
        endtask
        
        virtual task drive_transaction(axi4_master_tx tx);
            if (tx.tx_type == axi4_master_tx::WRITE) begin
                drive_write_transaction(tx);
            end else begin
                drive_read_transaction(tx);
            end
        endtask
        
        virtual task drive_write_transaction(axi4_master_tx tx);
            logic [DATA_WIDTH-1:0] data_array[];
            logic [(DATA_WIDTH/8)-1:0] strb_array[];
            
            `uvm_info(get_type_name(), $sformatf("Driving WRITE transaction - addr=0x%0h, len=%0d, size=%0d, burst=%0d, id=%0d", 
                tx.awaddr, tx.awlen, tx.awsize, tx.awburst, tx.awid), UVM_MEDIUM)
            
            // Prepare data array
            data_array = new[tx.awlen + 1];
            strb_array = new[tx.awlen + 1];
            
            // Generate write data if not provided
            if (tx.wdata.size() == 0) begin
                tx.wdata = new[tx.awlen + 1];
                for (int i = 0; i <= tx.awlen; i++) begin
                    tx.wdata[i] = $random();
                    `uvm_info(get_type_name(), $sformatf("Generated write data[%0d] = 0x%0h", i, tx.wdata[i]), UVM_HIGH)
                end
            end
            
            // Copy to local arrays
            for (int i = 0; i <= tx.awlen; i++) begin
                data_array[i] = tx.wdata[i];
                strb_array[i] = '1; // All bytes valid
            end
            
            // Call BFM write transaction task
            vif.write_transaction(
                tx.awid,
                tx.awaddr,
                tx.awlen,
                tx.awsize,
                tx.awburst,
                data_array,
                strb_array
            );
            
            `uvm_info(get_type_name(), "WRITE transaction completed on BFM", UVM_MEDIUM)
        endtask
        
        virtual task drive_read_transaction(axi4_master_tx tx);
            logic [DATA_WIDTH-1:0] data_array[];
            logic [1:0] resp_array[];
            
            `uvm_info(get_type_name(), $sformatf("Driving READ transaction - addr=0x%0h, len=%0d, size=%0d, burst=%0d, id=%0d", 
                tx.araddr, tx.arlen, tx.arsize, tx.arburst, tx.arid), UVM_MEDIUM)
            
            // Allocate arrays
            data_array = new[tx.arlen + 1];
            resp_array = new[tx.arlen + 1];
            
            // Call BFM read transaction task
            vif.read_transaction(
                tx.arid,
                tx.araddr,
                tx.arlen,
                tx.arsize,
                tx.arburst,
                data_array,
                resp_array
            );
            
            // Store read data back in transaction
            tx.rdata = new[tx.arlen + 1];
            tx.rresp = new[tx.arlen + 1];
            
            for (int i = 0; i <= tx.arlen; i++) begin
                tx.rdata[i] = data_array[i];
                tx.rresp[i] = resp_array[i];
                `uvm_info(get_type_name(), $sformatf("Read data[%0d] = 0x%0h, resp=%0d", 
                    i, tx.rdata[i], tx.rresp[i]), UVM_HIGH)
            end
            
            `uvm_info(get_type_name(), "READ transaction completed on BFM", UVM_MEDIUM)
        endtask
    endclass
    
    // Enhanced Monitor class with detailed logging
    class axi4_master_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_master_monitor)
        
        uvm_analysis_port #(axi4_master_tx) item_collected_port;
        
        // Virtual interface handle to BFM
        virtual axi4_master_monitor_bfm vif;
        
        function new(string name = "axi4_master_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            `uvm_info(get_type_name(), "Building master monitor with BFM", UVM_LOW)
            
            // Get virtual interface
            if(!uvm_config_db#(virtual axi4_master_monitor_bfm)::get(this, "", "vif", vif))
                `uvm_fatal("NOVIF", "Virtual interface not set in config_db")
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master monitor run_phase", UVM_LOW)
            `uvm_info(get_type_name(), "Monitoring AXI4 master interface for transactions", UVM_MEDIUM)
            
            // Monitor would normally access interface through virtual interface
            // For now, just log that monitoring is active
            forever begin
                #100ns;
                `uvm_info(get_type_name(), "Monitor active - checking for transactions", UVM_HIGH)
            end
        endtask
    endclass
    
    // Agent class
    class axi4_master_agent extends uvm_agent;
        `uvm_component_utils(axi4_master_agent)
        
        axi4_master_agent_config cfg;
        axi4_master_sequencer sequencer;
        axi4_master_driver driver;
        axi4_master_monitor monitor;
        
        function new(string name = "axi4_master_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            `uvm_info(get_type_name(), "Building master agent components", UVM_LOW)
            
            // Get configuration
            if(!uvm_config_db#(axi4_master_agent_config)::get(this, "", "cfg", cfg))
                `uvm_fatal("CONFIG", "Cannot get master agent config from uvm_config_db")
            
            `uvm_info(get_type_name(), $sformatf("Master agent mode: %s", 
                (cfg.is_active == UVM_ACTIVE) ? "ACTIVE" : "PASSIVE"), UVM_MEDIUM)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_master_sequencer::type_id::create("sequencer", this);
                driver = axi4_master_driver::type_id::create("driver", this);
                `uvm_info(get_type_name(), "Created sequencer and driver for active agent", UVM_HIGH)
            end
            monitor = axi4_master_monitor::type_id::create("monitor", this);
            `uvm_info(get_type_name(), "Created monitor", UVM_HIGH)
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            `uvm_info(get_type_name(), "Connecting master agent components", UVM_LOW)
            
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
                `uvm_info(get_type_name(), "Connected driver to sequencer", UVM_HIGH)
            end
        endfunction
    endclass
    
endpackage : axi4_master_pkg
