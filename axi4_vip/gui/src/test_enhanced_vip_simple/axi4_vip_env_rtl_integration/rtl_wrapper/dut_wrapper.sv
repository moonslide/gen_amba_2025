//==============================================================================
// DUT Wrapper for RTL Integration
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-03 23:14:02
// Supports 2 masters and 3 slaves
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32,
    parameter ID_WIDTH   = 4,
    parameter WIDTH_SID  = (1 + ID_WIDTH)  // WIDTH_CID + WIDTH_ID where WIDTH_CID = $clog2(2) = 1
    // Note: Slave ID signals use ID_WIDTH directly to match interconnect expectations
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave axi_if  // VIP connects as master to this slave interface
);

    // Internal signals for all masters
    // Master 0 signals
    logic [ID_WIDTH-1:0]     m0_awid;
    logic [ADDR_WIDTH-1:0]   m0_awaddr;
    logic [7:0]              m0_awlen;
    logic [2:0]              m0_awsize;
    logic [1:0]              m0_awburst;
    logic                    m0_awlock;
    logic [3:0]              m0_awcache;
    logic [2:0]              m0_awprot;
    logic [3:0]              m0_awqos;
    logic                    m0_awvalid;
    logic                    m0_awready;
    
    logic [DATA_WIDTH-1:0]   m0_wdata;
    logic [DATA_WIDTH/8-1:0] m0_wstrb;
    logic                    m0_wlast;
    logic                    m0_wvalid;
    logic                    m0_wready;
    
    logic [ID_WIDTH-1:0]     m0_bid;
    logic [1:0]              m0_bresp;
    logic                    m0_bvalid;
    logic                    m0_bready;
    
    logic [ID_WIDTH-1:0]     m0_arid;
    logic [ADDR_WIDTH-1:0]   m0_araddr;
    logic [7:0]              m0_arlen;
    logic [2:0]              m0_arsize;
    logic [1:0]              m0_arburst;
    logic                    m0_arlock;
    logic [3:0]              m0_arcache;
    logic [2:0]              m0_arprot;
    logic [3:0]              m0_arqos;
    logic                    m0_arvalid;
    logic                    m0_arready;
    
    logic [ID_WIDTH-1:0]     m0_rid;
    logic [DATA_WIDTH-1:0]   m0_rdata;
    logic [1:0]              m0_rresp;
    logic                    m0_rlast;
    logic                    m0_rvalid;
    logic                    m0_rready;

    // Master 1 signals
    logic [ID_WIDTH-1:0]     m1_awid;
    logic [ADDR_WIDTH-1:0]   m1_awaddr;
    logic [7:0]              m1_awlen;
    logic [2:0]              m1_awsize;
    logic [1:0]              m1_awburst;
    logic                    m1_awlock;
    logic [3:0]              m1_awcache;
    logic [2:0]              m1_awprot;
    logic [3:0]              m1_awqos;
    logic                    m1_awvalid;
    logic                    m1_awready;
    
    logic [DATA_WIDTH-1:0]   m1_wdata;
    logic [DATA_WIDTH/8-1:0] m1_wstrb;
    logic                    m1_wlast;
    logic                    m1_wvalid;
    logic                    m1_wready;
    
    logic [ID_WIDTH-1:0]     m1_bid;
    logic [1:0]              m1_bresp;
    logic                    m1_bvalid;
    logic                    m1_bready;
    
    logic [ID_WIDTH-1:0]     m1_arid;
    logic [ADDR_WIDTH-1:0]   m1_araddr;
    logic [7:0]              m1_arlen;
    logic [2:0]              m1_arsize;
    logic [1:0]              m1_arburst;
    logic                    m1_arlock;
    logic [3:0]              m1_arcache;
    logic [2:0]              m1_arprot;
    logic [3:0]              m1_arqos;
    logic                    m1_arvalid;
    logic                    m1_arready;
    
    logic [ID_WIDTH-1:0]     m1_rid;
    logic [DATA_WIDTH-1:0]   m1_rdata;
    logic [1:0]              m1_rresp;
    logic                    m1_rlast;
    logic                    m1_rvalid;
    logic                    m1_rready;

    
    // Internal signals for all slaves  
    // Slave 0 signals
    logic [ID_WIDTH-1:0]    s0_awid;
    logic [3:0]              s0_awcache;
    logic [2:0]              s0_awprot;
    logic [3:0]              s0_awqos;
    logic [ADDR_WIDTH-1:0]   s0_awaddr;
    logic [7:0]              s0_awlen;
    logic [2:0]              s0_awsize;
    logic [1:0]              s0_awburst;
    logic                    s0_awlock;
    logic                    s0_awvalid;
    logic                    s0_awready;
    
    logic [DATA_WIDTH-1:0]   s0_wdata;
    logic [DATA_WIDTH/8-1:0] s0_wstrb;
    logic                    s0_wlast;
    logic                    s0_wvalid;
    logic                    s0_wready;
    
    logic [ID_WIDTH-1:0]    s0_bid;
    logic [1:0]              s0_bresp;
    logic                    s0_bvalid;
    logic                    s0_bready;
    
    logic [ID_WIDTH-1:0]    s0_arid;
    logic [3:0]              s0_arcache;
    logic [2:0]              s0_arprot;
    logic [3:0]              s0_arqos;
    logic [ADDR_WIDTH-1:0]   s0_araddr;
    logic [7:0]              s0_arlen;
    logic [2:0]              s0_arsize;
    logic [1:0]              s0_arburst;
    logic                    s0_arlock;
    logic                    s0_arvalid;
    logic                    s0_arready;
    
    logic [ID_WIDTH-1:0]    s0_rid;
    logic [DATA_WIDTH-1:0]   s0_rdata;
    logic [1:0]              s0_rresp;
    logic                    s0_rlast;
    logic                    s0_rvalid;
    logic                    s0_rready;

    // Slave 1 signals
    logic [ID_WIDTH-1:0]    s1_awid;
    logic [3:0]              s1_awcache;
    logic [2:0]              s1_awprot;
    logic [3:0]              s1_awqos;
    logic [ADDR_WIDTH-1:0]   s1_awaddr;
    logic [7:0]              s1_awlen;
    logic [2:0]              s1_awsize;
    logic [1:0]              s1_awburst;
    logic                    s1_awlock;
    logic                    s1_awvalid;
    logic                    s1_awready;
    
    logic [DATA_WIDTH-1:0]   s1_wdata;
    logic [DATA_WIDTH/8-1:0] s1_wstrb;
    logic                    s1_wlast;
    logic                    s1_wvalid;
    logic                    s1_wready;
    
    logic [ID_WIDTH-1:0]    s1_bid;
    logic [1:0]              s1_bresp;
    logic                    s1_bvalid;
    logic                    s1_bready;
    
    logic [ID_WIDTH-1:0]    s1_arid;
    logic [3:0]              s1_arcache;
    logic [2:0]              s1_arprot;
    logic [3:0]              s1_arqos;
    logic [ADDR_WIDTH-1:0]   s1_araddr;
    logic [7:0]              s1_arlen;
    logic [2:0]              s1_arsize;
    logic [1:0]              s1_arburst;
    logic                    s1_arlock;
    logic                    s1_arvalid;
    logic                    s1_arready;
    
    logic [ID_WIDTH-1:0]    s1_rid;
    logic [DATA_WIDTH-1:0]   s1_rdata;
    logic [1:0]              s1_rresp;
    logic                    s1_rlast;
    logic                    s1_rvalid;
    logic                    s1_rready;

    // Slave 2 signals
    logic [ID_WIDTH-1:0]    s2_awid;
    logic [3:0]              s2_awcache;
    logic [2:0]              s2_awprot;
    logic [3:0]              s2_awqos;
    logic [ADDR_WIDTH-1:0]   s2_awaddr;
    logic [7:0]              s2_awlen;
    logic [2:0]              s2_awsize;
    logic [1:0]              s2_awburst;
    logic                    s2_awlock;
    logic                    s2_awvalid;
    logic                    s2_awready;
    
    logic [DATA_WIDTH-1:0]   s2_wdata;
    logic [DATA_WIDTH/8-1:0] s2_wstrb;
    logic                    s2_wlast;
    logic                    s2_wvalid;
    logic                    s2_wready;
    
    logic [ID_WIDTH-1:0]    s2_bid;
    logic [1:0]              s2_bresp;
    logic                    s2_bvalid;
    logic                    s2_bready;
    
    logic [ID_WIDTH-1:0]    s2_arid;
    logic [3:0]              s2_arcache;
    logic [2:0]              s2_arprot;
    logic [3:0]              s2_arqos;
    logic [ADDR_WIDTH-1:0]   s2_araddr;
    logic [7:0]              s2_arlen;
    logic [2:0]              s2_arsize;
    logic [1:0]              s2_arburst;
    logic                    s2_arlock;
    logic                    s2_arvalid;
    logic                    s2_arready;
    
    logic [ID_WIDTH-1:0]    s2_rid;
    logic [DATA_WIDTH-1:0]   s2_rdata;
    logic [1:0]              s2_rresp;
    logic                    s2_rlast;
    logic                    s2_rvalid;
    logic                    s2_rready;


    // Instantiate the generated interconnect
    axi4_interconnect_m2s3 #(
        .DATA_WIDTH(DATA_WIDTH),
        .ADDR_WIDTH(ADDR_WIDTH),
        .ID_WIDTH(ID_WIDTH)
    ) generated_interconnect (
        .aclk(clk),
        .aresetn(rst_n),
        
        // Master 0 - CPU
        .m0_awid(m0_awid),
        .m0_awaddr(m0_awaddr),
        .m0_awlen(m0_awlen),
        .m0_awsize(m0_awsize),
        .m0_awburst(m0_awburst),
        .m0_awlock(m0_awlock),
        .m0_awcache(m0_awcache),
        .m0_awprot(m0_awprot),
        .m0_awqos(m0_awqos),
        .m0_awvalid(m0_awvalid),
        .m0_awready(m0_awready),
        
        .m0_wdata(m0_wdata),
        .m0_wstrb(m0_wstrb),
        .m0_wlast(m0_wlast),
        .m0_wvalid(m0_wvalid),
        .m0_wready(m0_wready),
        
        .m0_bid(m0_bid),
        .m0_bresp(m0_bresp),
        .m0_bvalid(m0_bvalid),
        .m0_bready(m0_bready),
        
        .m0_arid(m0_arid),
        .m0_araddr(m0_araddr),
        .m0_arlen(m0_arlen),
        .m0_arsize(m0_arsize),
        .m0_arburst(m0_arburst),
        .m0_arlock(m0_arlock),
        .m0_arcache(m0_arcache),
        .m0_arprot(m0_arprot),
        .m0_arqos(m0_arqos),
        .m0_arvalid(m0_arvalid),
        .m0_arready(m0_arready),
        
        .m0_rid(m0_rid),
        .m0_rdata(m0_rdata),
        .m0_rresp(m0_rresp),
        .m0_rlast(m0_rlast),
        .m0_rvalid(m0_rvalid),
        .m0_rready(m0_rready),
        // Master 1 - DMA
        .m1_awid(m1_awid),
        .m1_awaddr(m1_awaddr),
        .m1_awlen(m1_awlen),
        .m1_awsize(m1_awsize),
        .m1_awburst(m1_awburst),
        .m1_awlock(m1_awlock),
        .m1_awcache(m1_awcache),
        .m1_awprot(m1_awprot),
        .m1_awqos(m1_awqos),
        .m1_awvalid(m1_awvalid),
        .m1_awready(m1_awready),
        
        .m1_wdata(m1_wdata),
        .m1_wstrb(m1_wstrb),
        .m1_wlast(m1_wlast),
        .m1_wvalid(m1_wvalid),
        .m1_wready(m1_wready),
        
        .m1_bid(m1_bid),
        .m1_bresp(m1_bresp),
        .m1_bvalid(m1_bvalid),
        .m1_bready(m1_bready),
        
        .m1_arid(m1_arid),
        .m1_araddr(m1_araddr),
        .m1_arlen(m1_arlen),
        .m1_arsize(m1_arsize),
        .m1_arburst(m1_arburst),
        .m1_arlock(m1_arlock),
        .m1_arcache(m1_arcache),
        .m1_arprot(m1_arprot),
        .m1_arqos(m1_arqos),
        .m1_arvalid(m1_arvalid),
        .m1_arready(m1_arready),
        
        .m1_rid(m1_rid),
        .m1_rdata(m1_rdata),
        .m1_rresp(m1_rresp),
        .m1_rlast(m1_rlast),
        .m1_rvalid(m1_rvalid),
        .m1_rready(m1_rready),
        
        // Slave 0 - DDR
        .s0_awid(s0_awid),
        .s0_awaddr(s0_awaddr),
        .s0_awlen(s0_awlen),
        .s0_awsize(s0_awsize),
        .s0_awburst(s0_awburst),
        .s0_awlock(s0_awlock),
        .s0_awvalid(s0_awvalid),
        .s0_awready(s0_awready),
        .s0_awcache(s0_awcache),
        .s0_awprot(s0_awprot),
        .s0_awqos(s0_awqos),
        
        .s0_wdata(s0_wdata),
        .s0_wstrb(s0_wstrb),
        .s0_wlast(s0_wlast),
        .s0_wvalid(s0_wvalid),
        .s0_wready(s0_wready),
        
        .s0_bid(s0_bid),
        .s0_bresp(s0_bresp),
        .s0_bvalid(s0_bvalid),
        .s0_bready(s0_bready),
        
        .s0_arid(s0_arid),
        .s0_araddr(s0_araddr),
        .s0_arlen(s0_arlen),
        .s0_arsize(s0_arsize),
        .s0_arburst(s0_arburst),
        .s0_arlock(s0_arlock),
        .s0_arvalid(s0_arvalid),
        .s0_arready(s0_arready),
        .s0_arcache(s0_arcache),
        .s0_arprot(s0_arprot),
        .s0_arqos(s0_arqos),
        
        .s0_rid(s0_rid),
        .s0_rdata(s0_rdata),
        .s0_rresp(s0_rresp),
        .s0_rlast(s0_rlast),
        .s0_rvalid(s0_rvalid),
        .s0_rready(s0_rready)
,
        // Slave 1 - SRAM
        .s1_awid(s1_awid),
        .s1_awaddr(s1_awaddr),
        .s1_awlen(s1_awlen),
        .s1_awsize(s1_awsize),
        .s1_awburst(s1_awburst),
        .s1_awlock(s1_awlock),
        .s1_awvalid(s1_awvalid),
        .s1_awready(s1_awready),
        .s1_awcache(s1_awcache),
        .s1_awprot(s1_awprot),
        .s1_awqos(s1_awqos),
        
        .s1_wdata(s1_wdata),
        .s1_wstrb(s1_wstrb),
        .s1_wlast(s1_wlast),
        .s1_wvalid(s1_wvalid),
        .s1_wready(s1_wready),
        
        .s1_bid(s1_bid),
        .s1_bresp(s1_bresp),
        .s1_bvalid(s1_bvalid),
        .s1_bready(s1_bready),
        
        .s1_arid(s1_arid),
        .s1_araddr(s1_araddr),
        .s1_arlen(s1_arlen),
        .s1_arsize(s1_arsize),
        .s1_arburst(s1_arburst),
        .s1_arlock(s1_arlock),
        .s1_arvalid(s1_arvalid),
        .s1_arready(s1_arready),
        .s1_arcache(s1_arcache),
        .s1_arprot(s1_arprot),
        .s1_arqos(s1_arqos),
        
        .s1_rid(s1_rid),
        .s1_rdata(s1_rdata),
        .s1_rresp(s1_rresp),
        .s1_rlast(s1_rlast),
        .s1_rvalid(s1_rvalid),
        .s1_rready(s1_rready)
,
        // Slave 2 - APB
        .s2_awid(s2_awid),
        .s2_awaddr(s2_awaddr),
        .s2_awlen(s2_awlen),
        .s2_awsize(s2_awsize),
        .s2_awburst(s2_awburst),
        .s2_awlock(s2_awlock),
        .s2_awvalid(s2_awvalid),
        .s2_awready(s2_awready),
        .s2_awcache(s2_awcache),
        .s2_awprot(s2_awprot),
        .s2_awqos(s2_awqos),
        
        .s2_wdata(s2_wdata),
        .s2_wstrb(s2_wstrb),
        .s2_wlast(s2_wlast),
        .s2_wvalid(s2_wvalid),
        .s2_wready(s2_wready),
        
        .s2_bid(s2_bid),
        .s2_bresp(s2_bresp),
        .s2_bvalid(s2_bvalid),
        .s2_bready(s2_bready),
        
        .s2_arid(s2_arid),
        .s2_araddr(s2_araddr),
        .s2_arlen(s2_arlen),
        .s2_arsize(s2_arsize),
        .s2_arburst(s2_arburst),
        .s2_arlock(s2_arlock),
        .s2_arvalid(s2_arvalid),
        .s2_arready(s2_arready),
        .s2_arcache(s2_arcache),
        .s2_arprot(s2_arprot),
        .s2_arqos(s2_arqos),
        
        .s2_rid(s2_rid),
        .s2_rdata(s2_rdata),
        .s2_rresp(s2_rresp),
        .s2_rlast(s2_rlast),
        .s2_rvalid(s2_rvalid),
        .s2_rready(s2_rready)
    );
    
    // Connect VIP to Master 0
    assign m0_awid    = axi_if.awid;
    assign m0_awaddr  = axi_if.awaddr;
    assign m0_awlen   = axi_if.awlen;
    assign m0_awsize  = axi_if.awsize;
    assign m0_awburst = axi_if.awburst;
    assign m0_awlock  = axi_if.awlock;
    assign m0_awcache = axi_if.awcache;
    assign m0_awprot  = axi_if.awprot;
    assign m0_awqos   = 4'b0000;  // Default QoS
    assign m0_awvalid = axi_if.awvalid;
    assign axi_if.awready = m0_awready;
    
    assign m0_wdata  = axi_if.wdata;
    assign m0_wstrb  = axi_if.wstrb;
    assign m0_wlast  = axi_if.wlast;
    assign m0_wvalid = axi_if.wvalid;
    assign axi_if.wready = m0_wready;
    
    assign axi_if.bid    = m0_bid;
    assign axi_if.bresp  = m0_bresp;
    assign axi_if.bvalid = m0_bvalid;
    assign m0_bready = axi_if.bready;
    
    assign m0_arid    = axi_if.arid;
    assign m0_araddr  = axi_if.araddr;
    assign m0_arlen   = axi_if.arlen;
    assign m0_arsize  = axi_if.arsize;
    assign m0_arburst = axi_if.arburst;
    assign m0_arlock  = axi_if.arlock;
    assign m0_arcache = axi_if.arcache;
    assign m0_arprot  = axi_if.arprot;
    assign m0_arqos   = 4'b0000;  // Default QoS
    assign m0_arvalid = axi_if.arvalid;
    assign axi_if.arready = m0_arready;
    
    assign axi_if.rid    = m0_rid;
    assign axi_if.rdata  = m0_rdata;
    assign axi_if.rresp  = m0_rresp;
    assign axi_if.rlast  = m0_rlast;
    assign axi_if.rvalid = m0_rvalid;
    assign m0_rready = axi_if.rready;
    
    // Terminate unused master interfaces
    // Master 1 termination
    // Write Address Channel
    assign m1_awid    = {ID_WIDTH{1'b0}};
    assign m1_awaddr  = {ADDR_WIDTH{1'b0}};
    assign m1_awlen   = 8'd0;
    assign m1_awsize  = 3'd0;
    assign m1_awburst = 2'b01;
    assign m1_awlock  = 1'b0;
    assign m1_awcache = 4'b0000;
    assign m1_awprot  = 3'b000;
    assign m1_awqos   = 4'b0000;
    assign m1_awvalid = 1'b0;
    
    // Write Data Channel
    assign m1_wdata   = {DATA_WIDTH{1'b0}};
    assign m1_wstrb   = {(DATA_WIDTH/8){1'b0}};
    assign m1_wlast   = 1'b0;
    assign m1_wvalid  = 1'b0;
    
    // Write Response Channel
    assign m1_bready  = 1'b1;
    
    // Read Address Channel
    assign m1_arid    = {ID_WIDTH{1'b0}};
    assign m1_araddr  = {ADDR_WIDTH{1'b0}};
    assign m1_arlen   = 8'd0;
    assign m1_arsize  = 3'd0;
    assign m1_arburst = 2'b01;
    assign m1_arlock  = 1'b0;
    assign m1_arcache = 4'b0000;
    assign m1_arprot  = 3'b000;
    assign m1_arqos   = 4'b0000;
    assign m1_arvalid = 1'b0;
    
    // Read Data Channel
    assign m1_rready  = 1'b1;

    
    // Slave response logic for testing
    // Slave 0 (DDR) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s0_awready <= 1'b0;
            s0_wready  <= 1'b0;
            s0_bvalid  <= 1'b0;
            s0_arready <= 1'b0;
            s0_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s0_awready <= 1'b1;
            s0_wready  <= 1'b1;
            s0_arready <= 1'b1;
            
            // Write response
            if (s0_awvalid && s0_awready && s0_wvalid && s0_wready && s0_wlast) begin
                s0_bvalid <= 1'b1;
                s0_bid    <= s0_awid;
                s0_bresp  <= 2'b00; // OKAY
            end else if (s0_bready && s0_bvalid) begin
                s0_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s0_arvalid && s0_arready) begin
                s0_rvalid <= 1'b1;
                s0_rid    <= s0_arid;
                s0_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s0_rresp  <= 2'b00; // OKAY
                s0_rlast  <= 1'b1;  // Single beat
            end else if (s0_rready && s0_rvalid) begin
                s0_rvalid <= 1'b0;
            end
        end
    end

    // Slave 1 (SRAM) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s1_awready <= 1'b0;
            s1_wready  <= 1'b0;
            s1_bvalid  <= 1'b0;
            s1_arready <= 1'b0;
            s1_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s1_awready <= 1'b1;
            s1_wready  <= 1'b1;
            s1_arready <= 1'b1;
            
            // Write response
            if (s1_awvalid && s1_awready && s1_wvalid && s1_wready && s1_wlast) begin
                s1_bvalid <= 1'b1;
                s1_bid    <= s1_awid;
                s1_bresp  <= 2'b00; // OKAY
            end else if (s1_bready && s1_bvalid) begin
                s1_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s1_arvalid && s1_arready) begin
                s1_rvalid <= 1'b1;
                s1_rid    <= s1_arid;
                s1_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s1_rresp  <= 2'b00; // OKAY
                s1_rlast  <= 1'b1;  // Single beat
            end else if (s1_rready && s1_rvalid) begin
                s1_rvalid <= 1'b0;
            end
        end
    end

    // Slave 2 (APB) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s2_awready <= 1'b0;
            s2_wready  <= 1'b0;
            s2_bvalid  <= 1'b0;
            s2_arready <= 1'b0;
            s2_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s2_awready <= 1'b1;
            s2_wready  <= 1'b1;
            s2_arready <= 1'b1;
            
            // Write response
            if (s2_awvalid && s2_awready && s2_wvalid && s2_wready && s2_wlast) begin
                s2_bvalid <= 1'b1;
                s2_bid    <= s2_awid;
                s2_bresp  <= 2'b00; // OKAY
            end else if (s2_bready && s2_bvalid) begin
                s2_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s2_arvalid && s2_arready) begin
                s2_rvalid <= 1'b1;
                s2_rid    <= s2_arid;
                s2_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s2_rresp  <= 2'b00; // OKAY
                s2_rlast  <= 1'b1;  // Single beat
            end else if (s2_rready && s2_rvalid) begin
                s2_rvalid <= 1'b0;
            end
        end
    end


endmodule : dut_wrapper
