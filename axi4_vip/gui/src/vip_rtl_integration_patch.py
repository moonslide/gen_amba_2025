#!/usr/bin/env python3
"""
Patch for VIP Environment Generator to support real RTL integration
"""

def get_real_rtl_wrapper_content(config, timestamp, num_masters, num_slaves):
    """Generate DUT wrapper for real RTL interconnect integration"""
    
    # Get ID width from config
    id_width = max([master.id_width for master in config.masters]) if config.masters else 10
    
    return f"""//==============================================================================
// DUT Wrapper for {num_masters}x{num_slaves} Real RTL Integration
// Connects AXI interfaces to real axi4_interconnect_m{num_masters}s{num_slaves} RTL module
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {timestamp}
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = {config.addr_width},
    parameter DATA_WIDTH = {config.data_width},
    parameter ID_WIDTH   = {id_width},
    parameter NUM_MASTERS = {num_masters},
    parameter NUM_SLAVES = {num_slaves}
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave master_if[NUM_MASTERS],  // Master interfaces from VIP
    axi4_if.master slave_if[NUM_SLAVES]    // Slave interfaces to VIP slave BFMs
);

    // The real RTL uses ID_WIDTH=4 internally, we need to adapt
    localparam RTL_ID_WIDTH = 4;
    
    // Wire declarations for all master signals
    // Master 0
    wire [RTL_ID_WIDTH-1:0]     m0_awid;
    wire [ADDR_WIDTH-1:0]       m0_awaddr;
    wire [7:0]                  m0_awlen;
    wire [2:0]                  m0_awsize;
    wire [1:0]                  m0_awburst;
    wire                        m0_awlock;
    wire [3:0]                  m0_awcache;
    wire [2:0]                  m0_awprot;
    wire [3:0]                  m0_awqos;
    wire                        m0_awvalid;
    wire                        m0_awready;
    wire [DATA_WIDTH-1:0]       m0_wdata;
    wire [DATA_WIDTH/8-1:0]     m0_wstrb;
    wire                        m0_wlast;
    wire                        m0_wvalid;
    wire                        m0_wready;
    wire [RTL_ID_WIDTH-1:0]     m0_bid;
    wire [1:0]                  m0_bresp;
    wire                        m0_bvalid;
    wire                        m0_bready;
    wire [RTL_ID_WIDTH-1:0]     m0_arid;
    wire [ADDR_WIDTH-1:0]       m0_araddr;
    wire [7:0]                  m0_arlen;
    wire [2:0]                  m0_arsize;
    wire [1:0]                  m0_arburst;
    wire                        m0_arlock;
    wire [3:0]                  m0_arcache;
    wire [2:0]                  m0_arprot;
    wire [3:0]                  m0_arqos;
    wire                        m0_arvalid;
    wire                        m0_arready;
    wire [RTL_ID_WIDTH-1:0]     m0_rid;
    wire [DATA_WIDTH-1:0]       m0_rdata;
    wire [1:0]                  m0_rresp;
    wire                        m0_rlast;
    wire                        m0_rvalid;
    wire                        m0_rready;

    // Similar declarations for Masters 1-{num_masters-1} (abbreviated for space)
    `include "master_wire_declarations.svh"
    
    // Wire declarations for all slave signals
    // Slave 0
    wire [RTL_ID_WIDTH-1:0]   s0_awid;
    wire [ADDR_WIDTH-1:0]       s0_awaddr;
    wire [7:0]                  s0_awlen;
    wire [2:0]                  s0_awsize;
    wire [1:0]                  s0_awburst;
    wire                        s0_awlock;
    wire [3:0]                  s0_awcache;
    wire [2:0]                  s0_awprot;
    wire [3:0]                  s0_awqos;
    wire                        s0_awvalid;
    wire                        s0_awready;
    wire [DATA_WIDTH-1:0]       s0_wdata;
    wire [DATA_WIDTH/8-1:0]     s0_wstrb;
    wire                        s0_wlast;
    wire                        s0_wvalid;
    wire                        s0_wready;
    wire [RTL_ID_WIDTH-1:0]   s0_bid;
    wire [1:0]                  s0_bresp;
    wire                        s0_bvalid;
    wire                        s0_bready;
    wire [RTL_ID_WIDTH-1:0]   s0_arid;
    wire [ADDR_WIDTH-1:0]       s0_araddr;
    wire [7:0]                  s0_arlen;
    wire [2:0]                  s0_arsize;
    wire [1:0]                  s0_arburst;
    wire                        s0_arlock;
    wire [3:0]                  s0_arcache;
    wire [2:0]                  s0_arprot;
    wire [3:0]                  s0_arqos;
    wire                        s0_arvalid;
    wire                        s0_arready;
    wire [RTL_ID_WIDTH-1:0]   s0_rid;
    wire [DATA_WIDTH-1:0]       s0_rdata;
    wire [1:0]                  s0_rresp;
    wire                        s0_rlast;
    wire                        s0_rvalid;
    wire                        s0_rready;

    // Similar declarations for Slaves 1-{num_slaves-1} (abbreviated for space)
    `include "slave_wire_declarations.svh"
    
    // Connect master interfaces to wires
    // Master 0
    assign m0_awid     = master_if[0].awid[RTL_ID_WIDTH-1:0];
    assign m0_awaddr   = master_if[0].awaddr;
    assign m0_awlen    = master_if[0].awlen;
    assign m0_awsize   = master_if[0].awsize;
    assign m0_awburst  = master_if[0].awburst;
    assign m0_awlock   = master_if[0].awlock;
    assign m0_awcache  = master_if[0].awcache;
    assign m0_awprot   = master_if[0].awprot;
    assign m0_awqos    = master_if[0].awqos;
    assign m0_awvalid  = master_if[0].awvalid;
    assign master_if[0].awready = m0_awready;
    
    assign m0_wdata    = master_if[0].wdata;
    assign m0_wstrb    = master_if[0].wstrb;
    assign m0_wlast    = master_if[0].wlast;
    assign m0_wvalid   = master_if[0].wvalid;
    assign master_if[0].wready = m0_wready;
    
    assign master_if[0].bid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, m0_bid}};
    assign master_if[0].bresp  = m0_bresp;
    assign master_if[0].bvalid = m0_bvalid;
    assign m0_bready   = master_if[0].bready;
    
    assign m0_arid     = master_if[0].arid[RTL_ID_WIDTH-1:0];
    assign m0_araddr   = master_if[0].araddr;
    assign m0_arlen    = master_if[0].arlen;
    assign m0_arsize   = master_if[0].arsize;
    assign m0_arburst  = master_if[0].arburst;
    assign m0_arlock   = master_if[0].arlock;
    assign m0_arcache  = master_if[0].arcache;
    assign m0_arprot   = master_if[0].arprot;
    assign m0_arqos    = master_if[0].arqos;
    assign m0_arvalid  = master_if[0].arvalid;
    assign master_if[0].arready = m0_arready;
    
    assign master_if[0].rid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, m0_rid}};
    assign master_if[0].rdata  = m0_rdata;
    assign master_if[0].rresp  = m0_rresp;
    assign master_if[0].rlast  = m0_rlast;
    assign master_if[0].rvalid = m0_rvalid;
    assign m0_rready   = master_if[0].rready;

    // Include connections for remaining masters
    `include "master_interface_connections.svh"
    
    // Connect slave wires to interfaces
    // Slave 0
    assign slave_if[0].awid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, s0_awid}};
    assign slave_if[0].awaddr  = s0_awaddr;
    assign slave_if[0].awlen   = s0_awlen;
    assign slave_if[0].awsize  = s0_awsize;
    assign slave_if[0].awburst = s0_awburst;
    assign slave_if[0].awlock  = s0_awlock;
    assign slave_if[0].awcache = s0_awcache;
    assign slave_if[0].awprot  = s0_awprot;
    assign slave_if[0].awqos   = s0_awqos;
    assign slave_if[0].awvalid = s0_awvalid;
    assign s0_awready  = slave_if[0].awready;
    
    assign slave_if[0].wdata   = s0_wdata;
    assign slave_if[0].wstrb   = s0_wstrb;
    assign slave_if[0].wlast   = s0_wlast;
    assign slave_if[0].wvalid  = s0_wvalid;
    assign s0_wready   = slave_if[0].wready;
    
    assign s0_bid      = slave_if[0].bid[RTL_ID_WIDTH-1:0];
    assign s0_bresp    = slave_if[0].bresp;
    assign s0_bvalid   = slave_if[0].bvalid;
    assign slave_if[0].bready  = s0_bready;
    
    assign slave_if[0].arid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, s0_arid}};
    assign slave_if[0].araddr  = s0_araddr;
    assign slave_if[0].arlen   = s0_arlen;
    assign slave_if[0].arsize  = s0_arsize;
    assign slave_if[0].arburst = s0_arburst;
    assign slave_if[0].arlock  = s0_arlock;
    assign slave_if[0].arcache = s0_arcache;
    assign slave_if[0].arprot  = s0_arprot;
    assign slave_if[0].arqos   = s0_arqos;
    assign slave_if[0].arvalid = s0_arvalid;
    assign s0_arready  = slave_if[0].arready;
    
    assign s0_rid      = slave_if[0].rid[RTL_ID_WIDTH-1:0];
    assign s0_rdata    = slave_if[0].rdata;
    assign s0_rresp    = slave_if[0].rresp;
    assign s0_rlast    = slave_if[0].rlast;
    assign s0_rvalid   = slave_if[0].rvalid;
    assign slave_if[0].rready  = s0_rready;

    // Include connections for remaining slaves
    `include "slave_interface_connections.svh"
    
    // Instantiate the real RTL interconnect
    axi4_interconnect_m{num_masters}s{num_slaves} #(
        .DATA_WIDTH(DATA_WIDTH),
        .ADDR_WIDTH(ADDR_WIDTH),
        .ID_WIDTH(RTL_ID_WIDTH),
        .USER_WIDTH(1)
    ) real_interconnect (
        .aclk(clk),
        .aresetn(rst_n),
        
        // Master 0 connections
        .m0_awid(m0_awid),
        .m0_awaddr(m0_awaddr),
        .m0_awlen(m0_awlen),
        .m0_awsize(m0_awsize),
        .m0_awburst(m0_awburst),
        .m0_awlock(m0_awlock),
        .m0_awcache(m0_awcache),
        .m0_awprot(m0_awprot),
        .m0_awqos(m0_awqos),
        .m0_awvalid(m0_awvalid),
        .m0_awready(m0_awready),
        .m0_wdata(m0_wdata),
        .m0_wstrb(m0_wstrb),
        .m0_wlast(m0_wlast),
        .m0_wvalid(m0_wvalid),
        .m0_wready(m0_wready),
        .m0_bid(m0_bid),
        .m0_bresp(m0_bresp),
        .m0_bvalid(m0_bvalid),
        .m0_bready(m0_bready),
        .m0_arid(m0_arid),
        .m0_araddr(m0_araddr),
        .m0_arlen(m0_arlen),
        .m0_arsize(m0_arsize),
        .m0_arburst(m0_arburst),
        .m0_arlock(m0_arlock),
        .m0_arcache(m0_arcache),
        .m0_arprot(m0_arprot),
        .m0_arqos(m0_arqos),
        .m0_arvalid(m0_arvalid),
        .m0_arready(m0_arready),
        .m0_rid(m0_rid),
        .m0_rdata(m0_rdata),
        .m0_rresp(m0_rresp),
        .m0_rlast(m0_rlast),
        .m0_rvalid(m0_rvalid),
        .m0_rready(m0_rready),
        
        // Include remaining master/slave connections
        `include "interconnect_port_map.svh"
    );
    
    initial begin
        $display("[%0t] DUT Wrapper: Connected to REAL axi4_interconnect_m{num_masters}s{num_slaves} RTL", $time);
        $display("[%0t] DUT Wrapper: %0d Masters x %0d Slaves", NUM_MASTERS, NUM_SLAVES, $time);
        $display("[%0t] DUT Wrapper: Interface ID_WIDTH=%0d, RTL ID_WIDTH=%0d", ID_WIDTH, RTL_ID_WIDTH, $time);
    end

endmodule : dut_wrapper"""

def generate_rtl_include_files(base_path, num_masters, num_slaves, config):
    """Generate include files for RTL wrapper"""
    import os
    
    rtl_wrapper_path = os.path.join(base_path, "rtl_wrapper")
    
    # Generate master wire declarations
    master_decls = []
    for i in range(1, num_masters):
        master_decls.append(f"""// Master {i}
wire [RTL_ID_WIDTH-1:0]     m{i}_awid;
wire [ADDR_WIDTH-1:0]       m{i}_awaddr;
wire [7:0]                  m{i}_awlen;
wire [2:0]                  m{i}_awsize;
wire [1:0]                  m{i}_awburst;
wire                        m{i}_awlock;
wire [3:0]                  m{i}_awcache;
wire [2:0]                  m{i}_awprot;
wire [3:0]                  m{i}_awqos;
wire                        m{i}_awvalid;
wire                        m{i}_awready;
wire [DATA_WIDTH-1:0]       m{i}_wdata;
wire [DATA_WIDTH/8-1:0]     m{i}_wstrb;
wire                        m{i}_wlast;
wire                        m{i}_wvalid;
wire                        m{i}_wready;
wire [RTL_ID_WIDTH-1:0]     m{i}_bid;
wire [1:0]                  m{i}_bresp;
wire                        m{i}_bvalid;
wire                        m{i}_bready;
wire [RTL_ID_WIDTH-1:0]     m{i}_arid;
wire [ADDR_WIDTH-1:0]       m{i}_araddr;
wire [7:0]                  m{i}_arlen;
wire [2:0]                  m{i}_arsize;
wire [1:0]                  m{i}_arburst;
wire                        m{i}_arlock;
wire [3:0]                  m{i}_arcache;
wire [2:0]                  m{i}_arprot;
wire [3:0]                  m{i}_arqos;
wire                        m{i}_arvalid;
wire                        m{i}_arready;
wire [RTL_ID_WIDTH-1:0]     m{i}_rid;
wire [DATA_WIDTH-1:0]       m{i}_rdata;
wire [1:0]                  m{i}_rresp;
wire                        m{i}_rlast;
wire                        m{i}_rvalid;
wire                        m{i}_rready;""")
    
    with open(os.path.join(rtl_wrapper_path, "master_wire_declarations.svh"), "w") as f:
        f.write("// Master wire declarations for Masters 1-" + str(num_masters-1) + "\n")
        f.write("// This file is included in dut_wrapper.sv\n\n")
        f.write("\n\n".join(master_decls))
    
    # Generate slave wire declarations
    slave_decls = []
    for i in range(1, num_slaves):
        slave_decls.append(f"""// Slave {i}
wire [RTL_ID_WIDTH-1:0]     s{i}_awid;
wire [ADDR_WIDTH-1:0]       s{i}_awaddr;
wire [7:0]                  s{i}_awlen;
wire [2:0]                  s{i}_awsize;
wire [1:0]                  s{i}_awburst;
wire                        s{i}_awlock;
wire [3:0]                  s{i}_awcache;
wire [2:0]                  s{i}_awprot;
wire [3:0]                  s{i}_awqos;
wire                        s{i}_awvalid;
wire                        s{i}_awready;
wire [DATA_WIDTH-1:0]       s{i}_wdata;
wire [DATA_WIDTH/8-1:0]     s{i}_wstrb;
wire                        s{i}_wlast;
wire                        s{i}_wvalid;
wire                        s{i}_wready;
wire [RTL_ID_WIDTH-1:0]     s{i}_bid;
wire [1:0]                  s{i}_bresp;
wire                        s{i}_bvalid;
wire                        s{i}_bready;
wire [RTL_ID_WIDTH-1:0]     s{i}_arid;
wire [ADDR_WIDTH-1:0]       s{i}_araddr;
wire [7:0]                  s{i}_arlen;
wire [2:0]                  s{i}_arsize;
wire [1:0]                  s{i}_arburst;
wire                        s{i}_arlock;
wire [3:0]                  s{i}_arcache;
wire [2:0]                  s{i}_arprot;
wire [3:0]                  s{i}_arqos;
wire                        s{i}_arvalid;
wire                        s{i}_arready;
wire [RTL_ID_WIDTH-1:0]     s{i}_rid;
wire [DATA_WIDTH-1:0]       s{i}_rdata;
wire [1:0]                  s{i}_rresp;
wire                        s{i}_rlast;
wire                        s{i}_rvalid;
wire                        s{i}_rready;""")
    
    with open(os.path.join(rtl_wrapper_path, "slave_wire_declarations.svh"), "w") as f:
        f.write("// Slave wire declarations for Slaves 1-" + str(num_slaves-1) + "\n")
        f.write("// This file is included in dut_wrapper.sv\n")
        f.write("// Note: RTL outputs ID_WIDTH=4, but slaves need SLAVE_ID_WIDTH (includes master index)\n\n")
        f.write("\n\n".join(slave_decls))
    
    # Generate master interface connections
    master_conns = []
    for i in range(1, num_masters):
        master_conns.append(f"""// Master {i}
assign m{i}_awid     = master_if[{i}].awid[RTL_ID_WIDTH-1:0];
assign m{i}_awaddr   = master_if[{i}].awaddr;
assign m{i}_awlen    = master_if[{i}].awlen;
assign m{i}_awsize   = master_if[{i}].awsize;
assign m{i}_awburst  = master_if[{i}].awburst;
assign m{i}_awlock   = master_if[{i}].awlock;
assign m{i}_awcache  = master_if[{i}].awcache;
assign m{i}_awprot   = master_if[{i}].awprot;
assign m{i}_awqos    = master_if[{i}].awqos;
assign m{i}_awvalid  = master_if[{i}].awvalid;
assign master_if[{i}].awready = m{i}_awready;

assign m{i}_wdata    = master_if[{i}].wdata;
assign m{i}_wstrb    = master_if[{i}].wstrb;
assign m{i}_wlast    = master_if[{i}].wlast;
assign m{i}_wvalid   = master_if[{i}].wvalid;
assign master_if[{i}].wready = m{i}_wready;

assign master_if[{i}].bid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, m{i}_bid}};
assign master_if[{i}].bresp  = m{i}_bresp;
assign master_if[{i}].bvalid = m{i}_bvalid;
assign m{i}_bready   = master_if[{i}].bready;

assign m{i}_arid     = master_if[{i}].arid[RTL_ID_WIDTH-1:0];
assign m{i}_araddr   = master_if[{i}].araddr;
assign m{i}_arlen    = master_if[{i}].arlen;
assign m{i}_arsize   = master_if[{i}].arsize;
assign m{i}_arburst  = master_if[{i}].arburst;
assign m{i}_arlock   = master_if[{i}].arlock;
assign m{i}_arcache  = master_if[{i}].arcache;
assign m{i}_arprot   = master_if[{i}].arprot;
assign m{i}_arqos    = master_if[{i}].arqos;
assign m{i}_arvalid  = master_if[{i}].arvalid;
assign master_if[{i}].arready = m{i}_arready;

assign master_if[{i}].rid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, m{i}_rid}};
assign master_if[{i}].rdata  = m{i}_rdata;
assign master_if[{i}].rresp  = m{i}_rresp;
assign master_if[{i}].rlast  = m{i}_rlast;
assign master_if[{i}].rvalid = m{i}_rvalid;
assign m{i}_rready   = master_if[{i}].rready;""")
    
    with open(os.path.join(rtl_wrapper_path, "master_interface_connections.svh"), "w") as f:
        f.write("\n\n".join(master_conns))
    
    # Generate slave interface connections
    slave_conns = []
    for i in range(1, num_slaves):
        slave_conns.append(f"""// Slave {i}
assign slave_if[{i}].awid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, s{i}_awid}};
assign slave_if[{i}].awaddr  = s{i}_awaddr;
assign slave_if[{i}].awlen   = s{i}_awlen;
assign slave_if[{i}].awsize  = s{i}_awsize;
assign slave_if[{i}].awburst = s{i}_awburst;
assign slave_if[{i}].awlock  = s{i}_awlock;
assign slave_if[{i}].awcache = s{i}_awcache;
assign slave_if[{i}].awprot  = s{i}_awprot;
assign slave_if[{i}].awqos   = s{i}_awqos;
assign slave_if[{i}].awvalid = s{i}_awvalid;
assign s{i}_awready  = slave_if[{i}].awready;

assign slave_if[{i}].wdata   = s{i}_wdata;
assign slave_if[{i}].wstrb   = s{i}_wstrb;
assign slave_if[{i}].wlast   = s{i}_wlast;
assign slave_if[{i}].wvalid  = s{i}_wvalid;
assign s{i}_wready   = slave_if[{i}].wready;

assign s{i}_bid      = slave_if[{i}].bid[RTL_ID_WIDTH-1:0];
assign s{i}_bresp    = slave_if[{i}].bresp;
assign s{i}_bvalid   = slave_if[{i}].bvalid;
assign slave_if[{i}].bready  = s{i}_bready;

assign slave_if[{i}].arid    = {{{{(ID_WIDTH-RTL_ID_WIDTH){{1'b0}}}}, s{i}_arid}};
assign slave_if[{i}].araddr  = s{i}_araddr;
assign slave_if[{i}].arlen   = s{i}_arlen;
assign slave_if[{i}].arsize  = s{i}_arsize;
assign slave_if[{i}].arburst = s{i}_arburst;
assign slave_if[{i}].arlock  = s{i}_arlock;
assign slave_if[{i}].arcache = s{i}_arcache;
assign slave_if[{i}].arprot  = s{i}_arprot;
assign slave_if[{i}].arqos   = s{i}_arqos;
assign slave_if[{i}].arvalid = s{i}_arvalid;
assign s{i}_arready  = slave_if[{i}].arready;

assign s{i}_rid      = slave_if[{i}].rid[RTL_ID_WIDTH-1:0];
assign s{i}_rdata    = slave_if[{i}].rdata;
assign s{i}_rresp    = slave_if[{i}].rresp;
assign s{i}_rlast    = slave_if[{i}].rlast;
assign s{i}_rvalid   = slave_if[{i}].rvalid;
assign slave_if[{i}].rready  = s{i}_rready;""")
    
    with open(os.path.join(rtl_wrapper_path, "slave_interface_connections.svh"), "w") as f:
        f.write("\n\n".join(slave_conns))
    
    # Generate interconnect port mappings
    port_maps = []
    
    # Master port mappings
    for i in range(1, num_masters):
        port_maps.append(f"""        // Master {i} connections
        .m{i}_awid(m{i}_awid),
        .m{i}_awaddr(m{i}_awaddr),
        .m{i}_awlen(m{i}_awlen),
        .m{i}_awsize(m{i}_awsize),
        .m{i}_awburst(m{i}_awburst),
        .m{i}_awlock(m{i}_awlock),
        .m{i}_awcache(m{i}_awcache),
        .m{i}_awprot(m{i}_awprot),
        .m{i}_awqos(m{i}_awqos),
        .m{i}_awvalid(m{i}_awvalid),
        .m{i}_awready(m{i}_awready),
        .m{i}_wdata(m{i}_wdata),
        .m{i}_wstrb(m{i}_wstrb),
        .m{i}_wlast(m{i}_wlast),
        .m{i}_wvalid(m{i}_wvalid),
        .m{i}_wready(m{i}_wready),
        .m{i}_bid(m{i}_bid),
        .m{i}_bresp(m{i}_bresp),
        .m{i}_bvalid(m{i}_bvalid),
        .m{i}_bready(m{i}_bready),
        .m{i}_arid(m{i}_arid),
        .m{i}_araddr(m{i}_araddr),
        .m{i}_arlen(m{i}_arlen),
        .m{i}_arsize(m{i}_arsize),
        .m{i}_arburst(m{i}_arburst),
        .m{i}_arlock(m{i}_arlock),
        .m{i}_arcache(m{i}_arcache),
        .m{i}_arprot(m{i}_arprot),
        .m{i}_arqos(m{i}_arqos),
        .m{i}_arvalid(m{i}_arvalid),
        .m{i}_arready(m{i}_arready),
        .m{i}_rid(m{i}_rid),
        .m{i}_rdata(m{i}_rdata),
        .m{i}_rresp(m{i}_rresp),
        .m{i}_rlast(m{i}_rlast),
        .m{i}_rvalid(m{i}_rvalid),
        .m{i}_rready(m{i}_rready),""")
    
    # Slave port mappings  
    for i in range(0, num_slaves):
        port_maps.append(f"""        // Slave {i} connections
        .s{i}_awid(s{i}_awid),
        .s{i}_awaddr(s{i}_awaddr),
        .s{i}_awlen(s{i}_awlen),
        .s{i}_awsize(s{i}_awsize),
        .s{i}_awburst(s{i}_awburst),
        .s{i}_awlock(s{i}_awlock),
        .s{i}_awcache(s{i}_awcache),
        .s{i}_awprot(s{i}_awprot),
        .s{i}_awqos(s{i}_awqos),
        .s{i}_awvalid(s{i}_awvalid),
        .s{i}_awready(s{i}_awready),
        .s{i}_wdata(s{i}_wdata),
        .s{i}_wstrb(s{i}_wstrb),
        .s{i}_wlast(s{i}_wlast),
        .s{i}_wvalid(s{i}_wvalid),
        .s{i}_wready(s{i}_wready),
        .s{i}_bid(s{i}_bid),
        .s{i}_bresp(s{i}_bresp),
        .s{i}_bvalid(s{i}_bvalid),
        .s{i}_bready(s{i}_bready),
        .s{i}_arid(s{i}_arid),
        .s{i}_araddr(s{i}_araddr),
        .s{i}_arlen(s{i}_arlen),
        .s{i}_arsize(s{i}_arsize),
        .s{i}_arburst(s{i}_arburst),
        .s{i}_arlock(s{i}_arlock),
        .s{i}_arcache(s{i}_arcache),
        .s{i}_arprot(s{i}_arprot),
        .s{i}_arqos(s{i}_arqos),
        .s{i}_arvalid(s{i}_arvalid),
        .s{i}_arready(s{i}_arready),
        .s{i}_rid(s{i}_rid),
        .s{i}_rdata(s{i}_rdata),
        .s{i}_rresp(s{i}_rresp),
        .s{i}_rlast(s{i}_rlast),
        .s{i}_rvalid(s{i}_rvalid),
        .s{i}_rready(s{i}_rready){"," if i < num_slaves-1 else ""}""")
    
    with open(os.path.join(rtl_wrapper_path, "interconnect_port_map.svh"), "w") as f:
        f.write("\n".join(port_maps))
    
    print(f"Generated RTL include files in {rtl_wrapper_path}")
    
def update_compile_file(base_path):
    """Update compile file to include rtl_wrapper directory"""
    import os
    compile_file = os.path.join(base_path, "sim/axi4_compile.f")
    
    # Read existing file
    with open(compile_file, "r") as f:
        lines = f.readlines()
    
    # Check if already added
    rtl_wrapper_inc = "+incdir+${VIP_ROOT}/rtl_wrapper\n"
    if rtl_wrapper_inc not in lines:
        # Find where to insert (after other includes)
        insert_idx = -1
        for i, line in enumerate(lines):
            if "+incdir+${VIP_ROOT}/test" in line:
                insert_idx = i + 1
                break
        
        if insert_idx > 0:
            lines.insert(insert_idx, rtl_wrapper_inc)
            
            # Write back
            with open(compile_file, "w") as f:
                f.writelines(lines)
            print(f"Updated {compile_file} with rtl_wrapper include path")

if __name__ == "__main__":
    print("RTL Integration Patch for VIP Environment Generator")
    print("This module provides functions to generate real RTL wrappers")
    print("Import and use the functions in your VIP generator script")