#!/usr/bin/env python3
"""
VIP Assertion Generator
Implements comprehensive assertion-based verification based on tim_axi4_vip
Step 3 of VIP Enhancement
"""

import os
from datetime import datetime
from typing import Dict, List, Optional

class VIPAssertionGenerator:
    """Generate assertion-based verification components"""
    
    def __init__(self, config):
        self.config = config
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
    def generate_assertions(self, output_dir):
        """Generate all assertion components"""
        assertions_dir = os.path.join(output_dir, "assertions")
        os.makedirs(assertions_dir, exist_ok=True)
        
        # Generate assertion files
        self._generate_master_assertions(assertions_dir)
        self._generate_slave_assertions(assertions_dir)
        self._generate_tb_master_assertions(assertions_dir)
        self._generate_tb_slave_assertions(assertions_dir)
        self._generate_protocol_assertions_pkg(assertions_dir)
        
        return assertions_dir
    
    def _generate_master_assertions(self, output_dir):
        """Generate master-side assertions"""
        content = f"""//==============================================================================
// AXI4 Master Assertions
// Generated by Assertion Generator
// Date: {self.timestamp}
// Based on tim_axi4_vip master_assertions.sv
//==============================================================================

`ifndef AXI4_MASTER_ASSERTIONS_SV
`define AXI4_MASTER_ASSERTIONS_SV

module axi4_master_assertions #(
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter ID_WIDTH = {self.config.id_width},
    parameter USER_WIDTH = {self.config.user_width if hasattr(self.config, 'user_width') else 1}
)(
    input wire aclk,
    input wire aresetn,
    
    // Master interface signals
    axi4_if.monitor master_if
);

    //==========================================================================
    // Helper functions
    //==========================================================================
    
    function automatic bit is_valid_burst_type(input [1:0] burst);
        return (burst != 2'b11); // RESERVED burst type is invalid
    endfunction
    
    function automatic bit is_valid_burst_len(input [1:0] burst, input [7:0] len);
        case(burst)
            2'b00: return 1; // FIXED: any length valid
            2'b01: return (len < 256); // INCR: up to 256 beats (AXI4)
            2'b10: return (len == 1 || len == 3 || len == 7 || len == 15); // WRAP: 2,4,8,16
            default: return 0;
        endcase
    endfunction
    
    function automatic bit is_4kb_boundary_crossed(
        input [ADDR_WIDTH-1:0] addr,
        input [7:0] len,
        input [2:0] size
    );
        logic [ADDR_WIDTH-1:0] start_addr, end_addr;
        int bytes_per_beat;
        
        bytes_per_beat = 1 << size;
        start_addr = addr;
        end_addr = addr + (len + 1) * bytes_per_beat - 1;
        
        return (start_addr[11:0] > end_addr[11:0]); // Crossed if wrapped
    endfunction
    
    //==========================================================================
    // Channel Handshake Assertions
    //==========================================================================
    
    // AW channel: AWVALID must remain stable until AWREADY
    property p_aw_valid_stable;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.awvalid && !master_if.awready) |=> master_if.awvalid;
    endproperty
    aw_valid_stable: assert property(p_aw_valid_stable)
        else $error("AWVALID deasserted before AWREADY");
    
    // W channel: WVALID must remain stable until WREADY
    property p_w_valid_stable;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.wvalid && !master_if.wready) |=> master_if.wvalid;
    endproperty
    w_valid_stable: assert property(p_w_valid_stable)
        else $error("WVALID deasserted before WREADY");
    
    // AR channel: ARVALID must remain stable until ARREADY
    property p_ar_valid_stable;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.arvalid && !master_if.arready) |=> master_if.arvalid;
    endproperty
    ar_valid_stable: assert property(p_ar_valid_stable)
        else $error("ARVALID deasserted before ARREADY");
    
    // B channel: BREADY can change at any time (no assertion needed)
    
    // R channel: RREADY can change at any time (no assertion needed)
    
    //==========================================================================
    // Signal Stability Assertions
    //==========================================================================
    
    // AW channel signals must be stable when AWVALID is high
    property p_aw_signal_stable(signal);
        @(posedge aclk) disable iff(!aresetn)
        (master_if.awvalid && !master_if.awready) |=> $stable(signal);
    endproperty
    
    aw_id_stable: assert property(p_aw_signal_stable(master_if.awid))
        else $error("AWID changed while AWVALID high");
    aw_addr_stable: assert property(p_aw_signal_stable(master_if.awaddr))
        else $error("AWADDR changed while AWVALID high");
    aw_len_stable: assert property(p_aw_signal_stable(master_if.awlen))
        else $error("AWLEN changed while AWVALID high");
    aw_size_stable: assert property(p_aw_signal_stable(master_if.awsize))
        else $error("AWSIZE changed while AWVALID high");
    aw_burst_stable: assert property(p_aw_signal_stable(master_if.awburst))
        else $error("AWBURST changed while AWVALID high");
    aw_lock_stable: assert property(p_aw_signal_stable(master_if.awlock))
        else $error("AWLOCK changed while AWVALID high");
    aw_cache_stable: assert property(p_aw_signal_stable(master_if.awcache))
        else $error("AWCACHE changed while AWVALID high");
    aw_prot_stable: assert property(p_aw_signal_stable(master_if.awprot))
        else $error("AWPROT changed while AWVALID high");
    aw_qos_stable: assert property(p_aw_signal_stable(master_if.awqos))
        else $error("AWQOS changed while AWVALID high");
    aw_region_stable: assert property(p_aw_signal_stable(master_if.awregion))
        else $error("AWREGION changed while AWVALID high");
    
    // W channel signals must be stable when WVALID is high
    property p_w_signal_stable(signal);
        @(posedge aclk) disable iff(!aresetn)
        (master_if.wvalid && !master_if.wready) |=> $stable(signal);
    endproperty
    
    w_data_stable: assert property(p_w_signal_stable(master_if.wdata))
        else $error("WDATA changed while WVALID high");
    w_strb_stable: assert property(p_w_signal_stable(master_if.wstrb))
        else $error("WSTRB changed while WVALID high");
    w_last_stable: assert property(p_w_signal_stable(master_if.wlast))
        else $error("WLAST changed while WVALID high");
    
    // AR channel signals must be stable when ARVALID is high
    property p_ar_signal_stable(signal);
        @(posedge aclk) disable iff(!aresetn)
        (master_if.arvalid && !master_if.arready) |=> $stable(signal);
    endproperty
    
    ar_id_stable: assert property(p_ar_signal_stable(master_if.arid))
        else $error("ARID changed while ARVALID high");
    ar_addr_stable: assert property(p_ar_signal_stable(master_if.araddr))
        else $error("ARADDR changed while ARVALID high");
    ar_len_stable: assert property(p_ar_signal_stable(master_if.arlen))
        else $error("ARLEN changed while ARVALID high");
    ar_size_stable: assert property(p_ar_signal_stable(master_if.arsize))
        else $error("ARSIZE changed while ARVALID high");
    ar_burst_stable: assert property(p_ar_signal_stable(master_if.arburst))
        else $error("ARBURST changed while ARVALID high");
    ar_lock_stable: assert property(p_ar_signal_stable(master_if.arlock))
        else $error("ARLOCK changed while ARVALID high");
    ar_cache_stable: assert property(p_ar_signal_stable(master_if.arcache))
        else $error("ARCACHE changed while ARVALID high");
    ar_prot_stable: assert property(p_ar_signal_stable(master_if.arprot))
        else $error("ARPROT changed while ARVALID high");
    ar_qos_stable: assert property(p_ar_signal_stable(master_if.arqos))
        else $error("ARQOS changed while ARVALID high");
    ar_region_stable: assert property(p_ar_signal_stable(master_if.arregion))
        else $error("ARREGION changed while ARVALID high");
    
    //==========================================================================
    // Burst Type and Length Assertions
    //==========================================================================
    
    // Valid burst type check
    property p_aw_valid_burst_type;
        @(posedge aclk) disable iff(!aresetn)
        master_if.awvalid |-> is_valid_burst_type(master_if.awburst);
    endproperty
    aw_valid_burst_type: assert property(p_aw_valid_burst_type)
        else $error("Invalid AWBURST type: %0b", master_if.awburst);
    
    property p_ar_valid_burst_type;
        @(posedge aclk) disable iff(!aresetn)
        master_if.arvalid |-> is_valid_burst_type(master_if.arburst);
    endproperty
    ar_valid_burst_type: assert property(p_ar_valid_burst_type)
        else $error("Invalid ARBURST type: %0b", master_if.arburst);
    
    // Valid burst length for burst type
    property p_aw_valid_burst_len;
        @(posedge aclk) disable iff(!aresetn)
        master_if.awvalid |-> is_valid_burst_len(master_if.awburst, master_if.awlen);
    endproperty
    aw_valid_burst_len: assert property(p_aw_valid_burst_len)
        else $error("Invalid AWLEN %0d for AWBURST %0b", master_if.awlen, master_if.awburst);
    
    property p_ar_valid_burst_len;
        @(posedge aclk) disable iff(!aresetn)
        master_if.arvalid |-> is_valid_burst_len(master_if.arburst, master_if.arlen);
    endproperty
    ar_valid_burst_len: assert property(p_ar_valid_burst_len)
        else $error("Invalid ARLEN %0d for ARBURST %0b", master_if.arlen, master_if.arburst);
    
    //==========================================================================
    // 4KB Boundary Crossing Assertions
    //==========================================================================
    
    // Warning for 4KB boundary crossing (not an error per spec)
    property p_aw_4kb_boundary;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.awvalid && master_if.awready) |-> 
        !is_4kb_boundary_crossed(master_if.awaddr, master_if.awlen, master_if.awsize);
    endproperty
    aw_4kb_boundary: assert property(p_aw_4kb_boundary)
        else $warning("Write transaction crosses 4KB boundary at address 0x%0h", master_if.awaddr);
    
    property p_ar_4kb_boundary;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.arvalid && master_if.arready) |-> 
        !is_4kb_boundary_crossed(master_if.araddr, master_if.arlen, master_if.arsize);
    endproperty
    ar_4kb_boundary: assert property(p_ar_4kb_boundary)
        else $warning("Read transaction crosses 4KB boundary at address 0x%0h", master_if.araddr);
    
    //==========================================================================
    // Exclusive Access Assertions
    //==========================================================================
    
    // Exclusive access size constraints
    property p_aw_exclusive_size;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.awvalid && master_if.awlock) |-> 
        ((1 << master_if.awsize) * (master_if.awlen + 1) <= 128);
    endproperty
    aw_exclusive_size: assert property(p_aw_exclusive_size)
        else $error("Exclusive write exceeds 128 bytes");
    
    property p_ar_exclusive_size;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.arvalid && master_if.arlock) |-> 
        ((1 << master_if.arsize) * (master_if.arlen + 1) <= 128);
    endproperty
    ar_exclusive_size: assert property(p_ar_exclusive_size)
        else $error("Exclusive read exceeds 128 bytes");
    
    // Exclusive access must be power of 2
    function automatic bit is_power_of_2(input int value);
        return (value != 0) && ((value & (value - 1)) == 0);
    endfunction
    
    property p_aw_exclusive_pow2;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.awvalid && master_if.awlock) |-> 
        is_power_of_2((1 << master_if.awsize) * (master_if.awlen + 1));
    endproperty
    aw_exclusive_pow2: assert property(p_aw_exclusive_pow2)
        else $error("Exclusive write size not power of 2");
    
    //==========================================================================
    // Write Strobe Assertions
    //==========================================================================
    
    // WSTRB must be valid for the transfer size
    function automatic bit is_valid_wstrb(input [DATA_WIDTH/8-1:0] strb, input [2:0] size);
        int bytes_per_transfer = 1 << size;
        int strb_bits = 0;
        
        // Count active strobe bits
        for(int i = 0; i < DATA_WIDTH/8; i++) begin
            if(strb[i]) strb_bits++;
        end
        
        // For narrow transfers, only lower strobes should be active
        if(bytes_per_transfer < DATA_WIDTH/8) begin
            for(int i = bytes_per_transfer; i < DATA_WIDTH/8; i++) begin
                if(strb[i]) return 0;
            end
        end
        
        return 1;
    endfunction
    
    // Track write address info for strobe checking
    logic [2:0] aw_size_q;
    logic aw_pending;
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            aw_pending <= 0;
        end else if(master_if.awvalid && master_if.awready) begin
            aw_size_q <= master_if.awsize;
            aw_pending <= 1;
        end else if(master_if.wvalid && master_if.wready && master_if.wlast) begin
            aw_pending <= 0;
        end
    end
    
    property p_w_valid_strb;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.wvalid && aw_pending) |-> is_valid_wstrb(master_if.wstrb, aw_size_q);
    endproperty
    w_valid_strb: assert property(p_w_valid_strb)
        else $error("Invalid WSTRB for transfer size");
    
    //==========================================================================
    // WLAST Tracking and Assertion
    //==========================================================================
    
    // Track expected number of write beats
    logic [7:0] expected_w_beats;
    logic [7:0] w_beat_count;
    logic w_transfer_active;
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            expected_w_beats <= 0;
            w_beat_count <= 0;
            w_transfer_active <= 0;
        end else begin
            // Capture expected beats from AW channel
            if(master_if.awvalid && master_if.awready) begin
                expected_w_beats <= master_if.awlen;
                w_transfer_active <= 1;
                w_beat_count <= 0;
            end
            
            // Count W beats
            if(master_if.wvalid && master_if.wready) begin
                if(master_if.wlast) begin
                    w_transfer_active <= 0;
                end else begin
                    w_beat_count <= w_beat_count + 1;
                end
            end
        end
    end
    
    // WLAST must be asserted on the last beat
    property p_w_last_timing;
        @(posedge aclk) disable iff(!aresetn)
        (master_if.wvalid && master_if.wready && w_transfer_active) |-> 
        (master_if.wlast == (w_beat_count == expected_w_beats));
    endproperty
    w_last_timing: assert property(p_w_last_timing)
        else $error("WLAST assertion mismatch: beat %0d of %0d", w_beat_count, expected_w_beats);
    
    //==========================================================================
    // Response Ready Assertions
    //==========================================================================
    
    // Master must eventually accept responses
    property p_b_ready_eventuality;
        @(posedge aclk) disable iff(!aresetn)
        master_if.bvalid |-> ##[1:1000] master_if.bready;
    endproperty
    b_ready_eventuality: assert property(p_b_ready_eventuality)
        else $error("BREADY not asserted within timeout");
    
    property p_r_ready_eventuality;
        @(posedge aclk) disable iff(!aresetn)
        master_if.rvalid |-> ##[1:1000] master_if.rready;
    endproperty
    r_ready_eventuality: assert property(p_r_ready_eventuality)
        else $error("RREADY not asserted within timeout");
    
    //==========================================================================
    // Coverage
    //==========================================================================
    
    covergroup master_coverage @(posedge aclk);
        option.per_instance = 1;
        
        // Write burst types
        aw_burst_cp: coverpoint master_if.awburst iff (master_if.awvalid && master_if.awready) {
            bins fixed = {2'b00};
            bins incr = {2'b01};
            bins wrap = {2'b10};
            illegal_bins reserved = {2'b11};
        }
        
        // Read burst types
        ar_burst_cp: coverpoint master_if.arburst iff (master_if.arvalid && master_if.arready) {
            bins fixed = {2'b00};
            bins incr = {2'b01};
            bins wrap = {2'b10};
            illegal_bins reserved = {2'b11};
        }
        
        // Transfer sizes
        aw_size_cp: coverpoint master_if.awsize iff (master_if.awvalid && master_if.awready) {
            bins sizes[] = {[0:$clog2(DATA_WIDTH/8)]};
        }
        
        ar_size_cp: coverpoint master_if.arsize iff (master_if.arvalid && master_if.arready) {
            bins sizes[] = {[0:$clog2(DATA_WIDTH/8)]};
        }
        
        // Burst lengths
        aw_len_cp: coverpoint master_if.awlen iff (master_if.awvalid && master_if.awready) {
            bins single = {0};
            bins short = {[1:15]};
            bins medium = {[16:63]};
            bins long = {[64:127]};
            bins max = {[128:255]};
        }
        
        // QoS levels
        aw_qos_cp: coverpoint master_if.awqos iff (master_if.awvalid && master_if.awready);
        ar_qos_cp: coverpoint master_if.arqos iff (master_if.arvalid && master_if.arready);
        
        // Protection types
        aw_prot_cp: coverpoint master_if.awprot iff (master_if.awvalid && master_if.awready) {
            bins secure_priv_data = {3'b000};
            bins secure_priv_inst = {3'b100};
            bins nonsec_unpriv_data = {3'b011};
            bins others = default;
        }
        
        // Exclusive access
        aw_lock_cp: coverpoint master_if.awlock iff (master_if.awvalid && master_if.awready);
        ar_lock_cp: coverpoint master_if.arlock iff (master_if.arvalid && master_if.arready);
        
        // Cross coverage
        aw_burst_x_len: cross aw_burst_cp, aw_len_cp;
        ar_burst_x_len: cross ar_burst_cp, ar_len_cp;
    endgroup
    
    master_coverage master_cov = new();
    
endmodule

`endif // AXI4_MASTER_ASSERTIONS_SV
"""
        
        filepath = os.path.join(output_dir, "master_assertions.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_slave_assertions(self, output_dir):
        """Generate slave-side assertions"""
        content = f"""//==============================================================================
// AXI4 Slave Assertions
// Generated by Assertion Generator
// Date: {self.timestamp}
// Based on tim_axi4_vip slave_assertions.sv
//==============================================================================

`ifndef AXI4_SLAVE_ASSERTIONS_SV
`define AXI4_SLAVE_ASSERTIONS_SV

module axi4_slave_assertions #(
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter ID_WIDTH = {self.config.id_width},
    parameter USER_WIDTH = {self.config.user_width if hasattr(self.config, 'user_width') else 1}
)(
    input wire aclk,
    input wire aresetn,
    
    // Slave interface signals
    axi4_if.monitor slave_if
);

    //==========================================================================
    // Slave Response Assertions
    //==========================================================================
    
    // BVALID must remain stable until BREADY
    property p_b_valid_stable;
        @(posedge aclk) disable iff(!aresetn)
        (slave_if.bvalid && !slave_if.bready) |=> slave_if.bvalid;
    endproperty
    b_valid_stable: assert property(p_b_valid_stable)
        else $error("BVALID deasserted before BREADY");
    
    // RVALID must remain stable until RREADY
    property p_r_valid_stable;
        @(posedge aclk) disable iff(!aresetn)
        (slave_if.rvalid && !slave_if.rready) |=> slave_if.rvalid;
    endproperty
    r_valid_stable: assert property(p_r_valid_stable)
        else $error("RVALID deasserted before RREADY");
    
    // Response signal stability
    property p_b_signal_stable(signal);
        @(posedge aclk) disable iff(!aresetn)
        (slave_if.bvalid && !slave_if.bready) |=> $stable(signal);
    endproperty
    
    b_id_stable: assert property(p_b_signal_stable(slave_if.bid))
        else $error("BID changed while BVALID high");
    b_resp_stable: assert property(p_b_signal_stable(slave_if.bresp))
        else $error("BRESP changed while BVALID high");
    
    property p_r_signal_stable(signal);
        @(posedge aclk) disable iff(!aresetn)
        (slave_if.rvalid && !slave_if.rready) |=> $stable(signal);
    endproperty
    
    r_id_stable: assert property(p_r_signal_stable(slave_if.rid))
        else $error("RID changed while RVALID high");
    r_data_stable: assert property(p_r_signal_stable(slave_if.rdata))
        else $error("RDATA changed while RVALID high");
    r_resp_stable: assert property(p_r_signal_stable(slave_if.rresp))
        else $error("RRESP changed while RVALID high");
    r_last_stable: assert property(p_r_signal_stable(slave_if.rlast))
        else $error("RLAST changed while RVALID high");
    
    //==========================================================================
    // Response Type Assertions
    //==========================================================================
    
    // Valid response types
    property p_b_valid_resp;
        @(posedge aclk) disable iff(!aresetn)
        slave_if.bvalid |-> (slave_if.bresp inside {2'b00, 2'b01, 2'b10, 2'b11});
    endproperty
    b_valid_resp: assert property(p_b_valid_resp)
        else $error("Invalid BRESP: %0b", slave_if.bresp);
    
    property p_r_valid_resp;
        @(posedge aclk) disable iff(!aresetn)
        slave_if.rvalid |-> (slave_if.rresp inside {2'b00, 2'b01, 2'b10, 2'b11});
    endproperty
    r_valid_resp: assert property(p_r_valid_resp)
        else $error("Invalid RRESP: %0b", slave_if.rresp);
    
    //==========================================================================
    // ID Matching Assertions
    //==========================================================================
    
    // Track outstanding write IDs
    logic [ID_WIDTH-1:0] outstanding_aw_ids[$];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            outstanding_aw_ids.delete();
        end else begin
            // Capture AW IDs
            if(slave_if.awvalid && slave_if.awready) begin
                outstanding_aw_ids.push_back(slave_if.awid);
            end
            
            // Check and remove B IDs
            if(slave_if.bvalid && slave_if.bready) begin
                automatic bit found = 0;
                for(int i = 0; i < outstanding_aw_ids.size(); i++) begin
                    if(outstanding_aw_ids[i] == slave_if.bid) begin
                        outstanding_aw_ids.delete(i);
                        found = 1;
                        break;
                    end
                end
                if(!found) begin
                    $error("BID %0h has no matching AWID", slave_if.bid);
                end
            end
        end
    end
    
    // Track outstanding read IDs
    logic [ID_WIDTH-1:0] outstanding_ar_ids[$];
    logic [7:0] expected_r_beats[logic [ID_WIDTH-1:0]];
    logic [7:0] r_beat_count[logic [ID_WIDTH-1:0]];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            outstanding_ar_ids.delete();
            expected_r_beats.delete();
            r_beat_count.delete();
        end else begin
            // Capture AR IDs and expected beats
            if(slave_if.arvalid && slave_if.arready) begin
                outstanding_ar_ids.push_back(slave_if.arid);
                expected_r_beats[slave_if.arid] = slave_if.arlen;
                r_beat_count[slave_if.arid] = 0;
            end
            
            // Check R IDs and count beats
            if(slave_if.rvalid && slave_if.rready) begin
                automatic bit found = 0;
                foreach(outstanding_ar_ids[i]) begin
                    if(outstanding_ar_ids[i] == slave_if.rid) begin
                        found = 1;
                        
                        // Check RLAST timing
                        if(slave_if.rlast) begin
                            if(r_beat_count[slave_if.rid] != expected_r_beats[slave_if.rid]) begin
                                $error("RLAST mismatch for RID %0h: expected beat %0d, got %0d",
                                      slave_if.rid, expected_r_beats[slave_if.rid], 
                                      r_beat_count[slave_if.rid]);
                            end
                            // Clean up completed read
                            outstanding_ar_ids.delete(i);
                            expected_r_beats.delete(slave_if.rid);
                            r_beat_count.delete(slave_if.rid);
                        end else begin
                            r_beat_count[slave_if.rid]++;
                        end
                        break;
                    end
                end
                if(!found) begin
                    $error("RID %0h has no matching ARID", slave_if.rid);
                end
            end
        end
    end
    
    //==========================================================================
    // Ready Signal Assertions
    //==========================================================================
    
    // Slave must eventually accept commands
    property p_aw_ready_eventuality;
        @(posedge aclk) disable iff(!aresetn)
        slave_if.awvalid |-> ##[1:1000] slave_if.awready;
    endproperty
    aw_ready_eventuality: assert property(p_aw_ready_eventuality)
        else $error("AWREADY not asserted within timeout");
    
    property p_w_ready_eventuality;
        @(posedge aclk) disable iff(!aresetn)
        slave_if.wvalid |-> ##[1:1000] slave_if.wready;
    endproperty
    w_ready_eventuality: assert property(p_w_ready_eventuality)
        else $error("WREADY not asserted within timeout");
    
    property p_ar_ready_eventuality;
        @(posedge aclk) disable iff(!aresetn)
        slave_if.arvalid |-> ##[1:1000] slave_if.arready;
    endproperty
    ar_ready_eventuality: assert property(p_ar_ready_eventuality)
        else $error("ARREADY not asserted within timeout");
    
    //==========================================================================
    // Exclusive Access Response Assertions
    //==========================================================================
    
    // Track exclusive accesses
    logic exclusive_write_pending[logic [ID_WIDTH-1:0]];
    logic exclusive_read_pending[logic [ID_WIDTH-1:0]];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            exclusive_write_pending.delete();
            exclusive_read_pending.delete();
        end else begin
            // Track exclusive writes
            if(slave_if.awvalid && slave_if.awready && slave_if.awlock) begin
                exclusive_write_pending[slave_if.awid] = 1;
            end
            
            // Track exclusive reads
            if(slave_if.arvalid && slave_if.arready && slave_if.arlock) begin
                exclusive_read_pending[slave_if.arid] = 1;
            end
            
            // Check exclusive write responses
            if(slave_if.bvalid && slave_if.bready) begin
                if(exclusive_write_pending.exists(slave_if.bid) && 
                   exclusive_write_pending[slave_if.bid]) begin
                    if(slave_if.bresp != 2'b01 && slave_if.bresp != 2'b00) begin
                        $error("Invalid response for exclusive write: %0b", slave_if.bresp);
                    end
                    exclusive_write_pending.delete(slave_if.bid);
                end
            end
        end
    end
    
    //==========================================================================
    // Coverage
    //==========================================================================
    
    covergroup slave_coverage @(posedge aclk);
        option.per_instance = 1;
        
        // Write response types
        b_resp_cp: coverpoint slave_if.bresp iff (slave_if.bvalid && slave_if.bready) {
            bins okay = {2'b00};
            bins exokay = {2'b01};
            bins slverr = {2'b10};
            bins decerr = {2'b11};
        }
        
        // Read response types
        r_resp_cp: coverpoint slave_if.rresp iff (slave_if.rvalid && slave_if.rready) {
            bins okay = {2'b00};
            bins exokay = {2'b01};
            bins slverr = {2'b10};
            bins decerr = {2'b11};
        }
        
        // Ready delays (sample when valid but not ready)
        aw_ready_delay_cp: coverpoint slave_if.awvalid && !slave_if.awready {
            bins no_delay = {0};
            bins delayed = {1};
        }
        
        w_ready_delay_cp: coverpoint slave_if.wvalid && !slave_if.wready {
            bins no_delay = {0};
            bins delayed = {1};
        }
        
        ar_ready_delay_cp: coverpoint slave_if.arvalid && !slave_if.arready {
            bins no_delay = {0};
            bins delayed = {1};
        }
        
        // Outstanding transactions (approximation)
        outstanding_writes_cp: coverpoint outstanding_aw_ids.size() {
            bins none = {0};
            bins few = {[1:3]};
            bins medium = {[4:7]};
            bins many = {[8:15]};
            bins max = {[16:$]};
        }
        
        outstanding_reads_cp: coverpoint outstanding_ar_ids.size() {
            bins none = {0};
            bins few = {[1:3]};
            bins medium = {[4:7]};
            bins many = {[8:15]};
            bins max = {[16:$]};
        }
    endgroup
    
    slave_coverage slave_cov = new();
    
endmodule

`endif // AXI4_SLAVE_ASSERTIONS_SV
"""
        
        filepath = os.path.join(output_dir, "slave_assertions.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_tb_master_assertions(self, output_dir):
        """Generate testbench master assertions"""
        content = f"""//==============================================================================
// AXI4 Testbench Master Assertions
// Generated by Assertion Generator
// Date: {self.timestamp}
// System-level assertions for master behavior
//==============================================================================

`ifndef TB_MASTER_ASSERTIONS_SV
`define TB_MASTER_ASSERTIONS_SV

module tb_master_assertions #(
    parameter NUM_MASTERS = {len(self.config.masters)},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter ID_WIDTH = {self.config.id_width}
)(
    input wire aclk,
    input wire aresetn,
    
    // Master interfaces
    axi4_if.monitor master_if[NUM_MASTERS]
);

    //==========================================================================
    // Inter-Master Assertions
    //==========================================================================
    
    // Check for unique IDs across masters (if required)
    property p_unique_master_ids(int m1, int m2);
        @(posedge aclk) disable iff(!aresetn)
        (master_if[m1].awvalid && master_if[m2].awvalid && m1 != m2) |->
        (master_if[m1].awid != master_if[m2].awid);
    endproperty
    
    generate
        for(genvar i = 0; i < NUM_MASTERS; i++) begin : master_i
            for(genvar j = i+1; j < NUM_MASTERS; j++) begin : master_j
                // Optional: Enable only if system requires unique IDs
                // unique_ids: assert property(p_unique_master_ids(i, j))
                //     else $warning("Masters %0d and %0d using same AWID", i, j);
            end
        end
    endgenerate
    
    //==========================================================================
    // System-Level Throughput Monitoring
    //==========================================================================
    
    // Count transactions per master
    int write_count[NUM_MASTERS];
    int read_count[NUM_MASTERS];
    real write_bandwidth[NUM_MASTERS];
    real read_bandwidth[NUM_MASTERS];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            for(int m = 0; m < NUM_MASTERS; m++) begin
                write_count[m] <= 0;
                read_count[m] <= 0;
            end
        end else begin
            for(int m = 0; m < NUM_MASTERS; m++) begin
                // Count write transactions
                if(master_if[m].awvalid && master_if[m].awready) begin
                    write_count[m] <= write_count[m] + 1;
                end
                
                // Count read transactions
                if(master_if[m].arvalid && master_if[m].arready) begin
                    read_count[m] <= read_count[m] + 1;
                end
            end
        end
    end
    
    // Calculate bandwidth periodically
    real time_window = 1000000; // 1ms in ps
    real last_time = 0;
    
    always @(posedge aclk) begin
        if($time - last_time >= time_window) begin
            for(int m = 0; m < NUM_MASTERS; m++) begin
                write_bandwidth[m] = real'(write_count[m]) * 1e12 / time_window;
                read_bandwidth[m] = real'(read_count[m]) * 1e12 / time_window;
                
                `uvm_info($sformatf("MASTER_%0d_BW", m), 
                         $sformatf("Write: %0.2f trans/sec, Read: %0.2f trans/sec", 
                         write_bandwidth[m], read_bandwidth[m]), UVM_MEDIUM)
                
                write_count[m] = 0;
                read_count[m] = 0;
            end
            last_time = $time;
        end
    end
    
    //==========================================================================
    // Protocol Violation Detection Across Masters
    //==========================================================================
    
    // Check for system-wide protocol violations
    int total_4kb_violations = 0;
    int total_exclusive_violations = 0;
    
    always_ff @(posedge aclk) begin
        for(int m = 0; m < NUM_MASTERS; m++) begin
            // Check 4KB boundary
            if(master_if[m].awvalid && master_if[m].awready) begin
                automatic logic [ADDR_WIDTH-1:0] end_addr;
                end_addr = master_if[m].awaddr + 
                          ((master_if[m].awlen + 1) << master_if[m].awsize) - 1;
                
                if(master_if[m].awaddr[11:0] > end_addr[11:0]) begin
                    total_4kb_violations++;
                    `uvm_warning($sformatf("MASTER_%0d_4KB", m),
                               $sformatf("4KB boundary crossed at 0x%0h", master_if[m].awaddr))
                end
            end
            
            // Check exclusive access size
            if(master_if[m].awvalid && master_if[m].awready && master_if[m].awlock) begin
                automatic int exc_size;
                exc_size = (1 << master_if[m].awsize) * (master_if[m].awlen + 1);
                
                if(exc_size > 128) begin
                    total_exclusive_violations++;
                    `uvm_error($sformatf("MASTER_%0d_EXCL", m),
                             $sformatf("Exclusive size %0d exceeds 128 bytes", exc_size))
                end
            end
        end
    end
    
    //==========================================================================
    // System Coverage
    //==========================================================================
    
    covergroup system_coverage @(posedge aclk);
        option.per_instance = 1;
        
        // Concurrent access patterns
        concurrent_writes: coverpoint $countones({master_if[m].awvalid for (m = 0; m < NUM_MASTERS; m++)}) {
            bins none = {0};
            bins single = {1};
            bins dual = {2};
            bins multiple = {[3:NUM_MASTERS-1]};
            bins all = {NUM_MASTERS};
        }
        
        concurrent_reads: coverpoint $countones({master_if[m].arvalid for (m = 0; m < NUM_MASTERS; m++)}) {
            bins none = {0};
            bins single = {1};
            bins dual = {2};
            bins multiple = {[3:NUM_MASTERS-1]};
            bins all = {NUM_MASTERS};
        }
        
        // Mixed read/write
        mixed_access: coverpoint {$countones({master_if[m].awvalid for (m = 0; m < NUM_MASTERS; m})}),
                                 $countones({master_if[m].arvalid for (m = 0; m < NUM_MASTERS; m})})} {
            bins idle = {0, 0};
            bins write_only = {[1:NUM_MASTERS], 0};
            bins read_only = {0, [1:NUM_MASTERS]};
            bins mixed = {[1:NUM_MASTERS], [1:NUM_MASTERS]};
        }
    endgroup
    
    system_coverage sys_cov = new();
    
endmodule

`endif // TB_MASTER_ASSERTIONS_SV
"""
        
        filepath = os.path.join(output_dir, "tb_master_assertions.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_tb_slave_assertions(self, output_dir):
        """Generate testbench slave assertions"""
        content = f"""//==============================================================================
// AXI4 Testbench Slave Assertions
// Generated by Assertion Generator
// Date: {self.timestamp}
// System-level assertions for slave behavior
//==============================================================================

`ifndef TB_SLAVE_ASSERTIONS_SV
`define TB_SLAVE_ASSERTIONS_SV

module tb_slave_assertions #(
    parameter NUM_SLAVES = {len(self.config.slaves)},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter ID_WIDTH = {self.config.id_width}
)(
    input wire aclk,
    input wire aresetn,
    
    // Slave interfaces
    axi4_if.monitor slave_if[NUM_SLAVES]
);

    //==========================================================================
    // Slave Response Time Monitoring
    //==========================================================================
    
    // Track response latencies
    typedef struct {
        logic [ID_WIDTH-1:0] id;
        realtime start_time;
        realtime end_time;
        real latency;
    } latency_info_t;
    
    latency_info_t write_latencies[NUM_SLAVES][$];
    latency_info_t read_latencies[NUM_SLAVES][$];
    
    // Average latency calculation
    real avg_write_latency[NUM_SLAVES];
    real avg_read_latency[NUM_SLAVES];
    real max_write_latency[NUM_SLAVES];
    real max_read_latency[NUM_SLAVES];
    
    // Track outstanding transactions
    realtime aw_start_time[NUM_SLAVES][logic [ID_WIDTH-1:0]];
    realtime ar_start_time[NUM_SLAVES][logic [ID_WIDTH-1:0]];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            for(int s = 0; s < NUM_SLAVES; s++) begin
                write_latencies[s].delete();
                read_latencies[s].delete();
                aw_start_time[s].delete();
                ar_start_time[s].delete();
            end
        end else begin
            for(int s = 0; s < NUM_SLAVES; s++) begin
                // Capture write start times
                if(slave_if[s].awvalid && slave_if[s].awready) begin
                    aw_start_time[s][slave_if[s].awid] = $realtime;
                end
                
                // Capture read start times
                if(slave_if[s].arvalid && slave_if[s].arready) begin
                    ar_start_time[s][slave_if[s].arid] = $realtime;
                end
                
                // Calculate write latencies
                if(slave_if[s].bvalid && slave_if[s].bready) begin
                    if(aw_start_time[s].exists(slave_if[s].bid)) begin
                        latency_info_t info;
                        info.id = slave_if[s].bid;
                        info.start_time = aw_start_time[s][slave_if[s].bid];
                        info.end_time = $realtime;
                        info.latency = (info.end_time - info.start_time) / 1ns;
                        
                        write_latencies[s].push_back(info);
                        aw_start_time[s].delete(slave_if[s].bid);
                        
                        // Update max latency
                        if(info.latency > max_write_latency[s]) begin
                            max_write_latency[s] = info.latency;
                        end
                    end
                end
                
                // Calculate read latencies (on first data beat)
                if(slave_if[s].rvalid && slave_if[s].rready && 
                   ar_start_time[s].exists(slave_if[s].rid)) begin
                    latency_info_t info;
                    info.id = slave_if[s].rid;
                    info.start_time = ar_start_time[s][slave_if[s].rid];
                    info.end_time = $realtime;
                    info.latency = (info.end_time - info.start_time) / 1ns;
                    
                    read_latencies[s].push_back(info);
                    
                    if(slave_if[s].rlast) begin
                        ar_start_time[s].delete(slave_if[s].rid);
                    end
                    
                    // Update max latency
                    if(info.latency > max_read_latency[s]) begin
                        max_read_latency[s] = info.latency;
                    end
                end
            end
        end
    end
    
    // Periodic latency reporting
    always @(posedge aclk) begin
        static real report_time = 0;
        if($realtime - report_time >= 10000000) begin // Report every 10us
            for(int s = 0; s < NUM_SLAVES; s++) begin
                // Calculate averages
                if(write_latencies[s].size() > 0) begin
                    real total = 0;
                    foreach(write_latencies[s][i]) total += write_latencies[s][i].latency;
                    avg_write_latency[s] = total / write_latencies[s].size();
                    
                    `uvm_info($sformatf("SLAVE_%0d_LATENCY", s),
                             $sformatf("Write: avg=%0.2fns max=%0.2fns (n=%0d)",
                             avg_write_latency[s], max_write_latency[s], 
                             write_latencies[s].size()), UVM_MEDIUM)
                end
                
                if(read_latencies[s].size() > 0) begin
                    real total = 0;
                    foreach(read_latencies[s][i]) total += read_latencies[s][i].latency;
                    avg_read_latency[s] = total / read_latencies[s].size();
                    
                    `uvm_info($sformatf("SLAVE_%0d_LATENCY", s),
                             $sformatf("Read: avg=%0.2fns max=%0.2fns (n=%0d)",
                             avg_read_latency[s], max_read_latency[s],
                             read_latencies[s].size()), UVM_MEDIUM)
                end
                
                // Clear for next period
                write_latencies[s].delete();
                read_latencies[s].delete();
            end
            report_time = $realtime;
        end
    end
    
    //==========================================================================
    // Error Response Tracking
    //==========================================================================
    
    int slverr_count[NUM_SLAVES];
    int decerr_count[NUM_SLAVES];
    int exokay_count[NUM_SLAVES];
    
    always_ff @(posedge aclk) begin
        if(!aresetn) begin
            for(int s = 0; s < NUM_SLAVES; s++) begin
                slverr_count[s] <= 0;
                decerr_count[s] <= 0;
                exokay_count[s] <= 0;
            end
        end else begin
            for(int s = 0; s < NUM_SLAVES; s++) begin
                // Count write responses
                if(slave_if[s].bvalid && slave_if[s].bready) begin
                    case(slave_if[s].bresp)
                        2'b01: exokay_count[s]++;
                        2'b10: slverr_count[s]++;
                        2'b11: decerr_count[s]++;
                    endcase
                end
                
                // Count read responses
                if(slave_if[s].rvalid && slave_if[s].rready) begin
                    case(slave_if[s].rresp)
                        2'b01: exokay_count[s]++;
                        2'b10: slverr_count[s]++;
                        2'b11: decerr_count[s]++;
                    endcase
                end
            end
        end
    end
    
    //==========================================================================
    // Slave Access Pattern Coverage
    //==========================================================================
    
    covergroup slave_access_coverage;
        option.per_instance = 1;
        
        // Which slaves are being accessed
        slave_write_access: coverpoint slave_if[0].awvalid {
            bins slaves[] = {[0:NUM_SLAVES-1]};
        }
        
        slave_read_access: coverpoint slave_if[0].arvalid {
            bins slaves[] = {[0:NUM_SLAVES-1]};
        }
        
        // Concurrent slave accesses
        concurrent_slave_writes: coverpoint 
            $countones({slave_if[s].awvalid for (int s = 0; s < NUM_SLAVES; s++)}) {
            bins none = {0};
            bins single = {1};
            bins multiple = {[2:NUM_SLAVES]};
        }
        
        concurrent_slave_reads: coverpoint 
            $countones({slave_if[s].arvalid for (int s = 0; s < NUM_SLAVES; s++)}) {
            bins none = {0};
            bins single = {1};
            bins multiple = {[2:NUM_SLAVES]};
        }
        
        // Response types per slave
        write_resp_types: coverpoint slave_if[0].bresp 
            iff (slave_if[0].bvalid && slave_if[0].bready) {
            bins okay = {2'b00};
            bins exokay = {2'b01};
            bins slverr = {2'b10};
            bins decerr = {2'b11};
        }
        
        read_resp_types: coverpoint slave_if[0].rresp 
            iff (slave_if[0].rvalid && slave_if[0].rready) {
            bins okay = {2'b00};
            bins exokay = {2'b01};
            bins slverr = {2'b10};
            bins decerr = {2'b11};
        }
    endgroup
    
    slave_access_coverage slave_cov = new();
    
    //==========================================================================
    // Performance Assertions
    //==========================================================================
    
    // Maximum response time assertions
    parameter MAX_WRITE_LATENCY = 1000; // ns
    parameter MAX_READ_LATENCY = 1000; // ns
    
    property p_max_write_latency(int s);
        @(posedge aclk) disable iff(!aresetn)
        (slave_if[s].bvalid && slave_if[s].bready) |-> 
        (max_write_latency[s] <= MAX_WRITE_LATENCY);
    endproperty
    
    property p_max_read_latency(int s);
        @(posedge aclk) disable iff(!aresetn)
        (slave_if[s].rvalid && slave_if[s].rready) |-> 
        (max_read_latency[s] <= MAX_READ_LATENCY);
    endproperty
    
    generate
        for(genvar s = 0; s < NUM_SLAVES; s++) begin : slave_perf
            // Optional: Enable based on performance requirements
            // max_wr_latency: assert property(p_max_write_latency(s))
            //     else $error("Slave %0d write latency %0.2fns exceeds max %0dns",
            //                s, max_write_latency[s], MAX_WRITE_LATENCY);
            
            // max_rd_latency: assert property(p_max_read_latency(s))
            //     else $error("Slave %0d read latency %0.2fns exceeds max %0dns",
            //                s, max_read_latency[s], MAX_READ_LATENCY);
        end
    endgenerate
    
endmodule

`endif // TB_SLAVE_ASSERTIONS_SV
"""
        
        filepath = os.path.join(output_dir, "tb_slave_assertions.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_protocol_assertions_pkg(self, output_dir):
        """Generate protocol assertions package"""
        content = f"""//==============================================================================
// AXI4 Protocol Assertions Package
// Generated by Assertion Generator
// Date: {self.timestamp}
// Comprehensive protocol checking library
//==============================================================================

`ifndef AXI4_PROTOCOL_ASSERTIONS_PKG_SV
`define AXI4_PROTOCOL_ASSERTIONS_PKG_SV

package axi4_protocol_assertions_pkg;
    
    // Protocol constants
    parameter AXI4_MAX_BURST_LEN = 256;
    parameter AXI3_MAX_BURST_LEN = 16;
    parameter MAX_EXCLUSIVE_BYTES = 128;
    parameter ADDR_4KB_BOUNDARY = 12;
    
    // Response types
    typedef enum logic [1:0] {
        OKAY   = 2'b00,
        EXOKAY = 2'b01,
        SLVERR = 2'b10,
        DECERR = 2'b11
    } axi_resp_e;
    
    // Burst types
    typedef enum logic [1:0] {
        FIXED = 2'b00,
        INCR  = 2'b01,
        WRAP  = 2'b10,
        RSVD  = 2'b11
    } axi_burst_e;
    
    // Protection encoding
    typedef struct packed {
        logic privileged;   // 0: privileged, 1: unprivileged
        logic nonsecure;    // 0: secure, 1: non-secure
        logic instruction;  // 0: data, 1: instruction
    } axi_prot_t;
    
    // Cache encoding
    typedef struct packed {
        logic allocate_read;
        logic allocate_write;
        logic other_allocate;
        logic modifiable;
    } axi_cache_t;
    
    // Assertion severity levels
    typedef enum {
        SEV_ERROR,
        SEV_WARNING,
        SEV_INFO
    } severity_e;
    
    // Protocol check functions
    function automatic bit is_valid_burst_type(logic [1:0] burst);
        return (burst != RSVD);
    endfunction
    
    function automatic bit is_valid_wrap_len(logic [7:0] len);
        return (len == 1 || len == 3 || len == 7 || len == 15);
    endfunction
    
    function automatic bit is_valid_exclusive_size(int size_bytes);
        return (size_bytes <= MAX_EXCLUSIVE_BYTES) && 
               ((size_bytes & (size_bytes - 1)) == 0); // Power of 2
    endfunction
    
    function automatic bit crosses_4kb_boundary(
        logic [63:0] addr,
        logic [7:0] len,
        logic [2:0] size
    );
        logic [63:0] start_addr = addr;
        logic [63:0] end_addr = addr + ((len + 1) << size) - 1;
        return (start_addr[11:0] > end_addr[11:0]);
    endfunction
    
    // Assertion macros
    `define AXI_ASSERT_ERROR(name, prop, msg) \\
        name: assert property(prop) \\
        else $error({$sformatf("[%s] ", `"name`"), msg})
    
    `define AXI_ASSERT_WARNING(name, prop, msg) \\
        name: assert property(prop) \\
        else $warning({$sformatf("[%s] ", `"name`"), msg})
    
    `define AXI_ASSERT_INFO(name, prop, msg) \\
        name: assert property(prop) \\
        else $info({$sformatf("[%s] ", `"name`"), msg})
    
    // Coverage macros
    `define AXI_COVER(name, prop, msg) \\
        name: cover property(prop) \\
        $display({$sformatf("[COVER:%s] ", `"name`"), msg})
    
    // Protocol violation tracking
    class protocol_violation_tracker;
        int handshake_violations = 0;
        int stability_violations = 0;
        int burst_violations = 0;
        int boundary_violations = 0;
        int exclusive_violations = 0;
        int response_violations = 0;
        
        function void report();
            $display("=== AXI Protocol Violation Summary ===");
            $display("Handshake violations: %0d", handshake_violations);
            $display("Stability violations: %0d", stability_violations);
            $display("Burst violations: %0d", burst_violations);
            $display("4KB boundary violations: %0d", boundary_violations);
            $display("Exclusive access violations: %0d", exclusive_violations);
            $display("Response violations: %0d", response_violations);
            $display("Total violations: %0d", get_total());
        endfunction
        
        function int get_total();
            return handshake_violations + stability_violations + 
                   burst_violations + boundary_violations + 
                   exclusive_violations + response_violations;
        endfunction
    endclass
    
    // Utility class for assertion configuration
    class assertion_config;
        bit enable_4kb_checks = 1;
        bit enable_exclusive_checks = 1;
        bit enable_stability_checks = 1;
        bit enable_ordering_checks = 1;
        bit enable_performance_checks = 0;
        
        severity_e boundary_severity = SEV_WARNING;
        severity_e stability_severity = SEV_ERROR;
        severity_e protocol_severity = SEV_ERROR;
        
        int max_outstanding_per_id = 16;
        int max_write_latency_ns = 1000;
        int max_read_latency_ns = 1000;
    endclass
    
endpackage

`endif // AXI4_PROTOCOL_ASSERTIONS_PKG_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_protocol_assertions_pkg.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def get_assertion_info(self) -> Dict:
        """Return assertion component information"""
        return {
            "components": [
                "Master Assertions",
                "Slave Assertions",
                "Testbench Master Assertions",
                "Testbench Slave Assertions",
                "Protocol Assertions Package"
            ],
            "checks": [
                "Channel handshake protocol",
                "Signal stability requirements",
                "Valid burst types and lengths",
                "4KB boundary crossing detection",
                "Exclusive access constraints",
                "Write strobe validity",
                "WLAST/RLAST timing",
                "ID matching and ordering",
                "Response type validity",
                "Maximum latency monitoring"
            ],
            "coverage": [
                "Burst type coverage",
                "Transfer size coverage",
                "Response type coverage",
                "QoS level coverage",
                "Protection type coverage",
                "Concurrent access patterns",
                "Outstanding transaction levels",
                "System throughput metrics"
            ],
            "features": [
                "Configurable severity levels",
                "Performance monitoring",
                "Protocol violation tracking",
                "System-level assertions",
                "Latency analysis",
                "Error response tracking"
            ]
        }