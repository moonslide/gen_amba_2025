#!/usr/bin/env python3
"""
VIP Virtual Sequencer and Virtual Sequences Generator
Implements virtual sequencer and sequences based on tim_axi4_vip
Step 6 of VIP Enhancement
"""

import os
from datetime import datetime
from typing import Dict, List, Optional

class VIPVirtualSequencerGenerator:
    """Generate virtual sequencer and virtual sequences"""
    
    def __init__(self, config):
        self.config = config
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        self.num_masters = len(config.masters)
        self.num_slaves = len(config.slaves)
        
        # Virtual sequence categories
        self.virtual_sequences = {
            "basic": [
                "base_seq", "bk_write_read_seq", "nbk_write_read_seq"
            ],
            "concurrent": [
                "tc_001_concurrent_reads",
                "tc_002_concurrent_writes_raw", 
                "tc_003_sequential_mixed_ops",
                "tc_004_concurrent_error_stress",
                "tc_005_exhaustive_random_reads"
            ],
            "master_coordination": [
                "all_master_slave_access",
                "4k_boundary_cross",
                "illegal_wstrb"
            ],
            "burst_patterns": [
                "bk_fixed_burst_write_read",
                "bk_incr_burst_write_read",
                "bk_wrap_burst_write_read"
            ],
            "response_patterns": [
                "bk_okay_response_write_read",
                "bk_exokay_response_write_read",
                "bk_slave_error_write_read"
            ],
            "channel_coordination": [
                "aw_ready_delay", "ar_ready_delay",
                "b_ready_delay", "r_ready_delay",
                "aw_w_channel_separation"
            ],
            "advanced": [
                "qos_write_read", "exclusive_access",
                "out_of_order_responses", "interleaved_transactions"
            ],
            "stress": [
                "enhanced_bus_matrix",
                "max_outstanding", "random_stress",
                "corner_case_coverage"
            ]
        }
        
    def generate_virtual_components(self, output_dir):
        """Generate all virtual sequencer components"""
        # Create directories
        vseqr_dir = os.path.join(output_dir, "virtual_seqr")
        vseq_dir = os.path.join(output_dir, "virtual_seq")
        os.makedirs(vseqr_dir, exist_ok=True)
        os.makedirs(vseq_dir, exist_ok=True)
        
        # Generate virtual sequencer
        self._generate_virtual_sequencer(vseqr_dir)
        
        # Generate virtual sequence package
        self._generate_virtual_seq_package(output_dir)
        
        # Generate base virtual sequence
        self._generate_base_virtual_sequence(vseq_dir)
        
        # Generate all virtual sequences
        self._generate_concurrent_sequences(vseq_dir)
        self._generate_coordination_sequences(vseq_dir)
        self._generate_pattern_sequences(vseq_dir)
        self._generate_test_case_sequences(vseq_dir)
        self._generate_stress_sequences(vseq_dir)
        
        return vseqr_dir, vseq_dir
    
    def _generate_virtual_sequencer(self, output_dir):
        """Generate virtual sequencer"""
        content = f"""//==============================================================================
// AXI4 Virtual Sequencer
// Generated by Virtual Sequencer Generator
// Date: {self.timestamp}
// Coordinates sequences across {self.num_masters} masters and {self.num_slaves} slaves
//==============================================================================

`ifndef AXI4_VIRTUAL_SEQUENCER_SV
`define AXI4_VIRTUAL_SEQUENCER_SV

class axi4_virtual_sequencer extends uvm_sequencer;
    `uvm_component_utils(axi4_virtual_sequencer)
    
    // Master sequencers
    axi4_master_write_sequencer master_wr_seqr[{self.num_masters}];
    axi4_master_read_sequencer master_rd_seqr[{self.num_masters}];
    
    // Slave sequencers
    axi4_slave_write_sequencer slave_wr_seqr[{self.num_slaves}];
    axi4_slave_read_sequencer slave_rd_seqr[{self.num_slaves}];
    
    // Configuration
    axi4_env_config env_cfg;
    
    // Synchronization events
    uvm_event master_sync[{self.num_masters}];
    uvm_event slave_sync[{self.num_slaves}];
    uvm_event global_sync;
    
    // Constructor
    function new(string name = "axi4_virtual_sequencer", uvm_component parent = null);
        super.new(name, parent);
        
        // Create synchronization events
        for(int i = 0; i < {self.num_masters}; i++) begin
            master_sync[i] = new($sformatf("master_sync[%0d]", i));
        end
        
        for(int i = 0; i < {self.num_slaves}; i++) begin
            slave_sync[i] = new($sformatf("slave_sync[%0d]", i));
        end
        
        global_sync = new("global_sync");
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        if(!uvm_config_db#(axi4_env_config)::get(this, "", "env_cfg", env_cfg))
            `uvm_fatal("NOCFG", "No environment configuration found")
    endfunction
    
    // Connect phase - connections made by environment
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // Verify all sequencers are connected
        for(int i = 0; i < {self.num_masters}; i++) begin
            if(master_wr_seqr[i] == null || master_rd_seqr[i] == null)
                `uvm_error("VSEQR", $sformatf("Master %0d sequencers not connected", i))
        end
        
        for(int i = 0; i < {self.num_slaves}; i++) begin
            if(slave_wr_seqr[i] == null || slave_rd_seqr[i] == null)
                `uvm_error("VSEQR", $sformatf("Slave %0d sequencers not connected", i))
        end
    endfunction
    
    // Utility functions for virtual sequences
    function axi4_master_write_sequencer get_master_write_seqr(int idx);
        if(idx < {self.num_masters})
            return master_wr_seqr[idx];
        else begin
            `uvm_error("VSEQR", $sformatf("Invalid master index %0d", idx))
            return null;
        end
    endfunction
    
    function axi4_master_read_sequencer get_master_read_seqr(int idx);
        if(idx < {self.num_masters})
            return master_rd_seqr[idx];
        else begin
            `uvm_error("VSEQR", $sformatf("Invalid master index %0d", idx))
            return null;
        end
    endfunction
    
    function axi4_slave_write_sequencer get_slave_write_seqr(int idx);
        if(idx < {self.num_slaves})
            return slave_wr_seqr[idx];
        else begin
            `uvm_error("VSEQR", $sformatf("Invalid slave index %0d", idx))
            return null;
        end
    endfunction
    
    function axi4_slave_read_sequencer get_slave_read_seqr(int idx);
        if(idx < {self.num_slaves})
            return slave_rd_seqr[idx];
        else begin
            `uvm_error("VSEQR", $sformatf("Invalid slave index %0d", idx))
            return null;
        end
    endfunction
    
    // Synchronization functions
    task wait_for_master(int idx);
        if(idx < {self.num_masters})
            master_sync[idx].wait_trigger();
    endtask
    
    task trigger_master(int idx);
        if(idx < {self.num_masters})
            master_sync[idx].trigger();
    endtask
    
    task wait_for_slave(int idx);
        if(idx < {self.num_slaves})
            slave_sync[idx].wait_trigger();
    endtask
    
    task trigger_slave(int idx);
        if(idx < {self.num_slaves})
            slave_sync[idx].trigger();
    endtask
    
    task wait_global_sync();
        global_sync.wait_trigger();
    endtask
    
    task trigger_global_sync();
        global_sync.trigger();
    endtask
    
    // Address mapping functions
    function int get_slave_for_address(bit [{self.config.addr_width-1}:0] addr);
        // Map address to slave based on configuration
        for(int i = 0; i < {self.num_slaves}; i++) begin
            if(addr >= env_cfg.slave_cfg[i].base_address &&
               addr < env_cfg.slave_cfg[i].base_address + env_cfg.slave_cfg[i].size) begin
                return i;
            end
        end
        return -1; // No slave found
    endfunction
    
    function bit is_address_valid(bit [{self.config.addr_width-1}:0] addr);
        return (get_slave_for_address(addr) != -1);
    endfunction
    
endclass

`endif // AXI4_VIRTUAL_SEQUENCER_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_sequencer.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_virtual_seq_package(self, output_dir):
        """Generate virtual sequence package"""
        content = f"""//==============================================================================
// AXI4 Virtual Sequences Package
// Generated by Virtual Sequencer Generator
// Date: {self.timestamp}
// Includes all virtual sequences for multi-master/slave coordination
//==============================================================================

`ifndef AXI4_VIRTUAL_SEQ_PKG_SV
`define AXI4_VIRTUAL_SEQ_PKG_SV

package axi4_virtual_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    import axi4_slave_pkg::*;
    import axi4_master_seq_pkg::*;
    import axi4_slave_seq_pkg::*;
    
    // Base virtual sequence
    `include "virtual_seq/axi4_virtual_base_seq.sv"
    
    // Basic coordination sequences
    `include "virtual_seq/axi4_virtual_bk_write_read_seq.sv"
    `include "virtual_seq/axi4_virtual_nbk_write_read_seq.sv"
    
    // Concurrent test sequences (TC-001 to TC-005)
    `include "virtual_seq/axi4_tc_001_concurrent_reads_virtual_seq.sv"
    `include "virtual_seq/axi4_tc_002_concurrent_writes_raw_virtual_seq.sv"
    `include "virtual_seq/axi4_tc_003_sequential_mixed_ops_virtual_seq.sv"
    `include "virtual_seq/axi4_tc_004_concurrent_error_stress_virtual_seq.sv"
    `include "virtual_seq/axi4_tc_005_exhaustive_random_reads_virtual_seq.sv"
    
    // Master coordination sequences
    `include "virtual_seq/axi4_virtual_all_master_slave_access_seq.sv"
    `include "virtual_seq/axi4_virtual_4k_boundary_cross_seq.sv"
    `include "virtual_seq/axi4_virtual_illegal_wstrb_seq.sv"
    
    // Burst pattern sequences
    `include "virtual_seq/axi4_virtual_bk_fixed_burst_write_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_incr_burst_write_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_wrap_burst_write_read_seq.sv"
    
    // Response pattern sequences
    `include "virtual_seq/axi4_virtual_bk_okay_response_write_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_exokay_response_write_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_slave_error_write_read_seq.sv"
    
    // Channel coordination sequences
    `include "virtual_seq/axi4_virtual_aw_ready_delay_seq.sv"
    `include "virtual_seq/axi4_virtual_ar_ready_delay_seq.sv"
    `include "virtual_seq/axi4_virtual_b_ready_delay_seq.sv"
    `include "virtual_seq/axi4_virtual_r_ready_delay_seq.sv"
    `include "virtual_seq/axi4_virtual_aw_w_channel_separation_seq.sv"
    
    // Advanced feature sequences
    `include "virtual_seq/axi4_virtual_nbk_qos_write_read_seq.sv"
    `include "virtual_seq/axi4_virtual_nbk_exclusive_access_seq.sv"
    `include "virtual_seq/axi4_virtual_nbk_out_of_order_seq.sv"
    `include "virtual_seq/axi4_virtual_nbk_interleaved_seq.sv"
    
    // Stress test sequences
    `include "virtual_seq/axi4_enhanced_bus_matrix_virtual_seq.sv"
    `include "virtual_seq/axi4_virtual_max_outstanding_seq.sv"
    `include "virtual_seq/axi4_virtual_random_stress_seq.sv"
    `include "virtual_seq/axi4_virtual_corner_case_seq.sv"
    
    // Boundary and size sequences
    `include "virtual_seq/axi4_virtual_lower_boundary_read_seq.sv"
    `include "virtual_seq/axi4_virtual_lower_boundary_write_seq.sv"
    `include "virtual_seq/axi4_virtual_upper_boundary_read_seq.sv"
    `include "virtual_seq/axi4_virtual_upper_boundary_write_seq.sv"
    
    // Transfer size sequences
    `include "virtual_seq/axi4_virtual_bk_8b_data_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_16b_data_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_32b_data_read_seq.sv"
    `include "virtual_seq/axi4_virtual_bk_64b_data_read_seq.sv"
    
    // WSTRB sequences
    `include "virtual_seq/axi4_virtual_wstrb_seq.sv"
    
    // Test case sequences (TC-046 to TC-058)
    `include "virtual_seq/axi4_virtual_tc_046_id_multiple_writes_same_awid_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_047_id_multiple_writes_different_awid_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_048_id_multiple_reads_same_arid_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_049_id_multiple_reads_different_arid_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_050_wid_awid_mismatch_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_051_wlast_too_early_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_052_wlast_too_late_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_053_awlen_out_of_spec_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_054_arlen_out_of_spec_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_055_exclusive_write_success_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_056_exclusive_write_fail_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_057_exclusive_read_success_seq.sv"
    `include "virtual_seq/axi4_virtual_tc_058_exclusive_read_fail_seq.sv"
    
endpackage

`endif // AXI4_VIRTUAL_SEQ_PKG_SV
"""
        
        filepath = os.path.join(output_dir, "virtual_seq", "axi4_virtual_seq_pkg.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_base_virtual_sequence(self, output_dir):
        """Generate base virtual sequence"""
        content = f"""//==============================================================================
// AXI4 Virtual Base Sequence
// Generated by Virtual Sequencer Generator
// Date: {self.timestamp}
// Base class for all virtual sequences
//==============================================================================

`ifndef AXI4_VIRTUAL_BASE_SEQ_SV
`define AXI4_VIRTUAL_BASE_SEQ_SV

class axi4_virtual_base_seq extends uvm_sequence;
    `uvm_object_utils(axi4_virtual_base_seq)
    
    // Virtual sequencer handle
    `uvm_declare_p_sequencer(axi4_virtual_sequencer)
    
    // Configuration
    axi4_env_config env_cfg;
    
    // Common parameters
    rand int num_transactions = 10;
    rand int master_id = 0;
    rand int slave_id = 0;
    rand bit [{self.config.addr_width-1}:0] base_addr = 'h0;
    
    // Sequence handles for reuse
    axi4_master_base_seq master_seq;
    axi4_slave_base_seq slave_seq;
    
    // Constraints
    constraint c_master_id {{
        master_id inside {{[0:{self.num_masters-1}]}};
    }}
    
    constraint c_slave_id {{
        slave_id inside {{[0:{self.num_slaves-1}]}};
    }}
    
    constraint c_num_trans {{
        num_transactions inside {{[1:100]}};
    }}
    
    // Constructor
    function new(string name = "axi4_virtual_base_seq");
        super.new(name);
    endfunction
    
    // Pre-start task
    task pre_start();
        env_cfg = p_sequencer.env_cfg;
    endtask
    
    // Body - override in derived classes
    task body();
        `uvm_info(get_type_name(), "Virtual base sequence body", UVM_HIGH)
    endtask
    
    // Helper tasks
    task start_master_write_seq(
        int master_idx,
        bit [{self.config.addr_width-1}:0] addr,
        int num_trans = 1,
        int burst_len = 1,
        bit [2:0] size = 3'b010,
        bit [1:0] burst = 2'b01
    );
        axi4_master_write_seq wr_seq;
        
        `uvm_create_on(wr_seq, p_sequencer.master_wr_seqr[master_idx])
        wr_seq.base_addr = addr;
        wr_seq.num_transactions = num_trans;
        wr_seq.burst_length = burst_len;
        wr_seq.burst_size = size;
        wr_seq.burst_type = burst;
        `uvm_send(wr_seq)
    endtask
    
    task start_master_read_seq(
        int master_idx,
        bit [{self.config.addr_width-1}:0] addr,
        int num_trans = 1,
        int burst_len = 1,
        bit [2:0] size = 3'b010,
        bit [1:0] burst = 2'b01
    );
        axi4_master_read_seq rd_seq;
        
        `uvm_create_on(rd_seq, p_sequencer.master_rd_seqr[master_idx])
        rd_seq.base_addr = addr;
        rd_seq.num_transactions = num_trans;
        rd_seq.burst_length = burst_len;
        rd_seq.burst_size = size;
        rd_seq.burst_type = burst;
        `uvm_send(rd_seq)
    endtask
    
    task start_slave_response_seq(
        int slave_idx,
        bit [1:0] resp_type = OKAY,
        int min_delay = 0,
        int max_delay = 10
    );
        axi4_slave_base_seq slv_seq;
        
        `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[slave_idx])
        slv_seq.default_resp = resp_type;
        slv_seq.min_delay = min_delay;
        slv_seq.max_delay = max_delay;
        `uvm_send(slv_seq)
        
        `uvm_create_on(slv_seq, p_sequencer.slave_rd_seqr[slave_idx])
        slv_seq.default_resp = resp_type;
        slv_seq.min_delay = min_delay;
        slv_seq.max_delay = max_delay;
        `uvm_send(slv_seq)
    endtask
    
    // Concurrent sequence control
    task start_concurrent_sequences();
        fork
            begin : master_sequences
                // Start sequences on all masters
                for(int i = 0; i < {self.num_masters}; i++) begin
                    automatic int idx = i;
                    fork
                        run_master_sequence(idx);
                    join_none
                end
            end
            
            begin : slave_sequences
                // Start response sequences on all slaves
                for(int i = 0; i < {self.num_slaves}; i++) begin
                    automatic int idx = i;
                    fork
                        run_slave_sequence(idx);
                    join_none
                end
            end
        join
    endtask
    
    // Override these in derived classes
    virtual task run_master_sequence(int master_idx);
        `uvm_info(get_type_name(), 
                 $sformatf("Running master %0d sequence", master_idx), 
                 UVM_MEDIUM)
    endtask
    
    virtual task run_slave_sequence(int slave_idx);
        `uvm_info(get_type_name(), 
                 $sformatf("Running slave %0d sequence", slave_idx), 
                 UVM_MEDIUM)
    endtask
    
    // Address calculation helpers
    function bit [{self.config.addr_width-1}:0] get_slave_base_addr(int slave_idx);
        if(slave_idx < {self.num_slaves})
            return env_cfg.slave_cfg[slave_idx].base_address;
        else
            return 0;
    endfunction
    
    function bit [{self.config.addr_width-1}:0] get_random_slave_addr(int slave_idx);
        bit [{self.config.addr_width-1}:0] base, size, offset;
        
        if(slave_idx < {self.num_slaves}) begin
            base = env_cfg.slave_cfg[slave_idx].base_address;
            size = env_cfg.slave_cfg[slave_idx].size;
            offset = $urandom_range(0, size - 1);
            return base + offset;
        end else begin
            return 0;
        end
    endfunction
    
    // Synchronization helpers
    task sync_all_masters();
        for(int i = 0; i < {self.num_masters}; i++) begin
            p_sequencer.trigger_master(i);
        end
    endtask
    
    task sync_all_slaves();
        for(int i = 0; i < {self.num_slaves}; i++) begin
            p_sequencer.trigger_slave(i);
        end
    endtask
    
endclass

`endif // AXI4_VIRTUAL_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_concurrent_sequences(self, output_dir):
        """Generate concurrent test sequences"""
        
        # TC-001: Concurrent Reads
        content = f"""//==============================================================================
// TC-001: Concurrent Reads Virtual Sequence
// Tests concurrent read operations from multiple masters
//==============================================================================

`ifndef AXI4_TC_001_CONCURRENT_READS_VIRTUAL_SEQ_SV
`define AXI4_TC_001_CONCURRENT_READS_VIRTUAL_SEQ_SV

class axi4_tc_001_concurrent_reads_virtual_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_tc_001_concurrent_reads_virtual_seq)
    
    rand int reads_per_master = 10;
    
    function new(string name = "axi4_tc_001_concurrent_reads_virtual_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "Starting TC-001: Concurrent reads from all masters", 
                 UVM_LOW)
        
        // Configure all slaves to respond
        for(int s = 0; s < {self.num_slaves}; s++) begin
            start_slave_response_seq(s, OKAY, 1, 5);
        end
        
        // Start concurrent reads from all masters
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                fork
                    begin
                        repeat(reads_per_master) begin
                            // Read from different slaves
                            int target_slave = master_idx % {self.num_slaves};
                            bit [{self.config.addr_width-1}:0] addr;
                            
                            addr = get_random_slave_addr(target_slave);
                            
                            start_master_read_seq(
                                .master_idx(master_idx),
                                .addr(addr),
                                .num_trans(1),
                                .burst_len($urandom_range(1, 16)),
                                .size($urandom_range(0, 3))
                            );
                            
                            // Small delay between transactions
                            #($urandom_range(10, 100) * 1ns);
                        end
                    end
                join_none
            end
            
            // Wait for all reads to complete
            #(reads_per_master * 200 * 1ns);
        join
        
        `uvm_info(get_type_name(), "TC-001 completed", UVM_LOW)
    endtask
endclass

`endif // AXI4_TC_001_CONCURRENT_READS_VIRTUAL_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_tc_001_concurrent_reads_virtual_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # TC-002: Concurrent Writes
        content = f"""//==============================================================================
// TC-002: Concurrent Writes RAW Virtual Sequence
// Tests Read-After-Write with concurrent writes
//==============================================================================

`ifndef AXI4_TC_002_CONCURRENT_WRITES_RAW_VIRTUAL_SEQ_SV
`define AXI4_TC_002_CONCURRENT_WRITES_RAW_VIRTUAL_SEQ_SV

class axi4_tc_002_concurrent_writes_raw_virtual_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_tc_002_concurrent_writes_raw_virtual_seq)
    
    rand int writes_per_master = 10;
    
    function new(string name = "axi4_tc_002_concurrent_writes_raw_virtual_seq");
        super.new(name);
    endfunction
    
    task body();
        bit [{self.config.addr_width-1}:0] write_addrs[int][int]; // [master][trans]
        
        `uvm_info(get_type_name(), 
                 "Starting TC-002: Concurrent writes with RAW verification", 
                 UVM_LOW)
        
        // Configure slaves
        for(int s = 0; s < {self.num_slaves}; s++) begin
            start_slave_response_seq(s, OKAY, 1, 5);
        end
        
        // Phase 1: Concurrent writes
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                fork
                    begin
                        for(int t = 0; t < writes_per_master; t++) begin
                            int target_slave = (master_idx + t) % {self.num_slaves};
                            bit [{self.config.addr_width-1}:0] addr;
                            
                            addr = get_slave_base_addr(target_slave) + (t * 'h100);
                            write_addrs[master_idx][t] = addr;
                            
                            start_master_write_seq(
                                .master_idx(master_idx),
                                .addr(addr),
                                .num_trans(1),
                                .burst_len(4),
                                .size(3'b010)
                            );
                            
                            #($urandom_range(10, 50) * 1ns);
                        end
                    end
                join_none
            end
            
            #(writes_per_master * 100 * 1ns);
        join
        
        // Phase 2: Read verification
        `uvm_info(get_type_name(), "Starting read-after-write verification", UVM_MEDIUM)
        
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                fork
                    begin
                        for(int t = 0; t < writes_per_master; t++) begin
                            start_master_read_seq(
                                .master_idx(master_idx),
                                .addr(write_addrs[master_idx][t]),
                                .num_trans(1),
                                .burst_len(4),
                                .size(3'b010)
                            );
                            
                            #($urandom_range(10, 50) * 1ns);
                        end
                    end
                join_none
            end
            
            #(writes_per_master * 100 * 1ns);
        join
        
        `uvm_info(get_type_name(), "TC-002 completed", UVM_LOW)
    endtask
endclass

`endif // AXI4_TC_002_CONCURRENT_WRITES_RAW_VIRTUAL_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_tc_002_concurrent_writes_raw_virtual_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Generate other concurrent sequences
        concurrent_seqs = [
            ("tc_003_sequential_mixed_ops", "Sequential mixed read/write operations"),
            ("tc_004_concurrent_error_stress", "Concurrent error condition stress test"),
            ("tc_005_exhaustive_random_reads", "Exhaustive random read coverage")
        ]
        
        for seq_name, desc in concurrent_seqs:
            self._generate_virtual_sequence_file(output_dir, seq_name, desc)
    
    def _generate_coordination_sequences(self, output_dir):
        """Generate master coordination sequences"""
        
        # All Master-Slave Access
        content = f"""//==============================================================================
// All Master-Slave Access Virtual Sequence
// Tests all possible master-slave combinations
//==============================================================================

`ifndef AXI4_VIRTUAL_ALL_MASTER_SLAVE_ACCESS_SEQ_SV
`define AXI4_VIRTUAL_ALL_MASTER_SLAVE_ACCESS_SEQ_SV

class axi4_virtual_all_master_slave_access_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_virtual_all_master_slave_access_seq)
    
    function new(string name = "axi4_virtual_all_master_slave_access_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "Testing all master-slave combinations", 
                 UVM_LOW)
        
        // Configure all slaves
        for(int s = 0; s < {self.num_slaves}; s++) begin
            start_slave_response_seq(s, OKAY, 0, 5);
        end
        
        // Test each master accessing each slave
        for(int m = 0; m < {self.num_masters}; m++) begin
            for(int s = 0; s < {self.num_slaves}; s++) begin
                bit [{self.config.addr_width-1}:0] addr;
                
                addr = get_random_slave_addr(s);
                
                `uvm_info(get_type_name(), 
                         $sformatf("Master %0d -> Slave %0d", m, s), 
                         UVM_MEDIUM)
                
                // Write then read
                start_master_write_seq(
                    .master_idx(m),
                    .addr(addr),
                    .num_trans(1),
                    .burst_len(8)
                );
                
                #100ns;
                
                start_master_read_seq(
                    .master_idx(m),
                    .addr(addr),
                    .num_trans(1),
                    .burst_len(8)
                );
                
                #100ns;
            end
        end
        
        `uvm_info(get_type_name(), 
                 "All master-slave combinations tested", 
                 UVM_LOW)
    endtask
endclass

`endif // AXI4_VIRTUAL_ALL_MASTER_SLAVE_ACCESS_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_all_master_slave_access_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # 4KB Boundary Cross
        content = f"""//==============================================================================
// 4KB Boundary Cross Virtual Sequence
// Coordinates multiple masters crossing 4KB boundaries
//==============================================================================

`ifndef AXI4_VIRTUAL_4K_BOUNDARY_CROSS_SEQ_SV
`define AXI4_VIRTUAL_4K_BOUNDARY_CROSS_SEQ_SV

class axi4_virtual_4k_boundary_cross_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_virtual_4k_boundary_cross_seq)
    
    function new(string name = "axi4_virtual_4k_boundary_cross_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "Testing 4KB boundary crossing from multiple masters", 
                 UVM_LOW)
        
        // Configure slaves
        for(int s = 0; s < {self.num_slaves}; s++) begin
            start_slave_response_seq(s, OKAY, 0, 5);
        end
        
        // Each master performs 4KB crossing transaction
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                automatic int slave_idx = master_idx % {self.num_slaves};
                
                fork
                    begin
                        bit [{self.config.addr_width-1}:0] addr;
                        
                        // Set address near 4KB boundary
                        addr = get_slave_base_addr(slave_idx) + 'hF80;
                        
                        `uvm_warning(get_type_name(), 
                                   $sformatf("Master %0d intentionally crossing 4KB at 0x%0h", 
                                   master_idx, addr))
                        
                        // Large burst to cross boundary
                        start_master_write_seq(
                            .master_idx(master_idx),
                            .addr(addr),
                            .num_trans(1),
                            .burst_len(32),  // 32 * 8 = 256 bytes
                            .size(3'b011)    // 8 bytes
                        );
                        
                        #200ns;
                        
                        start_master_read_seq(
                            .master_idx(master_idx),
                            .addr(addr),
                            .num_trans(1),
                            .burst_len(32),
                            .size(3'b011)
                        );
                    end
                join_none
            end
            
            #2000ns;
        join
        
        `uvm_info(get_type_name(), "4KB boundary test completed", UVM_LOW)
    endtask
endclass

`endif // AXI4_VIRTUAL_4K_BOUNDARY_CROSS_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_4k_boundary_cross_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_pattern_sequences(self, output_dir):
        """Generate pattern-based virtual sequences"""
        
        # Enhanced Bus Matrix Sequence
        content = f"""//==============================================================================
// Enhanced Bus Matrix Virtual Sequence
// Complex scenario for enhanced bus matrix testing
//==============================================================================

`ifndef AXI4_ENHANCED_BUS_MATRIX_VIRTUAL_SEQ_SV
`define AXI4_ENHANCED_BUS_MATRIX_VIRTUAL_SEQ_SV

class axi4_enhanced_bus_matrix_virtual_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_enhanced_bus_matrix_virtual_seq)
    
    // Master profiles from claude.md
    typedef enum {{
        SECURE_CPU,
        NS_CPU,
        I_FETCH,
        GPU,
        AI_ACCEL,
        DMA_S,
        DMA_NS,
        MALICIOUS,
        RO_PERI,
        LEGACY
    }} master_type_e;
    
    function new(string name = "axi4_enhanced_bus_matrix_virtual_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "Starting enhanced bus matrix test scenario", 
                 UVM_LOW)
        
        // Configure slaves based on their types
        configure_enhanced_slaves();
        
        // Run master-specific test patterns
        fork
            // Secure CPU - access all secure resources
            test_secure_cpu(0);
            
            // Non-secure CPU - normal application access
            test_ns_cpu(1);
            
            // Instruction fetch - XOM region access
            test_ifetch_unit(2);
            
            // GPU - high bandwidth shared buffer access
            test_gpu(3);
            
            // AI Accelerator - QoS testing
            test_ai_accel(4);
            
            // Secure DMA - secure transfers
            test_secure_dma(5);
            
            // Non-secure DMA - normal transfers
            test_ns_dma(6);
            
            // Malicious master - security testing
            test_malicious_master(7);
            
            // Read-only peripheral
            test_ro_peripheral(8);
            
            // Legacy master - compatibility
            test_legacy_master(9);
        join
        
        `uvm_info(get_type_name(), 
                 "Enhanced bus matrix test completed", 
                 UVM_LOW)
    endtask
    
    task configure_enhanced_slaves();
        // S0: DDR Secure Kernel - secure only
        axi4_slave_base_seq slv_seq;
        
        `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[0])
        slv_seq.default_resp = OKAY;
        slv_seq.use_memory_model = 1;
        // Configure security checks
        `uvm_send(slv_seq)
        
        // S1: DDR Non-Secure User - normal access
        `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[1])
        slv_seq.default_resp = OKAY;
        slv_seq.use_memory_model = 1;
        `uvm_send(slv_seq)
        
        // S2: DDR Shared Buffer - high performance
        `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[2])
        slv_seq.default_resp = OKAY;
        slv_seq.min_delay = 0;
        slv_seq.max_delay = 2;
        `uvm_send(slv_seq)
        
        // S3: Illegal Address Hole - always DECERR
        `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[3])
        slv_seq.default_resp = DECERR;
        `uvm_send(slv_seq)
        
        // Configure remaining slaves...
    endtask
    
    task test_secure_cpu(int master_idx);
        // Secure CPU can access all regions
        repeat(10) begin
            int target_slave = $urandom_range(0, {self.num_slaves-1});
            bit [{self.config.addr_width-1}:0] addr;
            
            addr = get_random_slave_addr(target_slave);
            
            // Set secure attributes
            axi4_master_base_seq mst_seq;
            `uvm_create_on(mst_seq, p_sequencer.master_wr_seqr[master_idx])
            mst_seq.prot = 3'b000;  // Secure, privileged, data
            mst_seq.cache = 4'b1111; // Fully cacheable
            mst_seq.base_addr = addr;
            `uvm_send(mst_seq)
            
            #100ns;
        end
    endtask
    
    task test_malicious_master(int master_idx);
        // Malicious master tries illegal accesses
        repeat(20) begin
            int target_slave = $urandom_range(0, {self.num_slaves-1});
            bit [{self.config.addr_width-1}:0] addr;
            
            addr = get_random_slave_addr(target_slave);
            
            // Try to access secure regions as non-secure
            axi4_master_base_seq mst_seq;
            `uvm_create_on(mst_seq, p_sequencer.master_wr_seqr[master_idx])
            mst_seq.prot = 3'b111;  // Non-secure, unprivileged
            mst_seq.base_addr = addr;
            
            // Expect errors for secure slaves
            if(target_slave == 0 || target_slave == 7) begin
                `uvm_info(get_type_name(), 
                         $sformatf("Malicious access to secure slave %0d - expecting error", 
                         target_slave), 
                         UVM_MEDIUM)
            end
            
            `uvm_send(mst_seq)
            
            #50ns;
        end
    endtask
    
    // Implement other master test tasks...
    task test_ns_cpu(int master_idx);
        // Implementation
    endtask
    
    task test_ifetch_unit(int master_idx);
        // Implementation
    endtask
    
    task test_gpu(int master_idx);
        // Implementation
    endtask
    
    task test_ai_accel(int master_idx);
        // Implementation
    endtask
    
    task test_secure_dma(int master_idx);
        // Implementation
    endtask
    
    task test_ns_dma(int master_idx);
        // Implementation
    endtask
    
    task test_ro_peripheral(int master_idx);
        // Implementation
    endtask
    
    task test_legacy_master(int master_idx);
        // Implementation
    endtask
    
endclass

`endif // AXI4_ENHANCED_BUS_MATRIX_VIRTUAL_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_enhanced_bus_matrix_virtual_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_test_case_sequences(self, output_dir):
        """Generate specific test case virtual sequences"""
        
        # Basic write-read sequence
        content = f"""//==============================================================================
// Basic Write-Read Virtual Sequence
// Coordinates write followed by read verification
//==============================================================================

`ifndef AXI4_VIRTUAL_BK_WRITE_READ_SEQ_SV
`define AXI4_VIRTUAL_BK_WRITE_READ_SEQ_SV

class axi4_virtual_bk_write_read_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_virtual_bk_write_read_seq)
    
    function new(string name = "axi4_virtual_bk_write_read_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "Starting blocking write-read sequence", 
                 UVM_LOW)
        
        // Configure target slave
        start_slave_response_seq(slave_id, OKAY, 0, 5);
        
        // Write from master
        start_master_write_seq(
            .master_idx(master_id),
            .addr(base_addr),
            .num_trans(num_transactions),
            .burst_len(8),
            .size(3'b010)
        );
        
        // Wait for writes to complete
        #500ns;
        
        // Read back for verification
        start_master_read_seq(
            .master_idx(master_id),
            .addr(base_addr),
            .num_trans(num_transactions),
            .burst_len(8),
            .size(3'b010)
        );
        
        `uvm_info(get_type_name(), 
                 "Completed write-read sequence", 
                 UVM_LOW)
    endtask
endclass

`endif // AXI4_VIRTUAL_BK_WRITE_READ_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_bk_write_read_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Generate other test case sequences
        test_sequences = [
            ("nbk_write_read", "Non-blocking write-read sequence"),
            ("bk_fixed_burst_write_read", "FIXED burst write-read"),
            ("bk_incr_burst_write_read", "INCR burst write-read"),
            ("bk_wrap_burst_write_read", "WRAP burst write-read"),
            ("bk_okay_response_write_read", "OKAY response verification"),
            ("bk_exokay_response_write", "Exclusive access verification"),
            ("bk_slave_error_write_read", "Error response handling")
        ]
        
        for seq_name, desc in test_sequences:
            self._generate_virtual_sequence_file(output_dir, f"virtual_{seq_name}", desc)
    
    def _generate_stress_sequences(self, output_dir):
        """Generate stress test virtual sequences"""
        
        # Random stress sequence
        content = f"""//==============================================================================
// Random Stress Virtual Sequence
// Stress test with random patterns from all masters
//==============================================================================

`ifndef AXI4_VIRTUAL_RANDOM_STRESS_SEQ_SV
`define AXI4_VIRTUAL_RANDOM_STRESS_SEQ_SV

class axi4_virtual_random_stress_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_virtual_random_stress_seq)
    
    rand int stress_duration_ns = 10000;
    rand int max_burst_len = 64;
    
    function new(string name = "axi4_virtual_random_stress_seq");
        super.new(name);
    endfunction
    
    task body();
        time start_time = $time;
        
        `uvm_info(get_type_name(), 
                 $sformatf("Starting random stress test for %0dns", stress_duration_ns), 
                 UVM_LOW)
        
        // Configure all slaves with random responses
        for(int s = 0; s < {self.num_slaves}; s++) begin
            axi4_slave_base_seq slv_seq;
            
            `uvm_create_on(slv_seq, p_sequencer.slave_wr_seqr[s])
            slv_seq.default_resp = OKAY;
            slv_seq.enable_error_injection = 1;
            slv_seq.error_rate = 0.05;  // 5% error rate
            slv_seq.enable_out_of_order = 1;
            slv_seq.min_delay = 0;
            slv_seq.max_delay = 20;
            `uvm_send(slv_seq)
        end
        
        // Start random traffic from all masters
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                fork
                    begin
                        while(($time - start_time) < stress_duration_ns * 1ns) begin
                            int op_type = $urandom_range(0, 2);
                            int target_slave = $urandom_range(0, {self.num_slaves-1});
                            bit [{self.config.addr_width-1}:0] addr;
                            int burst_len = $urandom_range(1, max_burst_len);
                            bit [2:0] size = $urandom_range(0, 3);
                            bit [1:0] burst_type = $urandom_range(0, 2);
                            
                            addr = get_random_slave_addr(target_slave);
                            
                            case(op_type)
                                0: begin // Write
                                    start_master_write_seq(
                                        .master_idx(master_idx),
                                        .addr(addr),
                                        .num_trans(1),
                                        .burst_len(burst_len),
                                        .size(size),
                                        .burst(burst_type)
                                    );
                                end
                                
                                1: begin // Read
                                    start_master_read_seq(
                                        .master_idx(master_idx),
                                        .addr(addr),
                                        .num_trans(1),
                                        .burst_len(burst_len),
                                        .size(size),
                                        .burst(burst_type)
                                    );
                                end
                                
                                2: begin // Write-Read
                                    start_master_write_seq(
                                        .master_idx(master_idx),
                                        .addr(addr),
                                        .num_trans(1),
                                        .burst_len(burst_len),
                                        .size(size),
                                        .burst(burst_type)
                                    );
                                    
                                    #($urandom_range(10, 100) * 1ns);
                                    
                                    start_master_read_seq(
                                        .master_idx(master_idx),
                                        .addr(addr),
                                        .num_trans(1),
                                        .burst_len(burst_len),
                                        .size(size),
                                        .burst(burst_type)
                                    );
                                end
                            endcase
                            
                            // Random inter-transaction delay
                            #($urandom_range(0, 50) * 1ns);
                        end
                    end
                join_none
            end
        join
        
        `uvm_info(get_type_name(), 
                 "Random stress test completed", 
                 UVM_LOW)
    endtask
endclass

`endif // AXI4_VIRTUAL_RANDOM_STRESS_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_virtual_random_stress_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Generate other stress sequences
        stress_sequences = [
            ("max_outstanding", "Maximum outstanding transactions"),
            ("corner_case_coverage", "Corner case coverage")
        ]
        
        for seq_name, desc in stress_sequences:
            self._generate_virtual_sequence_file(output_dir, f"virtual_{seq_name}", desc)
    
    def _generate_virtual_sequence_file(self, output_dir, seq_name, description):
        """Generate a generic virtual sequence file"""
        
        content = f"""//==============================================================================
// AXI4 {seq_name.replace('_', ' ').title()} Sequence
// {description}
//==============================================================================

`ifndef AXI4_{seq_name.upper()}_SEQ_SV
`define AXI4_{seq_name.upper()}_SEQ_SV

class axi4_{seq_name}_seq extends axi4_virtual_base_seq;
    `uvm_object_utils(axi4_{seq_name}_seq)
    
    function new(string name = "axi4_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), 
                 "{description}", 
                 UVM_LOW)
        
        // Configure slaves
        for(int s = 0; s < {self.num_slaves}; s++) begin
            start_slave_response_seq(s, OKAY, 0, 10);
        end
        
        // Sequence-specific implementation
        fork
            for(int m = 0; m < {self.num_masters}; m++) begin
                automatic int master_idx = m;
                fork
                    begin
                        repeat(num_transactions) begin
                            int target_slave = master_idx % {self.num_slaves};
                            bit [{self.config.addr_width-1}:0] addr;
                            
                            addr = get_random_slave_addr(target_slave);
                            
                            // Perform operation
                            if($urandom_range(0, 1)) begin
                                start_master_write_seq(
                                    .master_idx(master_idx),
                                    .addr(addr),
                                    .num_trans(1)
                                );
                            end else begin
                                start_master_read_seq(
                                    .master_idx(master_idx),
                                    .addr(addr),
                                    .num_trans(1)
                                );
                            end
                            
                            #100ns;
                        end
                    end
                join_none
            end
        join
        
        `uvm_info(get_type_name(), 
                 "Sequence completed", 
                 UVM_LOW)
    endtask
endclass

`endif // AXI4_{seq_name.upper()}_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, f"axi4_{seq_name}_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def get_virtual_sequencer_info(self) -> Dict:
        """Return virtual sequencer information"""
        
        # Count total sequences
        total_sequences = sum(len(seqs) for seqs in self.virtual_sequences.values())
        
        return {
            "components": [
                "Virtual Sequencer",
                f"Support for {self.num_masters} masters",
                f"Support for {self.num_slaves} slaves",
                f"{total_sequences}+ virtual sequences"
            ],
            "features": [
                "Multi-master coordination",
                "Multi-slave response control",
                "Synchronization events",
                "Address mapping functions",
                "Concurrent sequence execution",
                "Master-slave arbitration",
                "Error injection coordination",
                "Performance scenario control"
            ],
            "sequence_categories": {
                "Basic": ["write-read", "concurrent access"],
                "Test Cases": ["TC-001 to TC-005", "TC-046 to TC-058"],
                "Coordination": ["all master-slave", "4KB boundary", "WSTRB"],
                "Patterns": ["burst types", "response types", "channel delays"],
                "Advanced": ["QoS", "exclusive", "out-of-order", "interleaved"],
                "Stress": ["random", "max outstanding", "corner cases"]
            },
            "synchronization": [
                "Per-master sync events",
                "Per-slave sync events",
                "Global sync event",
                "Fork-join control"
            ]
        }