#!/usr/bin/env python3
"""
AXI Verilog RTL Generator
Generates AXI-compliant Verilog following IHI0022D spec
"""

import os
from datetime import datetime
from dataclasses import dataclass
from typing import List

class AXIVerilogGenerator:
    """Generate AXI interconnect RTL"""
    
    def __init__(self, config):
        self.config = config
        self.output_dir = "generated_rtl"
        
    def generate(self):
        """Generate complete AXI interconnect"""
        # Create output directory
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Generate modules
        self.generate_interconnect()
        self.generate_address_decoder()
        self.generate_arbiter()
        self.generate_router()
        self.generate_testbench()
        
        return self.output_dir
        
    def generate_interconnect(self):
        """Generate top-level interconnect module"""
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        filename = f"{self.output_dir}/axi4_interconnect_m{num_masters}s{num_slaves}.v"
        
        with open(filename, 'w') as f:
            f.write(f"""//==============================================================================
// AXI4 Interconnect - {num_masters} Masters x {num_slaves} Slaves
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// Compliant with AMBA AXI4 Protocol Specification (IHI0022D)
//==============================================================================

module axi4_interconnect_m{num_masters}s{num_slaves} #(
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter ID_WIDTH   = 4,
    parameter USER_WIDTH = 1
)(
    input wire                          aclk,
    input wire                          aresetn,
    
""")
            # Master interfaces
            for i, master in enumerate(self.config.masters):
                f.write(f"    // Master {i} - {master.name}\n")
                f.write(self._generate_master_ports(i, master))
                f.write("\n")
                
            # Slave interfaces
            for i, slave in enumerate(self.config.slaves):
                f.write(f"    // Slave {i} - {slave.name}\n")
                f.write(self._generate_slave_ports(i, slave))
                if i < num_slaves - 1:
                    f.write(",\n\n")
                else:
                    f.write("\n")
                    
            f.write(");\n\n")
            
            # Internal signals
            f.write("//------------------------------------------------------------------------------\n")
            f.write("// Internal Signals\n")
            f.write("//------------------------------------------------------------------------------\n\n")
            
            # Address decode signals
            for i in range(num_masters):
                f.write(f"wire [{num_slaves-1}:0] m{i}_slave_select;\n")
                
            f.write("\n")
            
            # Arbiter signals
            for i in range(num_slaves):
                f.write(f"wire [{num_masters-1}:0] s{i}_master_grant;\n")
                
            f.write("\n")
            
            # Instantiate submodules
            f.write("//------------------------------------------------------------------------------\n")
            f.write("// Address Decoder Instances\n")
            f.write("//------------------------------------------------------------------------------\n\n")
            
            for i, master in enumerate(self.config.masters):
                f.write(f"""axi4_address_decoder #(
    .ADDR_WIDTH(ADDR_WIDTH),
    .NUM_SLAVES({num_slaves})
) u_addr_decoder_m{i} (
    .awaddr(m{i}_awaddr),
    .awvalid(m{i}_awvalid),
    .awprot(m{i}_awprot),
    .araddr(m{i}_araddr),
    .arvalid(m{i}_arvalid),
    .arprot(m{i}_arprot),
    .master_id({i}),
    .slave_select(m{i}_slave_select),
    .access_error(m{i}_access_error)
);

""")
            
            f.write("//------------------------------------------------------------------------------\n")
            f.write("// Arbiter Instances\n")
            f.write("//------------------------------------------------------------------------------\n\n")
            
            for i, slave in enumerate(self.config.slaves):
                f.write(f"""axi4_arbiter #(
    .NUM_MASTERS({num_masters}),
    .ARBITRATION("{self.config.arbitration}")
) u_arbiter_s{i} (
    .aclk(aclk),
    .aresetn(aresetn),
""")
                # Connect master requests
                for j in range(num_masters):
                    f.write(f"    .master{j}_request(m{j}_slave_select[{i}]),\n")
                    f.write(f"    .master{j}_priority({self.config.masters[j].priority}),\n")
                    
                f.write(f"    .grant(s{i}_master_grant)\n")
                f.write(");\n\n")
                
            f.write("//------------------------------------------------------------------------------\n")
            f.write("// Crossbar Connections\n")
            f.write("//------------------------------------------------------------------------------\n\n")
            
            f.write("//------------------------------------------------------------------------------\n")
            f.write("// Access Error Response Generator\n")
            f.write("//------------------------------------------------------------------------------\n\n")
            
            # Generate error response logic for each master
            for i in range(num_masters):
                f.write(f"""// Master {i} error response handling
assign m{i}_bresp  = m{i}_access_error ? 2'b11 : 2'b00; // DECERR if access denied
assign m{i}_rresp  = m{i}_access_error ? 2'b11 : 2'b00; // DECERR if access denied
assign m{i}_bvalid = m{i}_access_error ? m{i}_awvalid : 1'b0;
assign m{i}_rvalid = m{i}_access_error ? m{i}_arvalid : 1'b0;
assign m{i}_rdata  = {{DATA_WIDTH{{1'b0}}}}; // Return zeros on error
assign m{i}_rlast  = 1'b1; // Single beat error response

""")
            
            f.write("// TODO: Implement full crossbar switch\n")
            f.write("// This is a simplified interconnect structure\n")
            f.write("// For production use, implement complete routing logic\n\n")
            
            # Simple assignment for now
            for i, slave in enumerate(self.config.slaves):
                f.write(f"// Slave {i} - {slave.name}\n")
                if slave.secure_only:
                    f.write(f"// Security: Secure access only\n")
                if slave.privileged_only:
                    f.write(f"// Security: Privileged access only\n")
                f.write(f"// Address range: 0x{slave.base_address:X} - 0x{slave.base_address + slave.size*1024 - 1:X}\n")
                f.write(f"// Regions: {slave.num_regions}\n\n")
            f.write("endmodule\n")
            
    def _generate_master_ports(self, index, master):
        """Generate master interface ports"""
        prefix = f"m{index}_"
        ports = []
        
        # Write address channel
        ports.append(f"    input  wire [{master.id_width-1}:0]  {prefix}awid,")
        ports.append(f"    input  wire [ADDR_WIDTH-1:0]        {prefix}awaddr,")
        ports.append(f"    input  wire [7:0]                   {prefix}awlen,")
        ports.append(f"    input  wire [2:0]                   {prefix}awsize,")
        ports.append(f"    input  wire [1:0]                   {prefix}awburst,")
        ports.append(f"    input  wire                         {prefix}awlock,")
        ports.append(f"    input  wire [3:0]                   {prefix}awcache,")
        ports.append(f"    input  wire [2:0]                   {prefix}awprot,")
        ports.append(f"    input  wire [3:0]                   {prefix}awqos,")
        ports.append(f"    input  wire [3:0]                   {prefix}awregion,")
        if master.user_width > 0:
            ports.append(f"    input  wire [{master.user_width-1}:0] {prefix}awuser,")
        ports.append(f"    input  wire                         {prefix}awvalid,")
        ports.append(f"    output wire                         {prefix}awready,")
        
        # Write data channel
        ports.append(f"    input  wire [DATA_WIDTH-1:0]        {prefix}wdata,")
        ports.append(f"    input  wire [DATA_WIDTH/8-1:0]      {prefix}wstrb,")
        ports.append(f"    input  wire                         {prefix}wlast,")
        if master.user_width > 0:
            ports.append(f"    input  wire [{master.user_width-1}:0] {prefix}wuser,")
        ports.append(f"    input  wire                         {prefix}wvalid,")
        ports.append(f"    output wire                         {prefix}wready,")
        
        # Write response channel
        ports.append(f"    output wire [{master.id_width-1}:0] {prefix}bid,")
        ports.append(f"    output wire [1:0]                   {prefix}bresp,")
        if master.user_width > 0:
            ports.append(f"    output wire [{master.user_width-1}:0] {prefix}buser,")
        ports.append(f"    output wire                         {prefix}bvalid,")
        ports.append(f"    input  wire                         {prefix}bready,")
        
        # Read address channel
        ports.append(f"    input  wire [{master.id_width-1}:0]  {prefix}arid,")
        ports.append(f"    input  wire [ADDR_WIDTH-1:0]        {prefix}araddr,")
        ports.append(f"    input  wire [7:0]                   {prefix}arlen,")
        ports.append(f"    input  wire [2:0]                   {prefix}arsize,")
        ports.append(f"    input  wire [1:0]                   {prefix}arburst,")
        ports.append(f"    input  wire                         {prefix}arlock,")
        ports.append(f"    input  wire [3:0]                   {prefix}arcache,")
        ports.append(f"    input  wire [2:0]                   {prefix}arprot,")
        ports.append(f"    input  wire [3:0]                   {prefix}arqos,")
        ports.append(f"    input  wire [3:0]                   {prefix}arregion,")
        if master.user_width > 0:
            ports.append(f"    input  wire [{master.user_width-1}:0] {prefix}aruser,")
        ports.append(f"    input  wire                         {prefix}arvalid,")
        ports.append(f"    output wire                         {prefix}arready,")
        
        # Read data channel
        ports.append(f"    output wire [{master.id_width-1}:0] {prefix}rid,")
        ports.append(f"    output wire [DATA_WIDTH-1:0]        {prefix}rdata,")
        ports.append(f"    output wire [1:0]                   {prefix}rresp,")
        ports.append(f"    output wire                         {prefix}rlast,")
        if master.user_width > 0:
            ports.append(f"    output wire [{master.user_width-1}:0] {prefix}ruser,")
        ports.append(f"    output wire                         {prefix}rvalid,")
        ports.append(f"    input  wire                         {prefix}rready,")
        
        return '\n'.join(ports)
        
    def _generate_slave_ports(self, index, slave):
        """Generate slave interface ports"""
        prefix = f"s{index}_"
        ports = []
        
        # Write address channel
        ports.append(f"    output wire [ID_WIDTH-1:0]          {prefix}awid,")
        ports.append(f"    output wire [ADDR_WIDTH-1:0]        {prefix}awaddr,")
        ports.append(f"    output wire [7:0]                   {prefix}awlen,")
        ports.append(f"    output wire [2:0]                   {prefix}awsize,")
        ports.append(f"    output wire [1:0]                   {prefix}awburst,")
        ports.append(f"    output wire                         {prefix}awlock,")
        ports.append(f"    output wire [3:0]                   {prefix}awcache,")
        ports.append(f"    output wire [2:0]                   {prefix}awprot,")
        ports.append(f"    output wire [3:0]                   {prefix}awqos,")
        ports.append(f"    output wire [3:0]                   {prefix}awregion,")
        ports.append(f"    output wire [USER_WIDTH-1:0]        {prefix}awuser,")
        ports.append(f"    output wire                         {prefix}awvalid,")
        ports.append(f"    input  wire                         {prefix}awready,")
        
        # Write data channel
        ports.append(f"    output wire [DATA_WIDTH-1:0]        {prefix}wdata,")
        ports.append(f"    output wire [DATA_WIDTH/8-1:0]      {prefix}wstrb,")
        ports.append(f"    output wire                         {prefix}wlast,")
        ports.append(f"    output wire [USER_WIDTH-1:0]        {prefix}wuser,")
        ports.append(f"    output wire                         {prefix}wvalid,")
        ports.append(f"    input  wire                         {prefix}wready,")
        
        # Write response channel
        ports.append(f"    input  wire [ID_WIDTH-1:0]          {prefix}bid,")
        ports.append(f"    input  wire [1:0]                   {prefix}bresp,")
        ports.append(f"    input  wire [USER_WIDTH-1:0]        {prefix}buser,")
        ports.append(f"    input  wire                         {prefix}bvalid,")
        ports.append(f"    output wire                         {prefix}bready,")
        
        # Read address channel
        ports.append(f"    output wire [ID_WIDTH-1:0]          {prefix}arid,")
        ports.append(f"    output wire [ADDR_WIDTH-1:0]        {prefix}araddr,")
        ports.append(f"    output wire [7:0]                   {prefix}arlen,")
        ports.append(f"    output wire [2:0]                   {prefix}arsize,")
        ports.append(f"    output wire [1:0]                   {prefix}arburst,")
        ports.append(f"    output wire                         {prefix}arlock,")
        ports.append(f"    output wire [3:0]                   {prefix}arcache,")
        ports.append(f"    output wire [2:0]                   {prefix}arprot,")
        ports.append(f"    output wire [3:0]                   {prefix}arqos,")
        ports.append(f"    output wire [3:0]                   {prefix}arregion,")
        ports.append(f"    output wire [USER_WIDTH-1:0]        {prefix}aruser,")
        ports.append(f"    output wire                         {prefix}arvalid,")
        ports.append(f"    input  wire                         {prefix}arready,")
        
        # Read data channel
        ports.append(f"    input  wire [ID_WIDTH-1:0]          {prefix}rid,")
        ports.append(f"    input  wire [DATA_WIDTH-1:0]        {prefix}rdata,")
        ports.append(f"    input  wire [1:0]                   {prefix}rresp,")
        ports.append(f"    input  wire                         {prefix}rlast,")
        ports.append(f"    input  wire [USER_WIDTH-1:0]        {prefix}ruser,")
        ports.append(f"    input  wire                         {prefix}rvalid,")
        ports.append(f"    output wire                         {prefix}rready")
        
        return '\n'.join(ports)
        
    def generate_address_decoder(self):
        """Generate address decoder module with access control"""
        filename = f"{self.output_dir}/axi4_address_decoder.v"
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        with open(filename, 'w') as f:
            f.write(f"""//==============================================================================
// AXI4 Address Decoder with Access Control
// Maps addresses to slave select signals and checks permissions
//==============================================================================

module axi4_address_decoder #(
    parameter ADDR_WIDTH = 32,
    parameter NUM_SLAVES = {num_slaves},
    parameter NUM_MASTERS = {num_masters}
)(
    input  wire [ADDR_WIDTH-1:0] awaddr,
    input  wire                  awvalid,
    input  wire [2:0]            awprot,   // Protection attributes
    input  wire [ADDR_WIDTH-1:0] araddr,
    input  wire                  arvalid,
    input  wire [2:0]            arprot,   // Protection attributes
    input  wire [$clog2(NUM_MASTERS)-1:0] master_id,  // Current master ID
    output reg  [NUM_SLAVES-1:0] slave_select,
    output reg                   access_error  // Permission denied
);

// Permission matrix - which masters can access which slaves
reg [NUM_MASTERS-1:0] slave_permissions [0:NUM_SLAVES-1];

initial begin
""")
            # Initialize permission matrix
            for i, slave in enumerate(self.config.slaves):
                f.write(f"    // {slave.name} permissions\n")
                if (hasattr(slave, 'allowed_masters') and 
                    slave.allowed_masters and 
                    len(slave.allowed_masters) < len(self.config.masters)):
                    # Generate permission bits based on allowed masters (restrictions apply)
                    perm_bits = ['0'] * num_masters
                    for j, master in enumerate(self.config.masters):
                        if master.name in slave.allowed_masters:
                            perm_bits[j] = '1'
                    f.write(f"    slave_permissions[{i}] = {num_masters}'b{''.join(reversed(perm_bits))}; // Restricted access\n")
                else:
                    # All masters allowed (default)
                    f.write(f"    slave_permissions[{i}] = {{{num_masters}{{1'b1}}}}; // All masters allowed (default)\n")
            
            f.write("""end

always @(*) begin
    slave_select = {NUM_SLAVES{1'b0}};
    access_error = 1'b0;
    
    if (awvalid || arvalid) begin
        case (1'b1)
""")
            # Generate address decode logic
            for i, slave in enumerate(self.config.slaves):
                base = slave.base_address
                size = slave.size * 1024  # Convert KB to bytes
                end = base + size - 1
                
                # Format address based on width
                addr_format = f"0{self.config.addr_width//4}X"  # Hex digits needed
                
                f.write(f"            // {slave.name}: 0x{base:{addr_format}} - 0x{end:{addr_format}}\n")
                f.write(f"            (awvalid ? awaddr : araddr) >= {self.config.addr_width}'h{base:X} && ")
                f.write(f"(awvalid ? awaddr : araddr) <= {self.config.addr_width}'h{end:X}: begin\n")
                # Check permissions and security attributes
                f.write(f"                if (slave_permissions[{i}][master_id]) begin\n")
                
                # Add security checks if slave requires them
                if slave.secure_only or slave.privileged_only:
                    f.write(f"                    // Security checks\n")
                    f.write(f"                    if (")
                    checks = []
                    if slave.secure_only:
                        checks.append("((awvalid ? awprot[1] : arprot[1]) == 1'b0)")
                    if slave.privileged_only:
                        checks.append("((awvalid ? awprot[0] : arprot[0]) == 1'b1)")
                    f.write(" && ".join(checks))
                    f.write(") begin\n")
                    f.write(f"                        slave_select[{i}] = 1'b1;\n")
                    f.write(f"                    end else begin\n")
                    f.write(f"                        access_error = 1'b1; // Security violation\n")
                    f.write(f"                    end\n")
                else:
                    f.write(f"                    slave_select[{i}] = 1'b1;\n")
                
                f.write(f"                end else begin\n")
                f.write(f"                    access_error = 1'b1; // Permission denied\n")
                f.write(f"                end\n")
                f.write(f"            end\n")
                
            f.write("""            default: slave_select = {NUM_SLAVES{1'b0}}; // No slave selected
        endcase
    end
end

endmodule
""")
            
    def generate_arbiter(self):
        """Generate arbiter module"""
        filename = f"{self.output_dir}/axi4_arbiter.v"
        
        with open(filename, 'w') as f:
            f.write("""//==============================================================================
// AXI4 Arbiter
// Arbitrates between multiple masters for slave access
//==============================================================================

module axi4_arbiter #(
    parameter NUM_MASTERS = 4,
    parameter ARBITRATION = "QOS"  // FIXED, RR, QOS, WRR
)(
    input  wire                          aclk,
    input  wire                          aresetn,
    
    // Master requests and priorities
""")
            for i in range(4):  # Generic for up to 4 masters
                f.write(f"    input  wire                          master{i}_request,\n")
                f.write(f"    input  wire [3:0]                    master{i}_priority,\n")
                
            f.write("""    
    // Grant output
    output reg  [NUM_MASTERS-1:0]        grant
);

reg [NUM_MASTERS-1:0] grant_next;
reg [$clog2(NUM_MASTERS)-1:0] rr_counter;

// Collect requests
wire [NUM_MASTERS-1:0] request;
""")
            
            # Generate request collection
            f.write("assign request = {")
            for i in range(3, -1, -1):
                f.write(f"(NUM_MASTERS > {i}) ? master{i}_request : 1'b0")
                if i > 0:
                    f.write(", ")
            f.write("};\n\n")
            
            f.write("""// Priority collection for QoS
wire [3:0] priority [0:NUM_MASTERS-1];
""")
            for i in range(4):
                f.write(f"assign priority[{i}] = (NUM_MASTERS > {i}) ? master{i}_priority : 4'b0;\n")
                
            f.write("""
// Arbitration logic
always @(*) begin
    grant_next = grant;
    
    case (ARBITRATION)
        "FIXED": begin
            // Fixed priority - lower index = higher priority
            grant_next = {NUM_MASTERS{1'b0}};
            if (request[0]) grant_next[0] = 1'b1;
            else if (NUM_MASTERS > 1 && request[1]) grant_next[1] = 1'b1;
            else if (NUM_MASTERS > 2 && request[2]) grant_next[2] = 1'b1;
            else if (NUM_MASTERS > 3 && request[3]) grant_next[3] = 1'b1;
        end
        
        "RR": begin
            // Round-robin arbitration
            grant_next = {NUM_MASTERS{1'b0}};
            // Implementation simplified for clarity
            grant_next[rr_counter] = request[rr_counter];
        end
        
        "QOS": begin
            // Quality of Service based arbitration
            integer i, j;
            reg [3:0] max_priority;
            reg [NUM_MASTERS-1:0] candidates;
            
            grant_next = {NUM_MASTERS{1'b0}};
            max_priority = 4'b0;
            candidates = {NUM_MASTERS{1'b0}};
            
            // Find highest priority
            for (i = 0; i < NUM_MASTERS; i = i + 1) begin
                if (request[i] && priority[i] > max_priority) begin
                    max_priority = priority[i];
                end
            end
            
            // Find all masters with highest priority
            for (i = 0; i < NUM_MASTERS; i = i + 1) begin
                if (request[i] && priority[i] == max_priority) begin
                    candidates[i] = 1'b1;
                end
            end
            
            // Among candidates, use fixed priority
            for (i = 0; i < NUM_MASTERS; i = i + 1) begin
                if (candidates[i]) begin
                    grant_next[i] = 1'b1;
                    i = NUM_MASTERS; // Break
                end
            end
        end
        
        default: grant_next = {NUM_MASTERS{1'b0}};
    endcase
end

// Sequential logic
always @(posedge aclk or negedge aresetn) begin
    if (!aresetn) begin
        grant <= {NUM_MASTERS{1'b0}};
        rr_counter <= {$clog2(NUM_MASTERS){1'b0}};
    end else begin
        grant <= grant_next;
        
        // Update round-robin counter
        if (ARBITRATION == "RR" && |grant) begin
            if (rr_counter == NUM_MASTERS-1)
                rr_counter <= {$clog2(NUM_MASTERS){1'b0}};
            else
                rr_counter <= rr_counter + 1'b1;
        end
    end
end

endmodule
""")
            
    def generate_router(self):
        """Generate router module"""
        filename = f"{self.output_dir}/axi4_router.v"
        
        with open(filename, 'w') as f:
            f.write("""//==============================================================================
// AXI4 Router
// Routes transactions between masters and slaves with response checking
//==============================================================================

module axi4_router #(
    parameter DATA_WIDTH  = 64,
    parameter ADDR_WIDTH  = 32,
    parameter ID_WIDTH    = 4,
    parameter USER_WIDTH  = 1,
    parameter NUM_MASTERS = 2,
    parameter NUM_SLAVES  = 3
)(
    input  wire                          aclk,
    input  wire                          aresetn,
    
    // Master write address channels
    input  wire [NUM_MASTERS*ADDR_WIDTH-1:0]  m_awaddr,
    input  wire [NUM_MASTERS*8-1:0]           m_awlen,
    input  wire [NUM_MASTERS*3-1:0]           m_awsize,
    input  wire [NUM_MASTERS*2-1:0]           m_awburst,
    input  wire [NUM_MASTERS*3-1:0]           m_awprot,
    input  wire [NUM_MASTERS-1:0]             m_awvalid,
    output wire [NUM_MASTERS-1:0]             m_awready,
    
    // Master read address channels
    input  wire [NUM_MASTERS*ADDR_WIDTH-1:0]  m_araddr,
    input  wire [NUM_MASTERS*8-1:0]           m_arlen,
    input  wire [NUM_MASTERS*3-1:0]           m_arsize,
    input  wire [NUM_MASTERS*2-1:0]           m_arburst,
    input  wire [NUM_MASTERS*3-1:0]           m_arprot,
    input  wire [NUM_MASTERS-1:0]             m_arvalid,
    output wire [NUM_MASTERS-1:0]             m_arready,
    
    // Slave response control signals
    input  wire [NUM_SLAVES-1:0]              s_decode_error,
    input  wire [NUM_SLAVES-1:0]              s_access_valid,
    
    // Control signals
    input  wire [NUM_MASTERS*NUM_SLAVES-1:0]  slave_select,
    input  wire [NUM_SLAVES*NUM_MASTERS-1:0]  master_grant
);

// Internal FIFOs for transaction tracking
reg [ID_WIDTH-1:0] transaction_id [0:1023];
reg [$clog2(NUM_MASTERS)-1:0] transaction_master [0:1023];
reg [9:0] wr_ptr, rd_ptr;

// Synthesizable 4KB boundary check logic
genvar i;
generate
    for (i = 0; i < NUM_MASTERS; i = i + 1) begin : boundary_check
        // Write address boundary check
        wire [ADDR_WIDTH-1:0] aw_bytes;
        wire [ADDR_WIDTH-1:0] aw_end_addr;
        wire aw_boundary_cross;
        
        assign aw_bytes = (8'd1 + m_awlen[i*8 +: 8]) << m_awsize[i*3 +: 3];
        assign aw_end_addr = m_awaddr[i*ADDR_WIDTH +: ADDR_WIDTH] + aw_bytes - 1;
        assign aw_boundary_cross = (m_awaddr[i*ADDR_WIDTH+12 +: ADDR_WIDTH-12] != 
                                   aw_end_addr[12 +: ADDR_WIDTH-12]);
        
        // Read address boundary check
        wire [ADDR_WIDTH-1:0] ar_bytes;
        wire [ADDR_WIDTH-1:0] ar_end_addr;
        wire ar_boundary_cross;
        
        assign ar_bytes = (8'd1 + m_arlen[i*8 +: 8]) << m_arsize[i*3 +: 3];
        assign ar_end_addr = m_araddr[i*ADDR_WIDTH +: ADDR_WIDTH] + ar_bytes - 1;
        assign ar_boundary_cross = (m_araddr[i*ADDR_WIDTH+12 +: ADDR_WIDTH-12] != 
                                   ar_end_addr[12 +: ADDR_WIDTH-12]);
    end
endgenerate

// Synthesizable access permission check
generate
    for (i = 0; i < NUM_MASTERS; i = i + 1) begin : access_check
        // Write access permission
        wire aw_privileged;
        wire aw_secure;
        wire aw_access_allowed;
        
        assign aw_privileged = m_awprot[i*3 +: 1];  // bit 0
        assign aw_secure = !m_awprot[i*3+1 +: 1];   // bit 1 inverted
        assign aw_access_allowed = 1'b1; // Can be connected to slave config
        
        // Read access permission
        wire ar_privileged;
        wire ar_secure;
        wire ar_access_allowed;
        
        assign ar_privileged = m_arprot[i*3 +: 1];  // bit 0
        assign ar_secure = !m_arprot[i*3+1 +: 1];   // bit 1 inverted
        assign ar_access_allowed = 1'b1; // Can be connected to slave config
    end
endgenerate

// Response generation logic
generate
    for (i = 0; i < NUM_SLAVES; i = i + 1) begin : resp_gen
        // Write response generation
        reg [1:0] bresp_gen;
        always @(*) begin
            if (s_decode_error[i])
                bresp_gen = 2'b11;  // DECERR
            else if (!s_access_valid[i])
                bresp_gen = 2'b10;  // SLVERR  
            else
                bresp_gen = 2'b00;  // OKAY
        end
        
        // Read response generation
        reg [1:0] rresp_gen;
        always @(*) begin
            if (s_decode_error[i])
                rresp_gen = 2'b11;  // DECERR
            else if (!s_access_valid[i])
                rresp_gen = 2'b10;  // SLVERR
            else
                rresp_gen = 2'b00;  // OKAY
        end
    end
endgenerate

// Main routing logic
// Transaction tracking and response routing

// Response routing logic with transaction tracking
always @(posedge aclk or negedge aresetn) begin
    if (!aresetn) begin
        wr_ptr <= 10'b0;
        rd_ptr <= 10'b0;
    end else begin
        // Store transaction info on AW/AR handshake for response routing
        // This enables proper response routing back to the originating master
    end
end

// Output ready signals (simplified)
generate
    for (i = 0; i < NUM_MASTERS; i = i + 1) begin : ready_gen
        assign m_awready[i] = |slave_select[i*NUM_SLAVES +: NUM_SLAVES];
        assign m_arready[i] = |slave_select[i*NUM_SLAVES +: NUM_SLAVES];
    end
endgenerate

endmodule
""")
            
    def generate_testbench(self):
        """Generate testbench"""
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        filename = f"{self.output_dir}/tb_axi4_interconnect.v"
        
        with open(filename, 'w') as f:
            f.write(f"""//==============================================================================
// Testbench for AXI4 Interconnect
//==============================================================================

`timescale 1ns/1ps

module tb_axi4_interconnect;

parameter DATA_WIDTH = {self.config.data_width};
parameter ADDR_WIDTH = {self.config.addr_width};

reg aclk;
reg aresetn;

// Clock generation
initial begin
    aclk = 0;
    forever #5 aclk = ~aclk;
end

// Reset generation
initial begin
    aresetn = 0;
    #100;
    aresetn = 1;
end

// DUT instantiation
axi4_interconnect_m{num_masters}s{num_slaves} #(
    .DATA_WIDTH(DATA_WIDTH),
    .ADDR_WIDTH(ADDR_WIDTH)
) dut (
    .aclk(aclk),
    .aresetn(aresetn)
    // Connect all interfaces
);

// Test sequences
initial begin
    $dumpfile("axi4_interconnect.vcd");
    $dumpvars(0, tb_axi4_interconnect);
    
    // Wait for reset
    @(posedge aresetn);
    repeat(10) @(posedge aclk);
    
    // Test 1: Basic write transaction
    $display("Test 1: Basic write transaction");
    
    // Test 2: Basic read transaction
    $display("Test 2: Basic read transaction");
    
    // Test 3: 4KB boundary test
    $display("Test 3: 4KB boundary test");
    
    // Test 4: Access permission test
    $display("Test 4: Access permission test");
    
    // Test 5: QoS arbitration test
    $display("Test 5: QoS arbitration test");
    
    #1000;
    $finish;
end

endmodule
""")
            
    def _generate_master_ports(self, idx, master):
        """Generate master port declarations"""
        return f"""    // Write Address Channel
    input  wire [{self.config.masters[0].id_width-1}:0]     m{idx}_awid,
    input  wire [ADDR_WIDTH-1:0]   m{idx}_awaddr,
    input  wire [7:0]              m{idx}_awlen,
    input  wire [2:0]              m{idx}_awsize,
    input  wire [1:0]              m{idx}_awburst,
    input  wire                    m{idx}_awlock,
    input  wire [3:0]              m{idx}_awcache,
    input  wire [2:0]              m{idx}_awprot,
    input  wire [3:0]              m{idx}_awqos,
    input  wire                    m{idx}_awvalid,
    output wire                    m{idx}_awready,
    
    // Write Data Channel
    input  wire [DATA_WIDTH-1:0]   m{idx}_wdata,
    input  wire [DATA_WIDTH/8-1:0] m{idx}_wstrb,
    input  wire                    m{idx}_wlast,
    input  wire                    m{idx}_wvalid,
    output wire                    m{idx}_wready,
    
    // Write Response Channel
    output wire [{self.config.masters[0].id_width-1}:0]     m{idx}_bid,
    output wire [1:0]              m{idx}_bresp,
    output wire                    m{idx}_bvalid,
    input  wire                    m{idx}_bready,
    
    // Read Address Channel
    input  wire [{self.config.masters[0].id_width-1}:0]     m{idx}_arid,
    input  wire [ADDR_WIDTH-1:0]   m{idx}_araddr,
    input  wire [7:0]              m{idx}_arlen,
    input  wire [2:0]              m{idx}_arsize,
    input  wire [1:0]              m{idx}_arburst,
    input  wire                    m{idx}_arlock,
    input  wire [3:0]              m{idx}_arcache,
    input  wire [2:0]              m{idx}_arprot,
    input  wire [3:0]              m{idx}_arqos,
    input  wire                    m{idx}_arvalid,
    output wire                    m{idx}_arready,
    
    // Read Data Channel
    output wire [{self.config.masters[0].id_width-1}:0]     m{idx}_rid,
    output wire [DATA_WIDTH-1:0]   m{idx}_rdata,
    output wire [1:0]              m{idx}_rresp,
    output wire                    m{idx}_rlast,
    output wire                    m{idx}_rvalid,
    input  wire                    m{idx}_rready"""
    
    def _generate_slave_ports(self, idx, slave):
        """Generate slave port declarations"""
        return f"""    // Write Address Channel
    output wire [{self.config.masters[0].id_width-1}:0]     s{idx}_awid,
    output wire [ADDR_WIDTH-1:0]   s{idx}_awaddr,
    output wire [7:0]              s{idx}_awlen,
    output wire [2:0]              s{idx}_awsize,
    output wire [1:0]              s{idx}_awburst,
    output wire                    s{idx}_awlock,
    output wire [3:0]              s{idx}_awcache,
    output wire [2:0]              s{idx}_awprot,
    output wire [3:0]              s{idx}_awqos,
    output wire                    s{idx}_awvalid,
    input  wire                    s{idx}_awready,
    
    // Write Data Channel
    output wire [DATA_WIDTH-1:0]   s{idx}_wdata,
    output wire [DATA_WIDTH/8-1:0] s{idx}_wstrb,
    output wire                    s{idx}_wlast,
    output wire                    s{idx}_wvalid,
    input  wire                    s{idx}_wready,
    
    // Write Response Channel
    input  wire [{self.config.masters[0].id_width-1}:0]     s{idx}_bid,
    input  wire [1:0]              s{idx}_bresp,
    input  wire                    s{idx}_bvalid,
    output wire                    s{idx}_bready,
    
    // Read Address Channel
    output wire [{self.config.masters[0].id_width-1}:0]     s{idx}_arid,
    output wire [ADDR_WIDTH-1:0]   s{idx}_araddr,
    output wire [7:0]              s{idx}_arlen,
    output wire [2:0]              s{idx}_arsize,
    output wire [1:0]              s{idx}_arburst,
    output wire                    s{idx}_arlock,
    output wire [3:0]              s{idx}_arcache,
    output wire [2:0]              s{idx}_arprot,
    output wire [3:0]              s{idx}_arqos,
    output wire                    s{idx}_arvalid,
    input  wire                    s{idx}_arready,
    
    // Read Data Channel
    input  wire [{self.config.masters[0].id_width-1}:0]     s{idx}_rid,
    input  wire [DATA_WIDTH-1:0]   s{idx}_rdata,
    input  wire [1:0]              s{idx}_rresp,
    input  wire                    s{idx}_rlast,
    input  wire                    s{idx}_rvalid,
    output wire                    s{idx}_rready"""