#!/usr/bin/env python3
"""
Enhanced VIP Environment Generator with proper slave sequence support
Fixes the issue where only master agents are active, ensuring slave agents respond properly
"""

import os
from datetime import datetime

class VIPEnvironmentGeneratorEnhancedFix:
    """Enhanced VIP Environment Generator with slave sequence fixes"""
    
    def __init__(self, base_generator):
        self.base_generator = base_generator
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
    def generate_enhanced_virtual_sequences(self, base_path):
        """Generate virtual sequences that properly start both master and slave sequences"""
        
        # Enhanced virtual write sequence with slave response
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write Sequence - Enhanced with Slave Response
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        axi4_slave_mem_seq slave_seq[{len(self.base_generator.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual write sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves first
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run write sequence on master 0
        `uvm_info(get_type_name(), "Starting master write sequence", UVM_MEDIUM)
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual write sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_write_seq
""")

        # Enhanced virtual read sequence with slave response
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Read Sequence - Enhanced with Slave Response
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_read_seq read_seq;
        axi4_slave_mem_seq slave_seq[{len(self.base_generator.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual read sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves first
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run read sequence on master 0
        `uvm_info(get_type_name(), "Starting master read sequence", UVM_MEDIUM)
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual read sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_read_seq
""")

        # Enhanced virtual write-read sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write-Read Sequence - Enhanced with Slave Response
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        axi4_slave_mem_seq slave_seq[{len(self.base_generator.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual write-read sequence with slave responses", UVM_MEDIUM)
        
        // Start slave sequences on all slaves
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                slave_seq[i].start(p_sequencer.slave_seqr[i]);
            join_none
        end
        
        // Give slaves time to initialize
        #100ns;
        
        // Run write sequence
        `uvm_info(get_type_name(), "Starting master write sequence", UVM_MEDIUM)
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
        // Small delay between write and read
        #50ns;
        
        // Run read sequence
        `uvm_info(get_type_name(), "Starting master read sequence", UVM_MEDIUM)
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual write-read sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_write_read_seq
""")

        # Enhanced virtual stress sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_stress_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Stress Sequence - Enhanced with Slave Response
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_stress_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_stress_seq)
    
    // Number of transactions per master
    int num_transactions = 10;
    
    // Constructor
    function new(string name = "axi4_virtual_stress_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq[{len(self.base_generator.config.masters)}];
        axi4_master_read_seq read_seq[{len(self.base_generator.config.masters)}];
        axi4_slave_mem_seq slave_seq[{len(self.base_generator.config.slaves)}];
        
        `uvm_info(get_type_name(), "Starting virtual stress sequence with all masters/slaves active", UVM_MEDIUM)
        
        // Start slave sequences on all slaves
        foreach(slave_seq[i]) begin
            `uvm_info(get_type_name(), $sformatf("Starting slave memory sequence on slave[%0d]", i), UVM_MEDIUM)
            slave_seq[i] = axi4_slave_mem_seq::type_id::create($sformatf("slave_seq[%0d]", i));
            fork
                automatic int idx = i;
                slave_seq[idx].start(p_sequencer.slave_seqr[idx]);
            join_none
        end
        
        // Give slaves time to initialize
        #200ns;
        
        // Start sequences on all masters in parallel
        foreach(write_seq[i]) begin
            fork
                automatic int idx = i;
                begin
                    for(int j = 0; j < num_transactions; j++) begin
                        `uvm_info(get_type_name(), $sformatf("Master[%0d] starting transaction %0d", idx, j), UVM_HIGH)
                        
                        // Alternate between writes and reads
                        if(j % 2 == 0) begin
                            write_seq[idx] = axi4_master_write_seq::type_id::create($sformatf("write_seq[%0d]_%0d", idx, j));
                            write_seq[idx].start(p_sequencer.master_seqr[idx]);
                        end else begin
                            read_seq[idx] = axi4_master_read_seq::type_id::create($sformatf("read_seq[%0d]_%0d", idx, j));
                            read_seq[idx].start(p_sequencer.master_seqr[idx]);
                        end
                        
                        // Random delay between transactions
                        #($urandom_range(10, 100) * 1ns);
                    end
                end
            join_none
        end
        
        // Wait for all masters to complete
        wait fork;
        
        // Stop slave sequences
        foreach(slave_seq[i]) begin
            if (slave_seq[i] != null) begin
                slave_seq[i].stop_sequences();
            end
        end
        
        `uvm_info(get_type_name(), "Completed virtual stress sequence", UVM_MEDIUM)
        
    endtask : body
    
endclass : axi4_virtual_stress_seq
""")

    def generate_enhanced_test_base(self, base_path):
        """Generate enhanced test base class with timeout and debug logging"""
        
        with open(os.path.join(base_path, "test/axi4_base_test.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Base Test - Enhanced with Timeout and Debug
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_base_test extends uvm_test;
    
    `uvm_component_utils(axi4_base_test)
    
    // Environment handle
    axi4_env env;
    
    // Environment configuration
    axi4_env_config env_cfg;
    
    // Test timeout (default: 10ms)
    time test_timeout = 10ms;
    
    // Test watchdog enable
    bit enable_watchdog = 1;
    
    // Constructor
    function new(string name = "axi4_base_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        `uvm_info(get_type_name(), "Starting build_phase", UVM_MEDIUM)
        
        // Create environment configuration
        env_cfg = axi4_env_config::type_id::create("env_cfg");
        
        // Initialize master and slave configurations
        env_cfg.no_of_masters = {len(self.base_generator.config.masters)};
        env_cfg.no_of_slaves = {len(self.base_generator.config.slaves)};
        
        // Set configuration
        uvm_config_db#(axi4_env_config)::set(this, "env*", "env_cfg", env_cfg);
        
        // Create environment
        env = axi4_env::type_id::create("env", this);
        
        `uvm_info(get_type_name(), $sformatf("Created environment with %0d masters and %0d slaves", 
                  env_cfg.no_of_masters, env_cfg.no_of_slaves), UVM_LOW)
    endfunction
    
    // Start of simulation phase
    function void start_of_simulation_phase(uvm_phase phase);
        super.start_of_simulation_phase(phase);
        
        // Set verbosity for better debug
        if ($test$plusargs("UVM_VERBOSITY")) begin
            string verbosity_str;
            uvm_verbosity verbosity_val;
            $value$plusargs("UVM_VERBOSITY=%s", verbosity_str);
            
            case (verbosity_str)
                "UVM_NONE"  : verbosity_val = UVM_NONE;
                "UVM_LOW"   : verbosity_val = UVM_LOW;
                "UVM_MEDIUM": verbosity_val = UVM_MEDIUM;
                "UVM_HIGH"  : verbosity_val = UVM_HIGH;
                "UVM_FULL"  : verbosity_val = UVM_FULL;
                "UVM_DEBUG" : verbosity_val = UVM_DEBUG;
                default     : verbosity_val = UVM_MEDIUM;
            endcase
            
            uvm_top.set_report_verbosity_level_hier(verbosity_val);
            `uvm_info(get_type_name(), $sformatf("Set verbosity to %s", verbosity_str), UVM_LOW)
        end
        
        // Check for waveform control
        if ($test$plusargs("enable_wave")) begin
            `uvm_info(get_type_name(), "Enabling waveform dump", UVM_LOW)
            `ifdef DUMP_FSDB
                $fsdbDumpon();
            `elsif DUMP_VCD
                $dumpon();
            `endif
        end
        
        if ($test$plusargs("disable_wave")) begin
            `uvm_info(get_type_name(), "Disabling waveform dump", UVM_LOW)
            `ifdef DUMP_FSDB
                $fsdbDumpoff();
            `elsif DUMP_VCD
                $dumpoff();
            `endif
        end
        
        // Override timeout if specified
        if ($value$plusargs("TEST_TIMEOUT=%d", test_timeout)) begin
            `uvm_info(get_type_name(), $sformatf("Test timeout set to %0t", test_timeout), UVM_LOW)
        end
    endfunction
    
    // End of elaboration phase
    function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        uvm_top.print_topology();
    endfunction
    
    // Run phase with timeout watchdog
    task run_phase(uvm_phase phase);
        process watchdog_process;
        
        phase.raise_objection(this);
        `uvm_info(get_type_name(), "Starting base test", UVM_LOW)
        
        // Start watchdog if enabled
        if (enable_watchdog) begin
            fork
                begin : watchdog_block
                    watchdog_process = process::self();
                    `uvm_info(get_type_name(), $sformatf("Starting test watchdog with timeout %0t", test_timeout), UVM_MEDIUM)
                    #test_timeout;
                    `uvm_error(get_type_name(), $sformatf("TEST TIMEOUT: Test did not complete within %0t", test_timeout))
                    `uvm_info(get_type_name(), "Calling global_stop_request due to timeout", UVM_LOW)
                    uvm_report_server::get_server().report_summarize();
                    $finish(2);
                end
            join_none
        end
        
        // Run actual test
        fork
            begin
                run_test_sequence();
            end
        join
        
        // Kill watchdog if test completed successfully
        if (watchdog_process != null) begin
            watchdog_process.kill();
            `uvm_info(get_type_name(), "Test completed successfully, killed watchdog", UVM_MEDIUM)
        end
        
        `uvm_info(get_type_name(), "Ending base test", UVM_LOW)
        phase.drop_objection(this);
    endtask
    
    // Virtual task to be overridden by derived tests
    virtual task run_test_sequence();
        // Default implementation - just wait
        #100ns;
    endtask
    
endclass : axi4_base_test
""")

    def generate_enhanced_slave_memory_sequence(self, base_path):
        """Generate enhanced slave memory sequence with better response handling"""
        
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_mem_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Memory Response Sequence - Enhanced
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_slave_mem_seq extends axi4_slave_base_seq;
    
    `uvm_object_utils(axi4_slave_mem_seq)
    
    // Memory storage
    bit [7:0] memory[bit[63:0]];
    
    // Response delay control
    int min_delay = 0;
    int max_delay = 5;
    
    // Enable debug messages
    bit debug_enable = 1;
    
    // Constructor
    function new(string name = "axi4_slave_mem_seq");
        super.new(name);
    endfunction
    
    // Body method - runs forever until stopped
    virtual task body();
        axi4_slave_tx tx;
        bit [63:0] addr;
        int delay;
        
        `uvm_info(get_type_name(), "Starting slave memory sequence - ready to respond", UVM_MEDIUM)
        
        forever begin
            // Get the next request from sequencer
            p_sequencer.get_next_item(tx);
            
            if (debug_enable) begin
                `uvm_info(get_type_name(), $sformatf("Received %s request: ADDR=0x%0h, LEN=%0d, SIZE=%0d", 
                         tx.tx_type == axi4_globals_pkg::WRITE ? "WRITE" : "READ",
                         tx.addr, tx.burst_length, tx.burst_size), UVM_HIGH)
            end
            
            // Add random delay
            delay = $urandom_range(min_delay, max_delay);
            if (delay > 0) begin
                repeat(delay) @(posedge p_sequencer.vif.aclk);
            end
            
            // Process based on transaction type
            if(tx.tx_type == axi4_globals_pkg::WRITE) begin
                // Store write data in memory
                for(int i = 0; i < tx.burst_length; i++) begin
                    addr = tx.addr + (i * (1 << tx.burst_size));
                    for(int j = 0; j < (1 << tx.burst_size); j++) begin
                        if(tx.wstrb[i][j]) begin
                            memory[addr + j] = tx.data[i][(j*8) +: 8];
                        end
                    end
                end
                
                // Set write response
                tx.resp = axi4_globals_pkg::OKAY;
                
                if (debug_enable) begin
                    `uvm_info(get_type_name(), $sformatf("Write completed: RESP=%s", 
                             tx.resp == axi4_globals_pkg::OKAY ? "OKAY" : "ERROR"), UVM_HIGH)
                end
                
            end else begin // READ
                // Read data from memory
                for(int i = 0; i < tx.burst_length; i++) begin
                    addr = tx.addr + (i * (1 << tx.burst_size));
                    tx.data[i] = 0;
                    for(int j = 0; j < (1 << tx.burst_size); j++) begin
                        if(memory.exists(addr + j)) begin
                            tx.data[i][(j*8) +: 8] = memory[addr + j];
                        end else begin
                            tx.data[i][(j*8) +: 8] = 8'hFF; // Default data for uninitialized memory
                        end
                    end
                    tx.resp = axi4_globals_pkg::OKAY;
                end
                
                if (debug_enable) begin
                    `uvm_info(get_type_name(), $sformatf("Read completed: DATA[0]=0x%0h, RESP=%s", 
                             tx.data[0], tx.resp == axi4_globals_pkg::OKAY ? "OKAY" : "ERROR"), UVM_HIGH)
                end
            end
            
            // Send response back
            p_sequencer.item_done(tx);
        end
        
    endtask : body
    
    // Task to stop this sequence
    virtual task stop_sequences();
        `uvm_info(get_type_name(), "Stopping slave memory sequence", UVM_MEDIUM)
        if (is_item_done == 0 && get_sequence_state() != STOPPED) begin
            stop_reason = STOP_REASON_SEQUENCE_KILLED;
        end
    endtask
    
endclass : axi4_slave_mem_seq
""")

    def generate_enhanced_tests(self, base_path):
        """Generate enhanced test files that properly use the updated base class"""
        
        # Basic read/write test
        with open(os.path.join(base_path, "test/axi4_basic_rw_test.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Basic Read/Write Test - Enhanced
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_basic_rw_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_basic_rw_test)
    
    // Constructor
    function new(string name = "axi4_basic_rw_test", uvm_component parent = null);
        super.new(name, parent);
        test_timeout = 5ms; // Set appropriate timeout
    endfunction
    
    // Override run_test_sequence
    virtual task run_test_sequence();
        axi4_virtual_write_read_seq vseq;
        
        `uvm_info(get_type_name(), "Starting basic read/write test sequence", UVM_LOW)
        
        // Create and start virtual sequence
        vseq = axi4_virtual_write_read_seq::type_id::create("vseq");
        vseq.start(env.v_seqr);
        
        `uvm_info(get_type_name(), "Completed basic read/write test sequence", UVM_LOW)
        
    endtask
    
endclass : axi4_basic_rw_test
""")

        # Stress test
        with open(os.path.join(base_path, "test/axi4_stress_test.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Stress Test - Enhanced
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_stress_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_stress_test)
    
    // Constructor
    function new(string name = "axi4_stress_test", uvm_component parent = null);
        super.new(name, parent);
        test_timeout = 20ms; // Longer timeout for stress test
    endfunction
    
    // Override run_test_sequence
    virtual task run_test_sequence();
        axi4_virtual_stress_seq vseq;
        
        `uvm_info(get_type_name(), "Starting stress test sequence", UVM_LOW)
        
        // Create and start virtual sequence
        vseq = axi4_virtual_stress_seq::type_id::create("vseq");
        vseq.num_transactions = 20; // Configure number of transactions
        vseq.start(env.v_seqr);
        
        `uvm_info(get_type_name(), "Completed stress test sequence", UVM_LOW)
        
    endtask
    
endclass : axi4_stress_test
""")

    def apply_fixes(self, vip_path):
        """Apply all the enhanced fixes to a VIP environment"""
        
        print(f"[VIP FIX] Applying enhanced VIP fixes to: {vip_path}")
        
        # Generate enhanced virtual sequences
        self.generate_enhanced_virtual_sequences(vip_path)
        print("[VIP FIX] Generated enhanced virtual sequences with slave support")
        
        # Generate enhanced test base class
        self.generate_enhanced_test_base(vip_path)
        print("[VIP FIX] Generated enhanced test base class with timeout")
        
        # Generate enhanced slave memory sequence
        self.generate_enhanced_slave_memory_sequence(vip_path)
        print("[VIP FIX] Generated enhanced slave memory sequence")
        
        # Generate enhanced tests
        self.generate_enhanced_tests(vip_path)
        print("[VIP FIX] Generated enhanced test files")
        
        print("[VIP FIX] All enhancements applied successfully!")


def apply_vip_environment_fixes(vip_path, config):
    """Main function to apply VIP environment fixes"""
    
    # Create a dummy base generator with the config
    class DummyGenerator:
        def __init__(self, config):
            self.config = config
            
    base_gen = DummyGenerator(config)
    fixer = VIPEnvironmentGeneratorEnhancedFix(base_gen)
    fixer.apply_fixes(vip_path)