"""
DUT Wrapper Fix for VIP Environment Generator
Fixes the 'id=z' issue by properly initializing all signals in stub mode
"""

def get_stub_rtl_wrapper(config, timestamp):
    """
    Generate a stub RTL wrapper that properly initializes all signals
    to avoid 'z' values in slave BFMs
    """
    num_masters = len(config.masters)
    num_slaves = len(config.slaves)
    
    # Get maximum ID width from all masters
    if config.masters:
        id_widths = [master.id_width for master in config.masters]
        id_width = max(id_widths)
    else:
        id_width = 4
        
    addr_width = config.addr_width
    data_width = config.data_width
    
    return f"""//==============================================================================
// DUT Wrapper for {num_masters}x{num_slaves} RTL Integration
// Stub implementation with proper signal initialization
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {timestamp}
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = {addr_width},
    parameter DATA_WIDTH = {data_width},
    parameter ID_WIDTH   = {id_width},
    parameter NUM_MASTERS = {num_masters},
    parameter NUM_SLAVES = {num_slaves}
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave master_if[NUM_MASTERS],  // Master interfaces from VIP
    axi4_if.master slave_if[NUM_SLAVES]    // Slave interfaces to VIP slave BFMs
);

    // Calculate extended ID width for slaves (includes master index)
    localparam SLAVE_ID_WIDTH = ID_WIDTH + $clog2(NUM_MASTERS);
    
    // For stub implementation, properly drive all signals to avoid 'z'
    genvar i;
    generate
        // Tie off master interfaces with valid responses
        for (i = 0; i < NUM_MASTERS; i++) begin : gen_master_tieoff
            always_comb begin
                // Write address channel ready
                master_if[i].awready = 1'b1;
                
                // Write data channel ready
                master_if[i].wready = 1'b1;
                
                // Write response channel - properly driven
                master_if[i].bid    = master_if[i].awid;  // Echo back the ID
                master_if[i].bresp  = 2'b00;              // OKAY response
                master_if[i].bvalid = 1'b0;               // Not valid
                
                // Read address channel ready
                master_if[i].arready = 1'b1;
                
                // Read data channel - properly driven
                master_if[i].rid    = master_if[i].arid;  // Echo back the ID
                master_if[i].rdata  = {{DATA_WIDTH{{1'b0}}}}; // Zero data
                master_if[i].rresp  = 2'b00;              // OKAY response
                master_if[i].rlast  = 1'b0;               // Not last
                master_if[i].rvalid = 1'b0;               // Not valid
            end
        end
        
        // Properly drive slave interfaces to avoid 'z'
        for (i = 0; i < NUM_SLAVES; i++) begin : gen_slave_tieoff
            always_comb begin
                // Write address channel - drive with valid zeros
                slave_if[i].awid     = {{SLAVE_ID_WIDTH{{1'b0}}}};
                slave_if[i].awaddr   = {{ADDR_WIDTH{{1'b0}}}};
                slave_if[i].awlen    = 8'b0;
                slave_if[i].awsize   = 3'b0;
                slave_if[i].awburst  = 2'b0;
                slave_if[i].awlock   = 1'b0;
                slave_if[i].awcache  = 4'b0;
                slave_if[i].awprot   = 3'b0;
                slave_if[i].awqos    = 4'b0;
                slave_if[i].awregion = 4'b0;
                slave_if[i].awvalid  = 1'b0;
                
                // Write data channel - drive with valid zeros
                slave_if[i].wdata  = {{DATA_WIDTH{{1'b0}}}};
                slave_if[i].wstrb  = {{(DATA_WIDTH/8){{1'b0}}}};
                slave_if[i].wlast  = 1'b0;
                slave_if[i].wvalid = 1'b0;
                
                // Write response ready
                slave_if[i].bready = 1'b1;
                
                // Read address channel - drive with valid zeros
                slave_if[i].arid     = {{SLAVE_ID_WIDTH{{1'b0}}}};
                slave_if[i].araddr   = {{ADDR_WIDTH{{1'b0}}}};
                slave_if[i].arlen    = 8'b0;
                slave_if[i].arsize   = 3'b0;
                slave_if[i].arburst  = 2'b0;
                slave_if[i].arlock   = 1'b0;
                slave_if[i].arcache  = 4'b0;
                slave_if[i].arprot   = 3'b0;
                slave_if[i].arqos    = 4'b0;
                slave_if[i].arregion = 4'b0;
                slave_if[i].arvalid  = 1'b0;
                
                // Read data ready
                slave_if[i].rready = 1'b1;
            end
        end
    endgenerate
    
    initial begin
        $display("[%0t] DUT Wrapper: {num_masters}x{num_slaves} Stub Configuration", $time);
        $display("[%0t] DUT Wrapper: All signals properly initialized to avoid 'z'", $time);
        $display("[%0t] DUT Wrapper: Master interfaces tied off with echo IDs", $time);
        $display("[%0t] DUT Wrapper: Slave interfaces driven with valid zeros", $time);
        $display("[%0t] DUT Wrapper: Replace with actual interconnect when available", $time);
    end

endmodule : dut_wrapper"""


def patch_vip_environment_generator():
    """
    Patch the VIP environment generator to use the stub wrapper
    when appropriate (large matrices or when gen_amba_axi is not available)
    """
    import os
    
    # Read the existing vip_environment_generator.py
    gen_file = "/home/timtim01/eda_test/project/gen_amba_2025/axi4_vip/gui/src/vip_environment_generator.py"
    
    if not os.path.exists(gen_file):
        print(f"Error: {gen_file} not found")
        return False
    
    with open(gen_file, 'r') as f:
        content = f.read()
    
    # Find the _get_enhanced_rtl_wrapper method
    if "_get_enhanced_rtl_wrapper" not in content:
        print("Error: _get_enhanced_rtl_wrapper method not found")
        return False
    
    # Add the new stub wrapper method after the imports
    insert_pos = content.find("class VIPEnvironmentGenerator:")
    if insert_pos == -1:
        print("Error: VIPEnvironmentGenerator class not found")
        return False
    
    # Insert helper method to check if stub is needed
    stub_check_method = '''
    def _should_use_stub_wrapper(self):
        """Check if we should use a stub wrapper instead of real interconnect"""
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        # Use stub for large matrices or when explicitly requested
        if num_masters >= 15 or num_slaves >= 15:
            return True
            
        # Use stub if gen_amba_axi tool is not available
        gen_amba_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 
                                                      "../../../../gen_amba_axi/gen_amba_axi"))
        if not os.path.exists(gen_amba_path):
            # Try alternative path
            gen_amba_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 
                                                          "../../../gen_amba_axi/gen_amba_axi"))
            if not os.path.exists(gen_amba_path):
                return True
                
        return False
        
    def _get_stub_rtl_wrapper(self):
        """Generate stub RTL wrapper with proper signal initialization"""
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        # Get maximum ID width from all masters
        if self.config.masters:
            id_widths = [master.id_width for master in self.config.masters]
            id_width = max(id_widths)
        else:
            id_width = 4
            
        return f"""//==============================================================================
// DUT Wrapper for {num_masters}x{num_slaves} RTL Integration
// Stub implementation with proper signal initialization
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ID_WIDTH   = {id_width},
    parameter NUM_MASTERS = {num_masters},
    parameter NUM_SLAVES = {num_slaves}
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave master_if[NUM_MASTERS],  // Master interfaces from VIP
    axi4_if.master slave_if[NUM_SLAVES]    // Slave interfaces to VIP slave BFMs
);

    // Calculate extended ID width for slaves (includes master index)
    localparam SLAVE_ID_WIDTH = ID_WIDTH + $clog2(NUM_MASTERS);
    
    // For stub implementation, properly drive all signals to avoid 'z'
    genvar i;
    generate
        // Tie off master interfaces with valid responses
        for (i = 0; i < NUM_MASTERS; i++) begin : gen_master_tieoff
            always_comb begin
                // Write address channel ready
                master_if[i].awready = 1'b1;
                
                // Write data channel ready
                master_if[i].wready = 1'b1;
                
                // Write response channel - properly driven
                master_if[i].bid    = master_if[i].awid;  // Echo back the ID
                master_if[i].bresp  = 2'b00;              // OKAY response
                master_if[i].bvalid = 1'b0;               // Not valid
                
                // Read address channel ready
                master_if[i].arready = 1'b1;
                
                // Read data channel - properly driven
                master_if[i].rid    = master_if[i].arid;  // Echo back the ID
                master_if[i].rdata  = {DATA_WIDTH{1'b0}}; // Zero data
                master_if[i].rresp  = 2'b00;              // OKAY response
                master_if[i].rlast  = 1'b0;               // Not last
                master_if[i].rvalid = 1'b0;               // Not valid
            end
        end
        
        // Properly drive slave interfaces to avoid 'z'
        for (i = 0; i < NUM_SLAVES; i++) begin : gen_slave_tieoff
            always_comb begin
                // Write address channel - drive with valid zeros
                slave_if[i].awid     = {SLAVE_ID_WIDTH{1'b0}};
                slave_if[i].awaddr   = {ADDR_WIDTH{1'b0}};
                slave_if[i].awlen    = 8'b0;
                slave_if[i].awsize   = 3'b0;
                slave_if[i].awburst  = 2'b0;
                slave_if[i].awlock   = 1'b0;
                slave_if[i].awcache  = 4'b0;
                slave_if[i].awprot   = 3'b0;
                slave_if[i].awqos    = 4'b0;
                slave_if[i].awregion = 4'b0;
                slave_if[i].awvalid  = 1'b0;
                
                // Write data channel - drive with valid zeros
                slave_if[i].wdata  = {DATA_WIDTH{1'b0}};
                slave_if[i].wstrb  = {(DATA_WIDTH/8){1'b0}};
                slave_if[i].wlast  = 1'b0;
                slave_if[i].wvalid = 1'b0;
                
                // Write response ready
                slave_if[i].bready = 1'b1;
                
                // Read address channel - drive with valid zeros
                slave_if[i].arid     = {SLAVE_ID_WIDTH{1'b0}};
                slave_if[i].araddr   = {ADDR_WIDTH{1'b0}};
                slave_if[i].arlen    = 8'b0;
                slave_if[i].arsize   = 3'b0;
                slave_if[i].arburst  = 2'b0;
                slave_if[i].arlock   = 1'b0;
                slave_if[i].arcache  = 4'b0;
                slave_if[i].arprot   = 3'b0;
                slave_if[i].arqos    = 4'b0;
                slave_if[i].arregion = 4'b0;
                slave_if[i].arvalid  = 1'b0;
                
                // Read data ready
                slave_if[i].rready = 1'b1;
            end
        end
    endgenerate
    
    initial begin
        $display("[%0t] DUT Wrapper: {num_masters}x{num_slaves} Stub Configuration", $time);
        $display("[%0t] DUT Wrapper: All signals properly initialized to avoid 'z'", $time);
        $display("[%0t] DUT Wrapper: Master interfaces tied off with echo IDs", $time);
        $display("[%0t] DUT Wrapper: Slave interfaces driven with valid zeros", $time);
        $display("[%0t] DUT Wrapper: Replace with actual interconnect when available", $time);
    end

endmodule : dut_wrapper"""
'''
    
    # Find where to modify _generate_rtl_wrapper
    wrapper_method_pos = content.find("def _generate_rtl_wrapper(self, base_path):")
    if wrapper_method_pos != -1:
        # Find the line where it calls _get_enhanced_rtl_wrapper
        enhanced_call_pos = content.find("wrapper_content = self._get_enhanced_rtl_wrapper()", wrapper_method_pos)
        if enhanced_call_pos != -1:
            # Replace with conditional call
            old_line = "wrapper_content = self._get_enhanced_rtl_wrapper()"
            new_line = """# Check if we should use stub wrapper
        if self._should_use_stub_wrapper():
            wrapper_content = self._get_stub_rtl_wrapper()
            self.warnings.append(f"Using stub DUT wrapper for {len(self.config.masters)}x{len(self.config.slaves)} matrix")
        else:
            wrapper_content = self._get_enhanced_rtl_wrapper()"""
            
            content = content.replace(old_line, new_line, 1)
    
    # Add the helper methods after the class definition
    class_end_pos = content.find("    def _get_enhanced_rtl_wrapper(self):")
    if class_end_pos != -1:
        content = content[:class_end_pos] + stub_check_method + "\n" + content[class_end_pos:]
    
    # Save the patched file
    backup_file = gen_file + ".backup_dut_wrapper_fix"
    with open(backup_file, 'w') as f:
        f.write(content)
    
    print(f"Patch saved to {backup_file}")
    print("To apply the patch, run:")
    print(f"  cp {backup_file} {gen_file}")
    
    return True


if __name__ == "__main__":
    print("DUT Wrapper Fix for VIP Environment Generator")
    print("=" * 60)
    print("\nThis script patches the VIP generator to properly initialize")
    print("all signals in stub mode, fixing the 'id=z' issue.\n")
    
    if patch_vip_environment_generator():
        print("\n✓ Patch created successfully!")
    else:
        print("\n✗ Failed to create patch")