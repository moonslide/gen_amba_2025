#!/usr/bin/env python3
"""
VIP BFM (Bus Functional Model) Generator
Implements BFM components based on tim_axi4_vip structure
Step 1 of VIP Enhancement
"""

import os
from datetime import datetime
from typing import Dict, List, Optional

class VIPBFMGenerator:
    """Generate BFM components for AXI4 VIP"""
    
    def __init__(self, config):
        self.config = config
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
    def generate_all_bfm_components(self, output_dir):
        """Generate all BFM components"""
        bfm_dir = os.path.join(output_dir, "agent")
        os.makedirs(os.path.join(bfm_dir, "master_agent_bfm"), exist_ok=True)
        os.makedirs(os.path.join(bfm_dir, "slave_agent_bfm"), exist_ok=True)
        
        # Generate Master BFM components
        self._generate_master_agent_bfm(bfm_dir)
        self._generate_master_driver_bfm(bfm_dir)
        self._generate_master_monitor_bfm(bfm_dir)
        
        # Generate Slave BFM components
        self._generate_slave_agent_bfm(bfm_dir)
        self._generate_slave_driver_bfm(bfm_dir)
        self._generate_slave_monitor_bfm(bfm_dir)
        
        # Generate BFM package
        self._generate_bfm_package(output_dir)
        
    def _generate_master_agent_bfm(self, base_dir):
        """Generate Master Agent BFM"""
        content = f"""//==============================================================================
// AXI4 Master Agent BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Based on tim_axi4_vip architecture
//==============================================================================

`ifndef AXI4_MASTER_AGENT_BFM_SV
`define AXI4_MASTER_AGENT_BFM_SV

class axi4_master_agent_bfm extends uvm_agent;
    `uvm_component_utils(axi4_master_agent_bfm)
    
    // BFM Components
    axi4_master_driver_bfm driver_bfm;
    axi4_master_monitor_bfm monitor_bfm;
    
    // Configuration
    axi4_master_agent_config cfg;
    
    // Analysis ports for transaction-level communication
    uvm_analysis_port #(axi4_master_tx) ap_write;
    uvm_analysis_port #(axi4_master_tx) ap_read;
    
    // Constructor
    function new(string name = "axi4_master_agent_bfm", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // Get configuration
        if(!uvm_config_db#(axi4_master_agent_config)::get(this, "", "cfg", cfg))
            `uvm_fatal("CONFIG", "Cannot get axi4_master_agent_config")
        
        // Create BFM components
        driver_bfm = axi4_master_driver_bfm::type_id::create("driver_bfm", this);
        monitor_bfm = axi4_master_monitor_bfm::type_id::create("monitor_bfm", this);
        
        // Create analysis ports
        ap_write = new("ap_write", this);
        ap_read = new("ap_read", this);
    endfunction
    
    // Connect phase
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // Pass configuration to BFM components
        driver_bfm.cfg = cfg;
        monitor_bfm.cfg = cfg;
        
        // Connect monitor to analysis ports
        monitor_bfm.ap_write.connect(ap_write);
        monitor_bfm.ap_read.connect(ap_read);
    endfunction
    
    // Task-based BFM API
    task write_burst(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.id_width-1}:0] id,
        input bit [7:0] len,
        input bit [2:0] size,
        input bit [1:0] burst,
        input bit [{self.config.data_width-1}:0] data[],
        input bit [{self.config.data_width/8-1}:0] strb[],
        output bit [1:0] resp
    );
        driver_bfm.write_burst(addr, id, len, size, burst, data, strb, resp);
    endtask
    
    task read_burst(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.id_width-1}:0] id,
        input bit [7:0] len,
        input bit [2:0] size,
        input bit [1:0] burst,
        output bit [{self.config.data_width-1}:0] data[],
        output bit [1:0] resp[]
    );
        driver_bfm.read_burst(addr, id, len, size, burst, data, resp);
    endtask
    
    // Advanced BFM features
    task write_with_qos(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [3:0] qos,
        input bit [3:0] region,
        input bit [{self.config.data_width-1}:0] data[],
        output bit [1:0] resp
    );
        driver_bfm.write_with_qos(addr, qos, region, data, resp);
    endtask
    
    task exclusive_access(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.data_width-1}:0] data,
        output bit success
    );
        driver_bfm.exclusive_access(addr, data, success);
    endtask
    
endclass

`endif // AXI4_MASTER_AGENT_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "master_agent_bfm", "axi4_master_agent_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_master_driver_bfm(self, base_dir):
        """Generate Master Driver BFM"""
        content = f"""//==============================================================================
// AXI4 Master Driver BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Provides task-based API for driving AXI transactions
//==============================================================================

`ifndef AXI4_MASTER_DRIVER_BFM_SV
`define AXI4_MASTER_DRIVER_BFM_SV

class axi4_master_driver_bfm extends uvm_driver #(axi4_master_tx);
    `uvm_component_utils(axi4_master_driver_bfm)
    
    // Virtual interface
    virtual axi4_if vif;
    
    // Configuration
    axi4_master_agent_config cfg;
    
    // Internal state
    protected bit exclusive_monitor[bit [{self.config.addr_width-1}:0]];
    protected int outstanding_aw_cnt = 0;
    protected int outstanding_w_cnt = 0;
    protected int outstanding_ar_cnt = 0;
    
    // Constructor
    function new(string name = "axi4_master_driver_bfm", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        // Initialize signals
        init_signals();
        
        // Main driver loop
        forever begin
            seq_item_port.get_next_item(req);
            drive_transaction(req);
            seq_item_port.item_done();
        end
    endtask
    
    // Initialize all signals
    task init_signals();
        vif.awvalid <= 0;
        vif.wvalid <= 0;
        vif.bready <= 1;
        vif.arvalid <= 0;
        vif.rready <= 1;
        
        // Initialize all signals per AXI spec
        vif.awid <= '0;
        vif.awaddr <= '0;
        vif.awlen <= '0;
        vif.awsize <= '0;
        vif.awburst <= '0;
        vif.awlock <= '0;
        vif.awcache <= '0;
        vif.awprot <= '0;
        vif.awqos <= '0;
        vif.awregion <= '0;
        vif.awuser <= '0;
        
        vif.wdata <= '0;
        vif.wstrb <= '0;
        vif.wlast <= '0;
        vif.wuser <= '0;
        
        vif.arid <= '0;
        vif.araddr <= '0;
        vif.arlen <= '0;
        vif.arsize <= '0;
        vif.arburst <= '0;
        vif.arlock <= '0;
        vif.arcache <= '0;
        vif.arprot <= '0;
        vif.arqos <= '0;
        vif.arregion <= '0;
        vif.aruser <= '0;
    endtask
    
    // Drive a transaction
    task drive_transaction(axi4_master_tx tr);
        if(tr.tx_type == WRITE)
            drive_write_transaction(tr);
        else
            drive_read_transaction(tr);
    endtask
    
    // Drive write transaction
    task drive_write_transaction(axi4_master_tx tr);
        // Check 4KB boundary
        check_4kb_boundary(tr);
        
        // Drive address channel
        @(posedge vif.aclk);
        vif.awid <= tr.awid;
        vif.awaddr <= tr.awaddr;
        vif.awlen <= tr.awlen;
        vif.awsize <= tr.awsize;
        vif.awburst <= tr.awburst;
        vif.awlock <= tr.awlock;
        vif.awcache <= tr.awcache;
        vif.awprot <= tr.awprot;
        vif.awqos <= tr.awqos;
        vif.awregion <= tr.awregion;
        vif.awuser <= tr.awuser;
        vif.awvalid <= 1;
        
        // Wait for ready
        while(!vif.awready) @(posedge vif.aclk);
        vif.awvalid <= 0;
        
        // Drive data channel
        for(int i = 0; i <= tr.awlen; i++) begin
            @(posedge vif.aclk);
            vif.wdata <= tr.wdata[i];
            vif.wstrb <= tr.wstrb[i];
            vif.wlast <= (i == tr.awlen);
            vif.wuser <= tr.wuser;
            vif.wvalid <= 1;
            
            while(!vif.wready) @(posedge vif.aclk);
        end
        vif.wvalid <= 0;
        vif.wlast <= 0;
        
        // Wait for response
        while(!vif.bvalid) @(posedge vif.aclk);
        tr.bresp = vif.bresp;
        tr.bid = vif.bid;
        
        // Handle exclusive access
        if(tr.awlock == 1'b1) begin
            exclusive_monitor[tr.awaddr] = (tr.bresp == 2'b01); // EXOKAY
        end
    endtask
    
    // Drive read transaction
    task drive_read_transaction(axi4_master_tx tr);
        // Check 4KB boundary
        check_4kb_boundary(tr);
        
        // Drive address channel
        @(posedge vif.aclk);
        vif.arid <= tr.arid;
        vif.araddr <= tr.araddr;
        vif.arlen <= tr.arlen;
        vif.arsize <= tr.arsize;
        vif.arburst <= tr.arburst;
        vif.arlock <= tr.arlock;
        vif.arcache <= tr.arcache;
        vif.arprot <= tr.arprot;
        vif.arqos <= tr.arqos;
        vif.arregion <= tr.arregion;
        vif.aruser <= tr.aruser;
        vif.arvalid <= 1;
        
        // Wait for ready
        while(!vif.arready) @(posedge vif.aclk);
        vif.arvalid <= 0;
        
        // Receive data
        tr.rdata = new[tr.arlen + 1];
        tr.rresp = new[tr.arlen + 1];
        
        for(int i = 0; i <= tr.arlen; i++) begin
            while(!vif.rvalid) @(posedge vif.aclk);
            tr.rdata[i] = vif.rdata;
            tr.rresp[i] = vif.rresp;
            tr.rid = vif.rid;
            
            if(vif.rlast != (i == tr.arlen))
                `uvm_error("RLAST", "RLAST mismatch")
        end
        
        // Handle exclusive read
        if(tr.arlock == 1'b1) begin
            exclusive_monitor[tr.araddr] = 1;
        end
    endtask
    
    // BFM API tasks
    task write_burst(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.id_width-1}:0] id,
        input bit [7:0] len,
        input bit [2:0] size,
        input bit [1:0] burst,
        input bit [{self.config.data_width-1}:0] data[],
        input bit [{self.config.data_width/8-1}:0] strb[],
        output bit [1:0] resp
    );
        axi4_master_tx tr = axi4_master_tx::type_id::create("tr");
        tr.tx_type = WRITE;
        tr.awaddr = addr;
        tr.awid = id;
        tr.awlen = len;
        tr.awsize = size;
        tr.awburst = burst;
        tr.wdata = data;
        tr.wstrb = strb;
        
        // Use sequence item port to drive
        seq_item_port.get_next_item(tr);
        drive_write_transaction(tr);
        seq_item_port.item_done();
        
        resp = tr.bresp;
    endtask
    
    task read_burst(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.id_width-1}:0] id,
        input bit [7:0] len,
        input bit [2:0] size,
        input bit [1:0] burst,
        output bit [{self.config.data_width-1}:0] data[],
        output bit [1:0] resp[]
    );
        axi4_master_tx tr = axi4_master_tx::type_id::create("tr");
        tr.tx_type = READ;
        tr.araddr = addr;
        tr.arid = id;
        tr.arlen = len;
        tr.arsize = size;
        tr.arburst = burst;
        
        // Use sequence item port to drive
        seq_item_port.get_next_item(tr);
        drive_read_transaction(tr);
        seq_item_port.item_done();
        
        data = tr.rdata;
        resp = tr.rresp;
    endtask
    
    // Advanced features
    task write_with_qos(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [3:0] qos,
        input bit [3:0] region,
        input bit [{self.config.data_width-1}:0] data[],
        output bit [1:0] resp
    );
        axi4_master_tx tr = axi4_master_tx::type_id::create("tr");
        tr.tx_type = WRITE;
        tr.awaddr = addr;
        tr.awqos = qos;
        tr.awregion = region;
        tr.awlen = data.size() - 1;
        tr.wdata = data;
        
        // Default strobe to all bytes valid
        tr.wstrb = new[data.size()];
        foreach(tr.wstrb[i]) tr.wstrb[i] = '1;
        
        seq_item_port.get_next_item(tr);
        drive_write_transaction(tr);
        seq_item_port.item_done();
        
        resp = tr.bresp;
    endtask
    
    task exclusive_access(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.data_width-1}:0] data,
        output bit success
    );
        axi4_master_tx rd_tr, wr_tr;
        
        // Exclusive read
        rd_tr = axi4_master_tx::type_id::create("rd_tr");
        rd_tr.tx_type = READ;
        rd_tr.araddr = addr;
        rd_tr.arlen = 0;
        rd_tr.arlock = 1;
        
        seq_item_port.get_next_item(rd_tr);
        drive_read_transaction(rd_tr);
        seq_item_port.item_done();
        
        // Exclusive write
        wr_tr = axi4_master_tx::type_id::create("wr_tr");
        wr_tr.tx_type = WRITE;
        wr_tr.awaddr = addr;
        wr_tr.awlen = 0;
        wr_tr.awlock = 1;
        wr_tr.wdata = new[1];
        wr_tr.wdata[0] = data;
        wr_tr.wstrb = new[1];
        wr_tr.wstrb[0] = '1;
        
        seq_item_port.get_next_item(wr_tr);
        drive_write_transaction(wr_tr);
        seq_item_port.item_done();
        
        success = (wr_tr.bresp == 2'b01); // EXOKAY
    endtask
    
    // 4KB boundary check
    task check_4kb_boundary(axi4_master_tx tr);
        bit [{self.config.addr_width-1}:0] start_addr, end_addr;
        int bytes_per_beat;
        
        bytes_per_beat = 1 << (tr.tx_type == WRITE ? tr.awsize : tr.arsize);
        start_addr = (tr.tx_type == WRITE) ? tr.awaddr : tr.araddr;
        end_addr = start_addr + ((tr.tx_type == WRITE ? tr.awlen : tr.arlen) + 1) * bytes_per_beat - 1;
        
        if((start_addr >> 12) != (end_addr >> 12)) begin
            `uvm_warning("4KB", $sformatf("Transaction crosses 4KB boundary: start=0x%0h, end=0x%0h", 
                         start_addr, end_addr))
        end
    endtask
    
endclass

`endif // AXI4_MASTER_DRIVER_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "master_agent_bfm", "axi4_master_driver_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_master_monitor_bfm(self, base_dir):
        """Generate Master Monitor BFM"""
        content = f"""//==============================================================================
// AXI4 Master Monitor BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Monitors AXI transactions and provides transaction-level visibility
//==============================================================================

`ifndef AXI4_MASTER_MONITOR_BFM_SV
`define AXI4_MASTER_MONITOR_BFM_SV

class axi4_master_monitor_bfm extends uvm_monitor;
    `uvm_component_utils(axi4_master_monitor_bfm)
    
    // Virtual interface
    virtual axi4_if vif;
    
    // Configuration
    axi4_master_agent_config cfg;
    
    // Analysis ports
    uvm_analysis_port #(axi4_master_tx) ap_write;
    uvm_analysis_port #(axi4_master_tx) ap_read;
    
    // Transaction tracking
    axi4_master_tx aw_trans[$];
    axi4_master_tx ar_trans[$];
    axi4_master_tx w_trans[int];
    
    // Coverage
    covergroup axi4_master_cg;
        // Burst type coverage
        burst_type_cp: coverpoint vif.awburst {{
            bins fixed = {{2'b00}};
            bins incr = {{2'b01}};
            bins wrap = {{2'b10}};
        }}
        
        // Transfer size coverage
        size_cp: coverpoint vif.awsize {{
            bins size_1b = {{3'b000}};
            bins size_2b = {{3'b001}};
            bins size_4b = {{3'b010}};
            bins size_8b = {{3'b011}};
            bins size_16b = {{3'b100}};
            bins size_32b = {{3'b101}};
            bins size_64b = {{3'b110}};
            bins size_128b = {{3'b111}};
        }}
        
        // QoS coverage
        qos_cp: coverpoint vif.awqos;
        
        // Response coverage
        resp_cp: coverpoint vif.bresp {{
            bins okay = {{2'b00}};
            bins exokay = {{2'b01}};
            bins slverr = {{2'b10}};
            bins decerr = {{2'b11}};
        }}
    endgroup
    
    // Constructor
    function new(string name = "axi4_master_monitor_bfm", uvm_component parent = null);
        super.new(name, parent);
        ap_write = new("ap_write", this);
        ap_read = new("ap_read", this);
        axi4_master_cg = new();
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        fork
            monitor_write_address_channel();
            monitor_write_data_channel();
            monitor_write_response_channel();
            monitor_read_address_channel();
            monitor_read_data_channel();
        join
    endtask
    
    // Monitor write address channel
    task monitor_write_address_channel();
        forever begin
            @(posedge vif.aclk);
            if(vif.awvalid && vif.awready) begin
                axi4_master_tx tr = axi4_master_tx::type_id::create("aw_tr");
                tr.tx_type = WRITE;
                tr.awid = vif.awid;
                tr.awaddr = vif.awaddr;
                tr.awlen = vif.awlen;
                tr.awsize = vif.awsize;
                tr.awburst = vif.awburst;
                tr.awlock = vif.awlock;
                tr.awcache = vif.awcache;
                tr.awprot = vif.awprot;
                tr.awqos = vif.awqos;
                tr.awregion = vif.awregion;
                tr.awuser = vif.awuser;
                
                // Store for correlation
                aw_trans.push_back(tr);
                
                // Sample coverage
                axi4_master_cg.sample();
                
                `uvm_info("MON", $sformatf("Write Address: ID=%0h ADDR=0x%0h LEN=%0d", 
                         tr.awid, tr.awaddr, tr.awlen), UVM_HIGH)
            end
        end
    endtask
    
    // Monitor write data channel
    task monitor_write_data_channel();
        axi4_master_tx tr;
        int beat_cnt = 0;
        
        forever begin
            @(posedge vif.aclk);
            if(vif.wvalid && vif.wready) begin
                if(aw_trans.size() > 0 && beat_cnt == 0) begin
                    tr = aw_trans.pop_front();
                    tr.wdata = new[tr.awlen + 1];
                    tr.wstrb = new[tr.awlen + 1];
                end
                
                if(tr != null) begin
                    tr.wdata[beat_cnt] = vif.wdata;
                    tr.wstrb[beat_cnt] = vif.wstrb;
                    tr.wuser = vif.wuser;
                    
                    if(vif.wlast) begin
                        if(beat_cnt != tr.awlen)
                            `uvm_error("MON", $sformatf("WLAST mismatch: expected %0d, got %0d", 
                                      tr.awlen, beat_cnt))
                        
                        // Store for response correlation
                        w_trans[tr.awid] = tr;
                        beat_cnt = 0;
                        tr = null;
                    end else begin
                        beat_cnt++;
                    end
                end
            end
        end
    endtask
    
    // Monitor write response channel
    task monitor_write_response_channel();
        forever begin
            @(posedge vif.aclk);
            if(vif.bvalid && vif.bready) begin
                if(w_trans.exists(vif.bid)) begin
                    axi4_master_tx tr = w_trans[vif.bid];
                    tr.bid = vif.bid;
                    tr.bresp = vif.bresp;
                    tr.buser = vif.buser;
                    
                    // Send to analysis port
                    ap_write.write(tr);
                    
                    // Clean up
                    w_trans.delete(vif.bid);
                    
                    `uvm_info("MON", $sformatf("Write Response: ID=%0h RESP=%0h", 
                             tr.bid, tr.bresp), UVM_HIGH)
                end
            end
        end
    endtask
    
    // Monitor read address channel
    task monitor_read_address_channel();
        forever begin
            @(posedge vif.aclk);
            if(vif.arvalid && vif.arready) begin
                axi4_master_tx tr = axi4_master_tx::type_id::create("ar_tr");
                tr.tx_type = READ;
                tr.arid = vif.arid;
                tr.araddr = vif.araddr;
                tr.arlen = vif.arlen;
                tr.arsize = vif.arsize;
                tr.arburst = vif.arburst;
                tr.arlock = vif.arlock;
                tr.arcache = vif.arcache;
                tr.arprot = vif.arprot;
                tr.arqos = vif.arqos;
                tr.arregion = vif.arregion;
                tr.aruser = vif.aruser;
                
                // Store for correlation
                ar_trans.push_back(tr);
                
                `uvm_info("MON", $sformatf("Read Address: ID=%0h ADDR=0x%0h LEN=%0d", 
                         tr.arid, tr.araddr, tr.arlen), UVM_HIGH)
            end
        end
    endtask
    
    // Monitor read data channel
    task monitor_read_data_channel();
        axi4_master_tx tr_queue[int][$];
        int beat_cnt[int];
        
        forever begin
            @(posedge vif.aclk);
            if(vif.rvalid && vif.rready) begin
                axi4_master_tx tr;
                
                // Find matching transaction
                if(!tr_queue.exists(vif.rid)) begin
                    // Look for new transaction
                    foreach(ar_trans[i]) begin
                        if(ar_trans[i].arid == vif.rid) begin
                            tr = ar_trans[i];
                            ar_trans.delete(i);
                            tr.rdata = new[tr.arlen + 1];
                            tr.rresp = new[tr.arlen + 1];
                            tr.rid = vif.rid;
                            tr_queue[vif.rid].push_back(tr);
                            beat_cnt[vif.rid] = 0;
                            break;
                        end
                    end
                end
                
                if(tr_queue.exists(vif.rid) && tr_queue[vif.rid].size() > 0) begin
                    tr = tr_queue[vif.rid][0];
                    int bc = beat_cnt[vif.rid];
                    
                    tr.rdata[bc] = vif.rdata;
                    tr.rresp[bc] = vif.rresp;
                    tr.ruser = vif.ruser;
                    
                    if(vif.rlast) begin
                        if(bc != tr.arlen)
                            `uvm_error("MON", $sformatf("RLAST mismatch: expected %0d, got %0d", 
                                      tr.arlen, bc))
                        
                        // Send to analysis port
                        ap_read.write(tr);
                        
                        // Clean up
                        tr_queue[vif.rid].delete(0);
                        if(tr_queue[vif.rid].size() == 0)
                            tr_queue.delete(vif.rid);
                        beat_cnt.delete(vif.rid);
                        
                        `uvm_info("MON", $sformatf("Read Complete: ID=%0h", tr.rid), UVM_HIGH)
                    end else begin
                        beat_cnt[vif.rid]++;
                    end
                end
            end
        end
    endtask
    
endclass

`endif // AXI4_MASTER_MONITOR_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "master_agent_bfm", "axi4_master_monitor_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_slave_agent_bfm(self, base_dir):
        """Generate Slave Agent BFM"""
        content = f"""//==============================================================================
// AXI4 Slave Agent BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Based on tim_axi4_vip architecture
//==============================================================================

`ifndef AXI4_SLAVE_AGENT_BFM_SV
`define AXI4_SLAVE_AGENT_BFM_SV

class axi4_slave_agent_bfm extends uvm_agent;
    `uvm_component_utils(axi4_slave_agent_bfm)
    
    // BFM Components
    axi4_slave_driver_bfm driver_bfm;
    axi4_slave_monitor_bfm monitor_bfm;
    
    // Configuration
    axi4_slave_agent_config cfg;
    
    // Memory model
    axi4_slave_memory memory;
    
    // Analysis ports
    uvm_analysis_port #(axi4_slave_tx) ap_write;
    uvm_analysis_port #(axi4_slave_tx) ap_read;
    
    // Constructor
    function new(string name = "axi4_slave_agent_bfm", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // Get configuration
        if(!uvm_config_db#(axi4_slave_agent_config)::get(this, "", "cfg", cfg))
            `uvm_fatal("CONFIG", "Cannot get axi4_slave_agent_config")
        
        // Create BFM components
        driver_bfm = axi4_slave_driver_bfm::type_id::create("driver_bfm", this);
        monitor_bfm = axi4_slave_monitor_bfm::type_id::create("monitor_bfm", this);
        
        // Create memory model if enabled
        if(cfg.memory_model_enable) begin
            memory = axi4_slave_memory::type_id::create("memory", this);
        end
        
        // Create analysis ports
        ap_write = new("ap_write", this);
        ap_read = new("ap_read", this);
    endfunction
    
    // Connect phase
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // Pass configuration
        driver_bfm.cfg = cfg;
        monitor_bfm.cfg = cfg;
        
        // Connect memory model
        if(cfg.memory_model_enable) begin
            driver_bfm.memory = memory;
        end
        
        // Connect monitor to analysis ports
        monitor_bfm.ap_write.connect(ap_write);
        monitor_bfm.ap_read.connect(ap_read);
    endfunction
    
    // BFM API Tasks
    task set_memory(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.data_width-1}:0] data
    );
        if(memory != null)
            memory.write(addr, data);
    endtask
    
    task get_memory(
        input bit [{self.config.addr_width-1}:0] addr,
        output bit [{self.config.data_width-1}:0] data
    );
        if(memory != null)
            data = memory.read(addr);
    endtask
    
    task configure_response_delay(
        input int min_delay,
        input int max_delay
    );
        driver_bfm.min_response_delay = min_delay;
        driver_bfm.max_response_delay = max_delay;
    endtask
    
    task inject_error(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [1:0] resp_type
    );
        driver_bfm.error_injection_addr = addr;
        driver_bfm.error_injection_resp = resp_type;
        driver_bfm.error_injection_enable = 1;
    endtask
    
    task set_exclusive_monitor(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.id_width-1}:0] id
    );
        driver_bfm.exclusive_monitor[addr] = id;
    endtask
    
endclass

`endif // AXI4_SLAVE_AGENT_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "slave_agent_bfm", "axi4_slave_agent_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_slave_driver_bfm(self, base_dir):
        """Generate Slave Driver BFM"""
        content = f"""//==============================================================================
// AXI4 Slave Driver BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Provides slave response generation with memory model
//==============================================================================

`ifndef AXI4_SLAVE_DRIVER_BFM_SV
`define AXI4_SLAVE_DRIVER_BFM_SV

class axi4_slave_driver_bfm extends uvm_driver #(axi4_slave_tx);
    `uvm_component_utils(axi4_slave_driver_bfm)
    
    // Virtual interface
    virtual axi4_if vif;
    
    // Configuration
    axi4_slave_agent_config cfg;
    
    // Memory handle
    axi4_slave_memory memory;
    
    // Response delays
    int min_response_delay = 0;
    int max_response_delay = 5;
    
    // Error injection
    bit error_injection_enable = 0;
    bit [{self.config.addr_width-1}:0] error_injection_addr;
    bit [1:0] error_injection_resp;
    
    // Exclusive access monitor
    bit [{self.config.id_width-1}:0] exclusive_monitor[bit [{self.config.addr_width-1}:0]];
    
    // Outstanding transaction tracking
    axi4_slave_tx aw_queue[$];
    axi4_slave_tx ar_queue[$];
    
    // Constructor
    function new(string name = "axi4_slave_driver_bfm", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        // Initialize signals
        init_signals();
        
        // Run parallel processes
        fork
            process_write_address();
            process_write_data();
            process_write_response();
            process_read_address();
            process_read_data();
        join
    endtask
    
    // Initialize signals
    task init_signals();
        vif.awready <= 1;
        vif.wready <= 1;
        vif.bvalid <= 0;
        vif.bid <= '0;
        vif.bresp <= '0;
        vif.buser <= '0;
        
        vif.arready <= 1;
        vif.rvalid <= 0;
        vif.rid <= '0;
        vif.rdata <= '0;
        vif.rresp <= '0;
        vif.rlast <= 0;
        vif.ruser <= '0;
    endtask
    
    // Process write address channel
    task process_write_address();
        forever begin
            @(posedge vif.aclk);
            if(vif.awvalid && vif.awready) begin
                axi4_slave_tx tr = axi4_slave_tx::type_id::create("aw_tr");
                tr.tx_type = WRITE;
                tr.awid = vif.awid;
                tr.awaddr = vif.awaddr;
                tr.awlen = vif.awlen;
                tr.awsize = vif.awsize;
                tr.awburst = vif.awburst;
                tr.awlock = vif.awlock;
                tr.awcache = vif.awcache;
                tr.awprot = vif.awprot;
                tr.awqos = vif.awqos;
                tr.awregion = vif.awregion;
                tr.awuser = vif.awuser;
                
                // Check access permissions
                if(!check_access_permission(tr)) begin
                    tr.bresp = cfg.secure_only ? 2'b10 : 2'b11; // SLVERR or DECERR
                end
                
                aw_queue.push_back(tr);
                
                // Apply configurable ready delay
                if(cfg.aw_wait_cycles > 0) begin
                    vif.awready <= 0;
                    repeat(cfg.aw_wait_cycles) @(posedge vif.aclk);
                    vif.awready <= 1;
                end
            end
        end
    endtask
    
    // Process write data channel
    task process_write_data();
        axi4_slave_tx tr;
        int beat_cnt = 0;
        
        forever begin
            @(posedge vif.aclk);
            if(vif.wvalid && vif.wready) begin
                if(beat_cnt == 0 && aw_queue.size() > 0) begin
                    tr = aw_queue.pop_front();
                    tr.wdata = new[tr.awlen + 1];
                    tr.wstrb = new[tr.awlen + 1];
                end
                
                if(tr != null) begin
                    tr.wdata[beat_cnt] = vif.wdata;
                    tr.wstrb[beat_cnt] = vif.wstrb;
                    
                    // Write to memory if enabled
                    if(memory != null && tr.bresp == 2'b00) begin
                        bit [{self.config.addr_width-1}:0] addr;
                        addr = calculate_address(tr.awaddr, beat_cnt, tr.awsize, tr.awburst, tr.awlen);
                        
                        // Write based on strobe
                        for(int i = 0; i < {self.config.data_width}/8; i++) begin
                            if(tr.wstrb[beat_cnt][i]) begin
                                memory.write_byte(addr + i, tr.wdata[beat_cnt][i*8 +: 8]);
                            end
                        end
                    end
                    
                    if(vif.wlast) begin
                        // Handle exclusive write
                        if(tr.awlock && exclusive_monitor.exists(tr.awaddr)) begin
                            if(exclusive_monitor[tr.awaddr] == tr.awid) begin
                                tr.bresp = 2'b01; // EXOKAY
                                exclusive_monitor.delete(tr.awaddr);
                            end else begin
                                tr.bresp = 2'b00; // OKAY (exclusive failed)
                            end
                        end
                        
                        // Queue for response
                        send_write_response(tr);
                        beat_cnt = 0;
                        tr = null;
                    end else begin
                        beat_cnt++;
                    end
                end
            end
        end
    endtask
    
    // Send write response
    task send_write_response(axi4_slave_tx tr);
        // Apply response delay
        int delay = $urandom_range(min_response_delay, max_response_delay);
        repeat(delay) @(posedge vif.aclk);
        
        // Check for error injection
        if(error_injection_enable && tr.awaddr == error_injection_addr) begin
            tr.bresp = error_injection_resp;
            error_injection_enable = 0;
        end
        
        @(posedge vif.aclk);
        vif.bid <= tr.awid;
        vif.bresp <= tr.bresp;
        vif.buser <= tr.buser;
        vif.bvalid <= 1;
        
        while(!vif.bready) @(posedge vif.aclk);
        vif.bvalid <= 0;
    endtask
    
    // Process read address channel
    task process_read_address();
        forever begin
            @(posedge vif.aclk);
            if(vif.arvalid && vif.arready) begin
                axi4_slave_tx tr = axi4_slave_tx::type_id::create("ar_tr");
                tr.tx_type = READ;
                tr.arid = vif.arid;
                tr.araddr = vif.araddr;
                tr.arlen = vif.arlen;
                tr.arsize = vif.arsize;
                tr.arburst = vif.arburst;
                tr.arlock = vif.arlock;
                tr.arcache = vif.arcache;
                tr.arprot = vif.arprot;
                tr.arqos = vif.arqos;
                tr.arregion = vif.arregion;
                tr.aruser = vif.aruser;
                
                // Check access permissions
                if(!check_access_permission(tr)) begin
                    tr.rresp = cfg.secure_only ? 2'b10 : 2'b11; // SLVERR or DECERR
                end else begin
                    tr.rresp = 2'b00; // OKAY
                end
                
                // Handle exclusive read
                if(tr.arlock && tr.rresp == 2'b00) begin
                    exclusive_monitor[tr.araddr] = tr.arid;
                end
                
                ar_queue.push_back(tr);
                
                // Process read immediately or based on response mode
                if(cfg.response_mode == IN_ORDER || ar_queue.size() == 1) begin
                    fork
                        send_read_data(tr);
                    join_none
                end
            end
        end
    endtask
    
    // Process read data responses
    task process_read_data();
        // Handle out-of-order responses if enabled
        if(cfg.response_mode != IN_ORDER) begin
            forever begin
                @(posedge vif.aclk);
                // Process queued reads based on QoS or other criteria
                if(ar_queue.size() > 0) begin
                    axi4_slave_tx tr;
                    
                    // Select transaction based on response mode
                    case(cfg.response_mode)
                        READ_OUT_OF_ORDER: begin
                            // Random selection
                            int idx = $urandom_range(0, ar_queue.size()-1);
                            tr = ar_queue[idx];
                            ar_queue.delete(idx);
                        end
                        
                        default: begin
                            tr = ar_queue.pop_front();
                        end
                    endcase
                    
                    fork
                        send_read_data(tr);
                    join_none
                end
            end
        end
    endtask
    
    // Send read data
    task send_read_data(axi4_slave_tx tr);
        // Apply initial delay
        int delay = $urandom_range(min_response_delay, max_response_delay);
        repeat(delay) @(posedge vif.aclk);
        
        // Send data beats
        for(int beat = 0; beat <= tr.arlen; beat++) begin
            bit [{self.config.addr_width-1}:0] addr;
            bit [{self.config.data_width-1}:0] data;
            
            addr = calculate_address(tr.araddr, beat, tr.arsize, tr.arburst, tr.arlen);
            
            // Read from memory or generate data
            if(memory != null && tr.rresp == 2'b00) begin
                data = memory.read(addr);
            end else begin
                // Generate random or pattern data
                case(cfg.read_data_mode)
                    RANDOM: data = $urandom();
                    USER_DATA: data = {{addr[7:0], beat[7:0]}};
                    default: data = 'hDEADBEEF;
                endcase
            end
            
            @(posedge vif.aclk);
            vif.rid <= tr.arid;
            vif.rdata <= data;
            vif.rresp <= tr.rresp;
            vif.rlast <= (beat == tr.arlen);
            vif.ruser <= tr.ruser;
            vif.rvalid <= 1;
            
            while(!vif.rready) @(posedge vif.aclk);
            vif.rvalid <= 0;
            
            // Inter-beat delay
            if(cfg.r_wait_cycles > 0 && beat < tr.arlen) begin
                repeat(cfg.r_wait_cycles) @(posedge vif.aclk);
            end
        end
    endtask
    
    // Check access permissions
    function bit check_access_permission(axi4_slave_tx tr);
        bit addr_in_range;
        bit secure_ok, priv_ok;
        
        // Check address range
        addr_in_range = (tr.tx_type == WRITE) ? 
                       (tr.awaddr >= cfg.base_address && 
                        tr.awaddr < cfg.base_address + cfg.size) :
                       (tr.araddr >= cfg.base_address && 
                        tr.araddr < cfg.base_address + cfg.size);
        
        if(!addr_in_range) return 0;
        
        // Check security
        secure_ok = !cfg.secure_only || 
                   ((tr.tx_type == WRITE ? tr.awprot[1] : tr.arprot[1]) == 0);
        
        // Check privilege
        priv_ok = !cfg.privileged_only || 
                 ((tr.tx_type == WRITE ? tr.awprot[0] : tr.arprot[0]) == 0);
        
        return secure_ok && priv_ok;
    endfunction
    
    // Calculate address for specific beat
    function bit [{self.config.addr_width-1}:0] calculate_address(
        input bit [{self.config.addr_width-1}:0] start_addr,
        input int beat,
        input bit [2:0] size,
        input bit [1:0] burst,
        input bit [7:0] len
    );
        bit [{self.config.addr_width-1}:0] addr;
        int bytes_per_beat = 1 << size;
        
        case(burst)
            2'b00: addr = start_addr; // FIXED
            2'b01: addr = start_addr + beat * bytes_per_beat; // INCR
            2'b10: begin // WRAP
                int total_bytes = (len + 1) * bytes_per_beat;
                int wrap_boundary = (start_addr / total_bytes) * total_bytes;
                addr = wrap_boundary + ((start_addr + beat * bytes_per_beat) % total_bytes);
            end
            default: addr = start_addr;
        endcase
        
        return addr;
    endfunction
    
endclass

`endif // AXI4_SLAVE_DRIVER_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "slave_agent_bfm", "axi4_slave_driver_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_slave_monitor_bfm(self, base_dir):
        """Generate Slave Monitor BFM"""
        content = f"""//==============================================================================
// AXI4 Slave Monitor BFM
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Monitors slave-side transactions
//==============================================================================

`ifndef AXI4_SLAVE_MONITOR_BFM_SV
`define AXI4_SLAVE_MONITOR_BFM_SV

class axi4_slave_monitor_bfm extends uvm_monitor;
    `uvm_component_utils(axi4_slave_monitor_bfm)
    
    // Virtual interface
    virtual axi4_if vif;
    
    // Configuration
    axi4_slave_agent_config cfg;
    
    // Analysis ports
    uvm_analysis_port #(axi4_slave_tx) ap_write;
    uvm_analysis_port #(axi4_slave_tx) ap_read;
    
    // Performance monitoring
    int total_write_latency = 0;
    int total_read_latency = 0;
    int write_count = 0;
    int read_count = 0;
    
    // Coverage
    covergroup slave_cg;
        // Address coverage
        addr_cp: coverpoint (vif.awvalid ? vif.awaddr : vif.araddr) {{
            bins low = {{[cfg.base_address : cfg.base_address + cfg.size/4]}};
            bins mid = {{[cfg.base_address + cfg.size/4 : cfg.base_address + 3*cfg.size/4]}};
            bins high = {{[cfg.base_address + 3*cfg.size/4 : cfg.base_address + cfg.size - 1]}};
        }}
        
        // Protection coverage
        prot_cp: coverpoint (vif.awvalid ? vif.awprot : vif.arprot) {{
            bins secure_priv = {{3'b000}};
            bins secure_unpriv = {{3'b001}};
            bins nonsec_priv = {{3'b010}};
            bins nonsec_unpriv = {{3'b011}};
            bins inst_access = {{3'b100, 3'b101, 3'b110, 3'b111}};
        }}
        
        // QoS coverage
        qos_cp: coverpoint (vif.awvalid ? vif.awqos : vif.arqos);
        
        // Region coverage
        region_cp: coverpoint (vif.awvalid ? vif.awregion : vif.arregion);
    endgroup
    
    // Constructor
    function new(string name = "axi4_slave_monitor_bfm", uvm_component parent = null);
        super.new(name, parent);
        ap_write = new("ap_write", this);
        ap_read = new("ap_read", this);
        slave_cg = new();
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if(!uvm_config_db#(virtual axi4_if)::get(this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        fork
            monitor_write_transactions();
            monitor_read_transactions();
            monitor_performance();
        join
    endtask
    
    // Monitor write transactions
    task monitor_write_transactions();
        axi4_slave_tx aw_queue[$];
        axi4_slave_tx w_queue[int];
        
        fork
            // Monitor write address
            forever begin
                @(posedge vif.aclk);
                if(vif.awvalid && vif.awready) begin
                    axi4_slave_tx tr = axi4_slave_tx::type_id::create("aw_tr");
                    tr.tx_type = WRITE;
                    tr.awid = vif.awid;
                    tr.awaddr = vif.awaddr;
                    tr.awlen = vif.awlen;
                    tr.awsize = vif.awsize;
                    tr.awburst = vif.awburst;
                    tr.awlock = vif.awlock;
                    tr.awcache = vif.awcache;
                    tr.awprot = vif.awprot;
                    tr.awqos = vif.awqos;
                    tr.awregion = vif.awregion;
                    tr.awuser = vif.awuser;
                    tr.start_time = $time;
                    
                    aw_queue.push_back(tr);
                    slave_cg.sample();
                end
            end
            
            // Monitor write data
            begin
                axi4_slave_tx tr;
                int beat_cnt = 0;
                
                forever begin
                    @(posedge vif.aclk);
                    if(vif.wvalid && vif.wready) begin
                        if(beat_cnt == 0 && aw_queue.size() > 0) begin
                            tr = aw_queue.pop_front();
                            tr.wdata = new[tr.awlen + 1];
                            tr.wstrb = new[tr.awlen + 1];
                        end
                        
                        if(tr != null) begin
                            tr.wdata[beat_cnt] = vif.wdata;
                            tr.wstrb[beat_cnt] = vif.wstrb;
                            
                            if(vif.wlast) begin
                                w_queue[tr.awid] = tr;
                                beat_cnt = 0;
                                tr = null;
                            end else begin
                                beat_cnt++;
                            end
                        end
                    end
                end
            end
            
            // Monitor write response
            forever begin
                @(posedge vif.aclk);
                if(vif.bvalid && vif.bready) begin
                    if(w_queue.exists(vif.bid)) begin
                        axi4_slave_tx tr = w_queue[vif.bid];
                        tr.bid = vif.bid;
                        tr.bresp = vif.bresp;
                        tr.buser = vif.buser;
                        tr.end_time = $time;
                        
                        // Calculate latency
                        tr.latency = (tr.end_time - tr.start_time) / 1ns;
                        total_write_latency += tr.latency;
                        write_count++;
                        
                        // Send to analysis port
                        ap_write.write(tr);
                        
                        // Clean up
                        w_queue.delete(vif.bid);
                        
                        `uvm_info("SMON", $sformatf("Write Complete: ID=%0h RESP=%0h Latency=%0dns", 
                                 tr.bid, tr.bresp, tr.latency), UVM_HIGH)
                    end
                end
            end
        join
    endtask
    
    // Monitor read transactions
    task monitor_read_transactions();
        axi4_slave_tx ar_queue[int];
        
        fork
            // Monitor read address
            forever begin
                @(posedge vif.aclk);
                if(vif.arvalid && vif.arready) begin
                    axi4_slave_tx tr = axi4_slave_tx::type_id::create("ar_tr");
                    tr.tx_type = READ;
                    tr.arid = vif.arid;
                    tr.araddr = vif.araddr;
                    tr.arlen = vif.arlen;
                    tr.arsize = vif.arsize;
                    tr.arburst = vif.arburst;
                    tr.arlock = vif.arlock;
                    tr.arcache = vif.arcache;
                    tr.arprot = vif.arprot;
                    tr.arqos = vif.arqos;
                    tr.arregion = vif.arregion;
                    tr.aruser = vif.aruser;
                    tr.start_time = $time;
                    
                    ar_queue[tr.arid] = tr;
                    slave_cg.sample();
                end
            end
            
            // Monitor read data
            begin
                int beat_cnt[int];
                
                forever begin
                    @(posedge vif.aclk);
                    if(vif.rvalid && vif.rready) begin
                        if(ar_queue.exists(vif.rid)) begin
                            axi4_slave_tx tr = ar_queue[vif.rid];
                            
                            if(!beat_cnt.exists(vif.rid)) begin
                                beat_cnt[vif.rid] = 0;
                                tr.rdata = new[tr.arlen + 1];
                                tr.rresp = new[tr.arlen + 1];
                            end
                            
                            int bc = beat_cnt[vif.rid];
                            tr.rdata[bc] = vif.rdata;
                            tr.rresp[bc] = vif.rresp;
                            tr.rid = vif.rid;
                            tr.ruser = vif.ruser;
                            
                            if(vif.rlast) begin
                                tr.end_time = $time;
                                tr.latency = (tr.end_time - tr.start_time) / 1ns;
                                total_read_latency += tr.latency;
                                read_count++;
                                
                                // Send to analysis port
                                ap_read.write(tr);
                                
                                // Clean up
                                ar_queue.delete(vif.rid);
                                beat_cnt.delete(vif.rid);
                                
                                `uvm_info("SMON", $sformatf("Read Complete: ID=%0h Latency=%0dns", 
                                         tr.rid, tr.latency), UVM_HIGH)
                            end else begin
                                beat_cnt[vif.rid]++;
                            end
                        end
                    end
                end
            end
        join
    endtask
    
    // Monitor performance metrics
    task monitor_performance();
        forever begin
            #10us; // Report every 10us
            
            if(write_count > 0) begin
                `uvm_info("PERF", $sformatf("Avg Write Latency: %0.2f ns", 
                         real'(total_write_latency) / write_count), UVM_MEDIUM)
            end
            
            if(read_count > 0) begin
                `uvm_info("PERF", $sformatf("Avg Read Latency: %0.2f ns", 
                         real'(total_read_latency) / read_count), UVM_MEDIUM)
            end
        end
    endtask
    
endclass

`endif // AXI4_SLAVE_MONITOR_BFM_SV
"""
        
        filepath = os.path.join(base_dir, "slave_agent_bfm", "axi4_slave_monitor_bfm.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_bfm_package(self, base_dir):
        """Generate BFM package file"""
        content = f"""//==============================================================================
// AXI4 BFM Package
// Generated by VIP BFM Generator
// Date: {self.timestamp}
// Includes all BFM components
//==============================================================================

`ifndef AXI4_BFM_PKG_SV
`define AXI4_BFM_PKG_SV

package axi4_bfm_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    // Import VIP packages
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    import axi4_slave_pkg::*;
    
    // Include BFM components
    `include "agent/master_agent_bfm/axi4_master_agent_bfm.sv"
    `include "agent/master_agent_bfm/axi4_master_driver_bfm.sv"
    `include "agent/master_agent_bfm/axi4_master_monitor_bfm.sv"
    
    `include "agent/slave_agent_bfm/axi4_slave_agent_bfm.sv"
    `include "agent/slave_agent_bfm/axi4_slave_driver_bfm.sv"
    `include "agent/slave_agent_bfm/axi4_slave_monitor_bfm.sv"
    
    // BFM Configuration class
    class axi4_bfm_config extends uvm_object;
        `uvm_object_utils(axi4_bfm_config)
        
        // Enable BFM mode
        bit bfm_mode_enable = 1;
        
        // Address filtering for BFM optimization
        bit bfm_address_filtering = 1;
        
        // Smart interconnect features
        bit smart_interconnect_enable = 1;
        bit or_based_routing = 1;
        bit race_condition_prevention = 1;
        
        // Performance optimizations
        bit parallel_processing = 1;
        int max_outstanding_transactions = 16;
        
        function new(string name = "axi4_bfm_config");
            super.new(name);
        endfunction
    endclass
    
    // BFM Factory registration
    class axi4_bfm_factory;
        static function void register_bfm_types();
            // Register BFM components with factory
            axi4_master_agent_bfm::type_id::set_type_override(axi4_master_agent::get_type());
            axi4_slave_agent_bfm::type_id::set_type_override(axi4_slave_agent::get_type());
        endfunction
    endclass
    
endpackage

`endif // AXI4_BFM_PKG_SV
"""
        
        filepath = os.path.join(base_dir, "pkg", "axi4_bfm_pkg.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def get_bfm_info(self) -> Dict:
        """Return BFM component information"""
        return {
            "components": [
                "Master Agent BFM",
                "Master Driver BFM",
                "Master Monitor BFM",
                "Slave Agent BFM",
                "Slave Driver BFM",
                "Slave Monitor BFM"
            ],
            "features": [
                "Task-based API for easy transaction generation",
                "Full protocol compliance checking",
                "4KB boundary detection",
                "Exclusive access support",
                "QoS and REGION support",
                "Performance monitoring",
                "Coverage collection",
                "Memory model integration",
                "Error injection capability",
                "Out-of-order response support"
            ],
            "api_tasks": [
                "write_burst() - Generate write burst transaction",
                "read_burst() - Generate read burst transaction",
                "write_with_qos() - Write with QoS settings",
                "exclusive_access() - Perform exclusive access",
                "set_memory() - Configure slave memory",
                "inject_error() - Inject error response",
                "configure_response_delay() - Set response delays"
            ]
        }