#!/usr/bin/env python3
"""
VIP Environment Generator following tim_axi4_vip structure
Generates a complete UVM-based AXI4 VIP environment with proper folder hierarchy
"""

import os
import json
from datetime import datetime
from dataclasses import asdict

class VIPEnvironmentGenerator:
    """Generate VIP environment following tim_axi4_vip structure"""
    
    def __init__(self, gui_config, mode, simulator="vcs"):
        self.config = gui_config
        self.mode = mode  # "rtl_integration" or "vip_standalone"
        self.simulator = simulator
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
    def generate_environment(self, output_dir):
        """Generate complete VIP environment"""
        env_name = f"axi4_vip_env_{self.mode}"
        env_path = os.path.join(output_dir, env_name)
        
        # Create tim_axi4_vip-like directory structure
        self._create_directory_structure(env_path)
        
        # Generate all files
        self._generate_package_files(env_path)
        self._generate_interface_files(env_path)
        self._generate_agent_files(env_path)
        self._generate_sequence_files(env_path)
        self._generate_environment_files(env_path)
        self._generate_test_files(env_path)
        self._generate_top_files(env_path)
        self._generate_simulation_files(env_path)
        self._generate_documentation(env_path)
        
        # For RTL integration, generate wrapper
        if self.mode == "rtl_integration":
            self._generate_rtl_wrapper(env_path)
            
        return env_path
    
    def _create_directory_structure(self, base_path):
        """Create tim_axi4_vip-like directory structure"""
        dirs = [
            # Core UVM component directories
            "agent",
            "agent/master_agent_bfm",
            "agent/slave_agent_bfm",
            "assertions",
            "bm",  # Bus matrix components
            "doc",
            "env",
            "include",
            "intf",
            "intf/axi4_interface",
            "master",
            "pkg",
            "seq",
            "seq/master_sequences",
            "seq/slave_sequences",
            "sim",
            "sim/scripts",
            "sim/results",
            "sim/logs",
            "sim/waves",
            "sim/coverage",
            "slave",
            "test",
            "testlists",
            "top",
            "virtual_seq",
            "virtual_seqr",
        ]
        
        # Add RTL-specific directories if in RTL integration mode
        if self.mode == "rtl_integration":
            dirs.extend([
                "rtl_wrapper",
                "rtl_wrapper/generated_rtl",
            ])
        
        for dir_path in dirs:
            os.makedirs(os.path.join(base_path, dir_path), exist_ok=True)
    
    def _generate_package_files(self, base_path):
        """Generate package definition files"""
        # axi4_globals_pkg.sv
        with open(os.path.join(base_path, "pkg/axi4_globals_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Global Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_globals_pkg;
    
    // Import UVM package
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    // Global parameters from GUI configuration
    parameter NO_OF_MASTERS    = {len(self.config.masters)};
    parameter NO_OF_SLAVES     = {len(self.config.slaves)};
    parameter ADDRESS_WIDTH    = {self.config.addr_width};
    parameter DATA_WIDTH       = {self.config.data_width};
    parameter ID_WIDTH         = 4;  // Default from GUI
    parameter STRB_WIDTH       = DATA_WIDTH/8;
    parameter USER_WIDTH       = 1;
    
    // Slave memory configuration
    parameter SLAVE_MEMORY_SIZE = 12288;  // 12KB default
    parameter MEMORY_WIDTH      = 8;
    parameter SLAVE_MEMORY_DEPTH = SLAVE_MEMORY_SIZE/MEMORY_WIDTH;
    
    // Transaction types
    typedef enum bit [1:0] {{
        FIXED = 2'b00,
        INCR  = 2'b01,
        WRAP  = 2'b10,
        RSVD  = 2'b11
    }} axi4_burst_type_e;
    
    // Response types
    typedef enum bit [1:0] {{
        OKAY   = 2'b00,
        EXOKAY = 2'b01,
        SLVERR = 2'b10,
        DECERR = 2'b11
    }} axi4_response_type_e;
    
    // Lock types
    typedef enum bit {{
        NORMAL    = 1'b0,
        EXCLUSIVE = 1'b1
    }} axi4_lock_type_e;
    
    // Size encoding
    typedef enum bit [2:0] {{
        SIZE_1B   = 3'b000,
        SIZE_2B   = 3'b001,
        SIZE_4B   = 3'b010,
        SIZE_8B   = 3'b011,
        SIZE_16B  = 3'b100,
        SIZE_32B  = 3'b101,
        SIZE_64B  = 3'b110,
        SIZE_128B = 3'b111
    }} axi4_size_e;
    
    // Cache encoding
    typedef struct packed {{
        bit allocate;
        bit other_allocate;
        bit modifiable;
        bit bufferable;
    }} axi4_cache_t;
    
    // Protection encoding
    typedef struct packed {{
        bit instruction;
        bit nonsecure;
        bit privileged;
    }} axi4_prot_t;
    
    // Slave configuration from GUI
    typedef struct {{
        string name;
        bit [ADDRESS_WIDTH-1:0] base_addr;
        bit [ADDRESS_WIDTH-1:0] end_addr;
        int memory_size;
    }} slave_config_t;
    
    // Master configuration from GUI
    typedef struct {{
        string name;
        int id_width;
        bit qos_support;
        bit exclusive_support;
    }} master_config_t;
    
    // Generated configurations
""")
            # Add master configurations
            f.write("    master_config_t master_configs[NO_OF_MASTERS] = '{\n")
            for i, master in enumerate(self.config.masters):
                f.write(f"        '{{\"{master.name}\", {master.id_width}, {int(master.qos_support)}, {int(master.exclusive_support)}}}")
                if i < len(self.config.masters) - 1:
                    f.write(",")
                f.write("\n")
            f.write("    };\n\n")
            
            # Add slave configurations
            f.write("    slave_config_t slave_configs[NO_OF_SLAVES] = '{\n")
            for i, slave in enumerate(self.config.slaves):
                end_addr = slave.base_address + (slave.size * 1024) - 1
                f.write(f"        '{{\"{slave.name}\", 'h{slave.base_address:X}, 'h{end_addr:X}, {slave.size * 1024}}}")
                if i < len(self.config.slaves) - 1:
                    f.write(",")
                f.write("\n")
            f.write("    };\n\n")
            
            f.write("""endpackage : axi4_globals_pkg
""")
    
    def _generate_interface_files(self, base_path):
        """Generate interface files"""
        # axi4_if.sv
        with open(os.path.join(base_path, "intf/axi4_interface/axi4_if.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Interface
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

interface axi4_if #(
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ID_WIDTH   = 4,
    parameter USER_WIDTH = 1
)(
    input logic aclk,
    input logic aresetn
);

    // Import global package
    import axi4_globals_pkg::*;
    
    // Write Address Channel
    logic [ID_WIDTH-1:0]     awid;
    logic [ADDR_WIDTH-1:0]   awaddr;
    logic [7:0]              awlen;
    logic [2:0]              awsize;
    logic [1:0]              awburst;
    logic                    awlock;
    logic [3:0]              awcache;
    logic [2:0]              awprot;
    logic [3:0]              awqos;
    logic [3:0]              awregion;
    logic [USER_WIDTH-1:0]   awuser;
    logic                    awvalid;
    logic                    awready;
    
    // Write Data Channel
    logic [DATA_WIDTH-1:0]   wdata;
    logic [STRB_WIDTH-1:0]   wstrb;
    logic                    wlast;
    logic [USER_WIDTH-1:0]   wuser;
    logic                    wvalid;
    logic                    wready;
    
    // Write Response Channel
    logic [ID_WIDTH-1:0]     bid;
    logic [1:0]              bresp;
    logic [USER_WIDTH-1:0]   buser;
    logic                    bvalid;
    logic                    bready;
    
    // Read Address Channel
    logic [ID_WIDTH-1:0]     arid;
    logic [ADDR_WIDTH-1:0]   araddr;
    logic [7:0]              arlen;
    logic [2:0]              arsize;
    logic [1:0]              arburst;
    logic                    arlock;
    logic [3:0]              arcache;
    logic [2:0]              arprot;
    logic [3:0]              arqos;
    logic [3:0]              arregion;
    logic [USER_WIDTH-1:0]   aruser;
    logic                    arvalid;
    logic                    arready;
    
    // Read Data Channel
    logic [ID_WIDTH-1:0]     rid;
    logic [DATA_WIDTH-1:0]   rdata;
    logic [1:0]              rresp;
    logic                    rlast;
    logic [USER_WIDTH-1:0]   ruser;
    logic                    rvalid;
    logic                    rready;
    
    // Modports
    modport master (
        input  aclk, aresetn,
        output awid, awaddr, awlen, awsize, awburst, awlock, awcache, awprot, awqos, awregion, awuser, awvalid,
        input  awready,
        output wdata, wstrb, wlast, wuser, wvalid,
        input  wready,
        input  bid, bresp, buser, bvalid,
        output bready,
        output arid, araddr, arlen, arsize, arburst, arlock, arcache, arprot, arqos, arregion, aruser, arvalid,
        input  arready,
        input  rid, rdata, rresp, rlast, ruser, rvalid,
        output rready
    );
    
    modport slave (
        input  aclk, aresetn,
        input  awid, awaddr, awlen, awsize, awburst, awlock, awcache, awprot, awqos, awregion, awuser, awvalid,
        output awready,
        input  wdata, wstrb, wlast, wuser, wvalid,
        output wready,
        output bid, bresp, buser, bvalid,
        input  bready,
        input  arid, araddr, arlen, arsize, arburst, arlock, arcache, arprot, arqos, arregion, aruser, arvalid,
        output arready,
        output rid, rdata, rresp, rlast, ruser, rvalid,
        input  rready
    );
    
    modport monitor (
        input aclk, aresetn,
        input awid, awaddr, awlen, awsize, awburst, awlock, awcache, awprot, awqos, awregion, awuser, awvalid, awready,
        input wdata, wstrb, wlast, wuser, wvalid, wready,
        input bid, bresp, buser, bvalid, bready,
        input arid, araddr, arlen, arsize, arburst, arlock, arcache, arprot, arqos, arregion, aruser, arvalid, arready,
        input rid, rdata, rresp, rlast, ruser, rvalid, rready
    );

endinterface : axi4_if
""")
    
    def _generate_agent_files(self, base_path):
        """Generate agent BFM files"""
        # Master agent BFM
        with open(os.path.join(base_path, "agent/master_agent_bfm/axi4_master_agent_bfm.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Agent BFM
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

interface axi4_master_agent_bfm #(
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ID_WIDTH   = 4
)(
    input aclk,
    input aresetn
);

    import axi4_globals_pkg::*;
    
    // Master driver BFM instance
    axi4_master_driver_bfm master_driver_bfm_h;
    
    // Master monitor BFM instance  
    axi4_master_monitor_bfm master_monitor_bfm_h;

endinterface : axi4_master_agent_bfm
""")
        
        # Create stub driver and monitor BFMs
        with open(os.path.join(base_path, "agent/master_agent_bfm/axi4_master_driver_bfm.sv"), "w") as f:
            f.write(f"""// Stub master driver BFM - replace with actual implementation
interface axi4_master_driver_bfm(input aclk, input aresetn);
endinterface
""")
        
        with open(os.path.join(base_path, "agent/master_agent_bfm/axi4_master_monitor_bfm.sv"), "w") as f:
            f.write(f"""// Stub master monitor BFM - replace with actual implementation
interface axi4_master_monitor_bfm(input aclk, input aresetn);
endinterface
""")
        
        # Similarly generate slave agent BFM
        with open(os.path.join(base_path, "agent/slave_agent_bfm/axi4_slave_agent_bfm.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Agent BFM
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

interface axi4_slave_agent_bfm #(
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ID_WIDTH   = 4
)(
    input aclk,
    input aresetn
);

    import axi4_globals_pkg::*;
    
    // Slave driver BFM instance
    axi4_slave_driver_bfm slave_driver_bfm_h;
    
    // Slave monitor BFM instance  
    axi4_slave_monitor_bfm slave_monitor_bfm_h;

endinterface : axi4_slave_agent_bfm
""")
        
        # Create stub slave driver and monitor BFMs
        with open(os.path.join(base_path, "agent/slave_agent_bfm/axi4_slave_driver_bfm.sv"), "w") as f:
            f.write(f"""// Stub slave driver BFM - replace with actual implementation
interface axi4_slave_driver_bfm(input aclk, input aresetn);
endinterface
""")
        
        with open(os.path.join(base_path, "agent/slave_agent_bfm/axi4_slave_monitor_bfm.sv"), "w") as f:
            f.write(f"""// Stub slave monitor BFM - replace with actual implementation  
interface axi4_slave_monitor_bfm(input aclk, input aresetn);
endinterface
""")
    
    def _generate_agent_packages(self, base_path):
        """Generate agent package files"""
        # Master package
        with open(os.path.join(base_path, "master/axi4_master_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_master_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_master_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_master_tx)
        
        // Transaction type
        typedef enum {{WRITE, READ}} tx_type_e;
        tx_type_e tx_type;
        
        // Address channel
        rand bit [ADDRESS_WIDTH-1:0] awaddr;
        rand bit [7:0] awlen;
        rand bit [2:0] awsize;
        rand bit [1:0] awburst;
        
        // Data channel
        rand bit [DATA_WIDTH-1:0] wdata[];
        
        // Read address channel  
        rand bit [ADDRESS_WIDTH-1:0] araddr;
        rand bit [7:0] arlen;
        rand bit [2:0] arsize;
        rand bit [1:0] arburst;
        
        // Read data
        bit [DATA_WIDTH-1:0] rdata[];
        bit [1:0] rresp[];
        
        function new(string name = "axi4_master_tx");
            super.new(name);
        endfunction
    endclass
    
    // Master agent config
    class axi4_master_agent_config extends uvm_object;
        `uvm_object_utils(axi4_master_agent_config)
        
        bit is_active = UVM_ACTIVE;
        
        function new(string name = "axi4_master_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_master_sequencer extends uvm_sequencer #(axi4_master_tx);
        `uvm_component_utils(axi4_master_sequencer)
        
        function new(string name = "axi4_master_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Driver class (stub)
    class axi4_master_driver extends uvm_driver #(axi4_master_tx);
        `uvm_component_utils(axi4_master_driver)
        
        function new(string name = "axi4_master_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            forever begin
                seq_item_port.get_next_item(req);
                `uvm_info(get_type_name(), "Driving transaction", UVM_MEDIUM)
                #100ns;
                seq_item_port.item_done();
            end
        endtask
    endclass
    
    // Monitor class (stub)
    class axi4_master_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_master_monitor)
        
        uvm_analysis_port #(axi4_master_tx) item_collected_port;
        
        function new(string name = "axi4_master_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
    endclass
    
    // Agent class
    class axi4_master_agent extends uvm_agent;
        `uvm_component_utils(axi4_master_agent)
        
        axi4_master_agent_config cfg;
        axi4_master_sequencer sequencer;
        axi4_master_driver driver;
        axi4_master_monitor monitor;
        
        function new(string name = "axi4_master_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_master_sequencer::type_id::create("sequencer", this);
                driver = axi4_master_driver::type_id::create("driver", this);
            end
            monitor = axi4_master_monitor::type_id::create("monitor", this);
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
            end
        endfunction
    endclass
    
endpackage : axi4_master_pkg
""")
        
        # Slave package
        with open(os.path.join(base_path, "slave/axi4_slave_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Package  
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_slave_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_slave_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_slave_tx)
        
        // Response fields
        rand bit [1:0] bresp;
        rand bit [1:0] rresp;
        
        function new(string name = "axi4_slave_tx");
            super.new(name);
        endfunction
    endclass
    
    // Slave agent config
    class axi4_slave_agent_config extends uvm_object;
        `uvm_object_utils(axi4_slave_agent_config)
        
        bit is_active = UVM_ACTIVE;
        bit slave_memory_mode_enable = 1;
        
        function new(string name = "axi4_slave_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_slave_sequencer extends uvm_sequencer #(axi4_slave_tx);
        `uvm_component_utils(axi4_slave_sequencer)
        
        function new(string name = "axi4_slave_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Driver class (stub)
    class axi4_slave_driver extends uvm_driver #(axi4_slave_tx);
        `uvm_component_utils(axi4_slave_driver)
        
        function new(string name = "axi4_slave_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            forever begin
                seq_item_port.get_next_item(req);
                `uvm_info(get_type_name(), "Driving response", UVM_MEDIUM)
                #100ns;
                seq_item_port.item_done();
            end
        endtask
    endclass
    
    // Monitor class (stub)
    class axi4_slave_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_slave_monitor)
        
        uvm_analysis_port #(axi4_slave_tx) item_collected_port;
        
        function new(string name = "axi4_slave_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
    endclass
    
    // Agent class
    class axi4_slave_agent extends uvm_agent;
        `uvm_component_utils(axi4_slave_agent)
        
        axi4_slave_agent_config cfg;
        axi4_slave_sequencer sequencer;
        axi4_slave_driver driver;
        axi4_slave_monitor monitor;
        
        function new(string name = "axi4_slave_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_slave_sequencer::type_id::create("sequencer", this);
                driver = axi4_slave_driver::type_id::create("driver", this);
            end
            monitor = axi4_slave_monitor::type_id::create("monitor", this);
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
            end
        endfunction
    endclass
    
endpackage : axi4_slave_pkg
""")
        
        # Create sequence packages
        with open(os.path.join(base_path, "seq/master_sequences/axi4_master_seq_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Sequence Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_master_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    
    // Include sequence files
    `include "axi4_master_base_seq.sv"
    `include "axi4_master_write_seq.sv"
    `include "axi4_master_read_seq.sv"
    
endpackage : axi4_master_seq_pkg
""")
        
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_seq_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Sequence Package
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: {self.timestamp}
//==============================================================================

package axi4_slave_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_slave_pkg::*;
    
    // Include sequence files
    `include "axi4_slave_base_seq.sv"
    
endpackage : axi4_slave_seq_pkg
""")
    
    def _generate_sequence_files(self, base_path):
        """Generate basic sequence files"""
        # First create the master and slave packages needed for sequences
        self._generate_agent_packages(base_path)
        
        # Master base sequence
        with open(os.path.join(base_path, "seq/master_sequences/axi4_master_base_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Base Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_master_base_seq extends uvm_sequence #(axi4_master_tx);
    
    `uvm_object_utils(axi4_master_base_seq)
    
    // Number of transactions
    int num_trans = 1;
    
    // Constructor
    function new(string name = "axi4_master_base_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        `uvm_info(get_type_name(), "Starting base sequence", UVM_MEDIUM)
    endtask : body
    
endclass : axi4_master_base_seq
""")
        
        # Master write sequence
        with open(os.path.join(base_path, "seq/master_sequences/axi4_master_write_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Write Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_master_write_seq extends axi4_master_base_seq;
    
    `uvm_object_utils(axi4_master_write_seq)
    
    // Constructor
    function new(string name = "axi4_master_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_tx tx;
        
        repeat(num_trans) begin
            `uvm_do_with(tx, {{
                tx.tx_type == WRITE;
                tx.awburst == INCR;
                tx.awsize == SIZE_4B;
                tx.awlen == 0;  // Single beat
            }})
        end
    endtask : body
    
endclass : axi4_master_write_seq
""")
        
        # Master read sequence
        with open(os.path.join(base_path, "seq/master_sequences/axi4_master_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Master Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_master_read_seq extends axi4_master_base_seq;
    
    `uvm_object_utils(axi4_master_read_seq)
    
    // Constructor
    function new(string name = "axi4_master_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_tx tx;
        
        repeat(num_trans) begin
            `uvm_do_with(tx, {{
                tx.tx_type == READ;
                tx.arburst == INCR;
                tx.arsize == SIZE_4B;
                tx.arlen == 0;  // Single beat
            }})
        end
    endtask : body
    
endclass : axi4_master_read_seq
""")
        
        # Slave base sequence
        with open(os.path.join(base_path, "seq/slave_sequences/axi4_slave_base_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Slave Base Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_slave_base_seq extends uvm_sequence #(axi4_slave_tx);
    
    `uvm_object_utils(axi4_slave_base_seq)
    
    // Constructor
    function new(string name = "axi4_slave_base_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        `uvm_info(get_type_name(), "Starting slave base sequence", UVM_MEDIUM)
    endtask : body
    
endclass : axi4_slave_base_seq
""")
    
    def _generate_virtual_components(self, base_path):
        """Generate virtual sequencer and sequence components"""
        # Virtual sequencer
        with open(os.path.join(base_path, "virtual_seqr/axi4_virtual_sequencer.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Sequencer
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_sequencer extends uvm_sequencer;
    
    `uvm_component_utils(axi4_virtual_sequencer)
    
    // Master sequencers
    axi4_master_sequencer master_seqr[{len(self.config.masters)}];
    
    // Slave sequencers
    axi4_slave_sequencer slave_seqr[{len(self.config.slaves)}];
    
    // Constructor
    function new(string name = "axi4_virtual_sequencer", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
endclass : axi4_virtual_sequencer
""")
        
        # Virtual sequence package
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_seq_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Sequence Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_virtual_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    import axi4_slave_pkg::*;
    import axi4_master_seq_pkg::*;
    import axi4_slave_seq_pkg::*;
    
    // Forward declaration of virtual sequencer
    typedef class axi4_virtual_sequencer;
    
    // Include virtual sequence files
    `include "axi4_virtual_base_seq.sv"
    `include "axi4_virtual_write_seq.sv"
    `include "axi4_virtual_read_seq.sv"
    `include "axi4_virtual_write_read_seq.sv"
    
endpackage : axi4_virtual_seq_pkg
""")
        
        # Virtual base sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_base_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Base Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_base_seq extends uvm_sequence;
    
    `uvm_object_utils(axi4_virtual_base_seq)
    `uvm_declare_p_sequencer(axi4_virtual_sequencer)
    
    // Constructor
    function new(string name = "axi4_virtual_base_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        `uvm_info(get_type_name(), "Starting virtual base sequence", UVM_MEDIUM)
    endtask : body
    
endclass : axi4_virtual_base_seq
""")
        
        # Virtual write sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Starting virtual write sequence", UVM_MEDIUM)
        
        // Run write sequence on master 0
        write_seq = axi4_master_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer.master_seqr[0]);
        
    endtask : body
    
endclass : axi4_virtual_write_seq
""")
        
        # Virtual read sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Starting virtual read sequence", UVM_MEDIUM)
        
        // Run read sequence on master 0
        read_seq = axi4_master_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer.master_seqr[0]);
        
    endtask : body
    
endclass : axi4_virtual_read_seq
""")
        
        # Virtual write-read sequence
        with open(os.path.join(base_path, "virtual_seq/axi4_virtual_write_read_seq.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Virtual Write-Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_virtual_write_read_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_write_read_seq)
    
    // Constructor
    function new(string name = "axi4_virtual_write_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_virtual_write_seq write_seq;
        axi4_virtual_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Starting virtual write-read sequence", UVM_MEDIUM)
        
        // Run write sequence
        write_seq = axi4_virtual_write_seq::type_id::create("write_seq");
        write_seq.start(p_sequencer);
        
        // Run read sequence
        read_seq = axi4_virtual_read_seq::type_id::create("read_seq");
        read_seq.start(p_sequencer);
        
    endtask : body
    
endclass : axi4_virtual_write_read_seq
""")
    
    def _generate_environment_files(self, base_path):
        """Generate environment files"""
        # First generate virtual sequencer and sequence packages
        self._generate_virtual_components(base_path)
        
        # Generate environment package
        with open(os.path.join(base_path, "env/axi4_env_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Environment Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_env_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    import axi4_slave_pkg::*;
    
    // Include environment files
    `include "axi4_env_config.sv"
    `include "axi4_scoreboard.sv"
    `include "axi4_protocol_coverage.sv"
    `include "axi4_env.sv"
    
endpackage : axi4_env_pkg
""")
        
        # Environment configuration
        with open(os.path.join(base_path, "env/axi4_env_config.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Environment Configuration
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_env_config extends uvm_object;
    
    `uvm_object_utils(axi4_env_config)
    
    // Number of masters and slaves
    int no_of_masters = {len(self.config.masters)};
    int no_of_slaves = {len(self.config.slaves)};
    
    // Agent configurations
    axi4_master_agent_config master_cfg[{len(self.config.masters)}];
    axi4_slave_agent_config slave_cfg[{len(self.config.slaves)}];
    
    // Coverage enable
    bit has_coverage = 1;
    
    // Scoreboard enable
    bit has_scoreboard = 1;
    
    // Constructor
    function new(string name = "axi4_env_config");
        super.new(name);
        
        // Create agent configurations
        foreach(master_cfg[i]) begin
            master_cfg[i] = axi4_master_agent_config::type_id::create($sformatf("master_cfg[%0d]", i));
        end
        
        foreach(slave_cfg[i]) begin
            slave_cfg[i] = axi4_slave_agent_config::type_id::create($sformatf("slave_cfg[%0d]", i));
        end
    endfunction
    
endclass : axi4_env_config
""")
        
        # Environment class
        with open(os.path.join(base_path, "env/axi4_env.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Environment
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_env extends uvm_env;
    
    `uvm_component_utils(axi4_env)
    
    // Environment configuration
    axi4_env_config env_cfg;
    
    // Master agents
    axi4_master_agent master_agent[{len(self.config.masters)}];
    
    // Slave agents
    axi4_slave_agent slave_agent[{len(self.config.slaves)}];
    
    // Virtual sequencer
    axi4_virtual_sequencer v_seqr;
    
    // Scoreboard
    axi4_scoreboard scoreboard;
    
    // Coverage
    axi4_protocol_coverage coverage;
    
    // Constructor
    function new(string name = "axi4_env", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // Get configuration
        if(!uvm_config_db#(axi4_env_config)::get(this, "", "env_cfg", env_cfg))
            `uvm_fatal("CONFIG", "Cannot get env_cfg from uvm_config_db")
        
        // Create agents
        foreach(master_agent[i]) begin
            master_agent[i] = axi4_master_agent::type_id::create($sformatf("master_agent[%0d]", i), this);
            uvm_config_db#(axi4_master_agent_config)::set(this, $sformatf("master_agent[%0d]*", i), "cfg", env_cfg.master_cfg[i]);
        end
        
        foreach(slave_agent[i]) begin
            slave_agent[i] = axi4_slave_agent::type_id::create($sformatf("slave_agent[%0d]", i), this);
            uvm_config_db#(axi4_slave_agent_config)::set(this, $sformatf("slave_agent[%0d]*", i), "cfg", env_cfg.slave_cfg[i]);
        end
        
        // Create virtual sequencer
        v_seqr = axi4_virtual_sequencer::type_id::create("v_seqr", this);
        
        // Create scoreboard if enabled
        if(env_cfg.has_scoreboard) begin
            scoreboard = axi4_scoreboard::type_id::create("scoreboard", this);
        end
        
        // Create coverage if enabled
        if(env_cfg.has_coverage) begin
            coverage = axi4_protocol_coverage::type_id::create("coverage", this);
        end
    endfunction
    
    // Connect phase
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // Connect sequencers to virtual sequencer
        foreach(master_agent[i]) begin
            v_seqr.master_seqr[i] = master_agent[i].sequencer;
        end
        
        foreach(slave_agent[i]) begin
            v_seqr.slave_seqr[i] = slave_agent[i].sequencer;
        end
        
        // Connect monitors to scoreboard
        if(env_cfg.has_scoreboard) begin
            foreach(master_agent[i]) begin
                master_agent[i].monitor.item_collected_port.connect(scoreboard.master_fifo[i].analysis_export);
            end
            
            foreach(slave_agent[i]) begin
                slave_agent[i].monitor.item_collected_port.connect(scoreboard.slave_fifo[i].analysis_export);
            end
        end
    endfunction
    
endclass : axi4_env
""")
        
        # Generate stub scoreboard
        with open(os.path.join(base_path, "env/axi4_scoreboard.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Scoreboard (Stub)
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_scoreboard extends uvm_scoreboard;
    
    `uvm_component_utils(axi4_scoreboard)
    
    // Analysis fifos for masters and slaves
    uvm_analysis_fifo #(axi4_master_tx) master_fifo[{len(self.config.masters)}];
    uvm_analysis_fifo #(axi4_slave_tx) slave_fifo[{len(self.config.slaves)}];
    
    // Constructor
    function new(string name = "axi4_scoreboard", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        foreach(master_fifo[i]) begin
            master_fifo[i] = new($sformatf("master_fifo[%0d]", i), this);
        end
        
        foreach(slave_fifo[i]) begin
            slave_fifo[i] = new($sformatf("slave_fifo[%0d]", i), this);
        end
    endfunction
    
endclass : axi4_scoreboard
""")
        
        # Generate stub protocol coverage
        with open(os.path.join(base_path, "env/axi4_protocol_coverage.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Protocol Coverage (Stub)
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_protocol_coverage extends uvm_component;
    
    `uvm_component_utils(axi4_protocol_coverage)
    
    // Constructor
    function new(string name = "axi4_protocol_coverage", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        `uvm_info(get_type_name(), "Protocol coverage build phase", UVM_MEDIUM)
    endfunction
    
endclass : axi4_protocol_coverage
""")
    
    def _generate_test_files(self, base_path):
        """Generate test files"""
        # Test package
        with open(os.path.join(base_path, "test/axi4_test_pkg.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Test Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

package axi4_test_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    import axi4_slave_pkg::*;
    import axi4_master_seq_pkg::*;
    import axi4_slave_seq_pkg::*;
    import axi4_virtual_seq_pkg::*;
    import axi4_env_pkg::*;
    
    // Include test files
    `include "axi4_base_test.sv"
    `include "axi4_basic_rw_test.sv"
    
endpackage : axi4_test_pkg
""")
        
        # Base test
        with open(os.path.join(base_path, "test/axi4_base_test.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Base Test
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_base_test extends uvm_test;
    
    `uvm_component_utils(axi4_base_test)
    
    // Environment instance
    axi4_env env;
    
    // Environment configuration
    axi4_env_config env_cfg;
    
    // Constructor
    function new(string name = "axi4_base_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Build phase
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // Create environment configuration
        env_cfg = axi4_env_config::type_id::create("env_cfg");
        
        // Set configuration
        uvm_config_db#(axi4_env_config)::set(this, "env*", "env_cfg", env_cfg);
        
        // Create environment
        env = axi4_env::type_id::create("env", this);
    endfunction
    
    // End of elaboration phase
    function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        uvm_top.print_topology();
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        `uvm_info(get_type_name(), "Starting base test", UVM_LOW)
        
        // Add test logic here
        #100ns;
        
        `uvm_info(get_type_name(), "Ending base test", UVM_LOW)
        phase.drop_objection(this);
    endtask
    
endclass : axi4_base_test
""")
        
        # Basic read/write test
        with open(os.path.join(base_path, "test/axi4_basic_rw_test.sv"), "w") as f:
            f.write(f"""//==============================================================================
// AXI4 Basic Read/Write Test
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

class axi4_basic_rw_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_basic_rw_test)
    
    // Virtual sequence
    axi4_virtual_write_read_seq vseq;
    
    // Constructor
    function new(string name = "axi4_basic_rw_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    // Run phase
    task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting basic read/write test", UVM_LOW)
        
        // Create and start virtual sequence
        vseq = axi4_virtual_write_read_seq::type_id::create("vseq");
        vseq.start(env.v_seqr);
        
        `uvm_info(get_type_name(), "Completed basic read/write test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_basic_rw_test
""")
    
    def _generate_top_files(self, base_path):
        """Generate top-level files"""
        # HDL top
        with open(os.path.join(base_path, "top/hdl_top.sv"), "w") as f:
            f.write(f"""//==============================================================================
// HDL Top Module
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

module hdl_top;
    
    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Clock and reset
    logic aclk;
    logic aresetn;
    
    // Clock generation
    initial begin
        aclk = 0;
        forever #5ns aclk = ~aclk;
    end
    
    // Reset generation
    initial begin
        aresetn = 0;
        repeat(10) @(posedge aclk);
        aresetn = 1;
    end
    
    // AXI4 interfaces
    axi4_if axi_if[NO_OF_MASTERS](aclk, aresetn);
    
    // Master agent BFMs
    axi4_master_agent_bfm master_bfm[NO_OF_MASTERS](aclk, aresetn);
    
    // Slave agent BFMs
    axi4_slave_agent_bfm slave_bfm[NO_OF_SLAVES](aclk, aresetn);
    
""")
            if self.mode == "rtl_integration":
                f.write("""    // RTL DUT instance
    dut_wrapper #(
        .ADDR_WIDTH(ADDRESS_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH)
    ) dut (
        .clk(aclk),
        .rst_n(aresetn),
        .axi_if(axi_if[0])  // Connect to first master interface
    );
    
""")
            else:
                f.write("""    // Direct connection for standalone mode
    // Connect masters to slaves through interconnect logic
    
""")
            
            f.write("""endmodule : hdl_top
""")
        
        # HVL top
        with open(os.path.join(base_path, "top/hvl_top.sv"), "w") as f:
            f.write(f"""//==============================================================================
// HVL Top Module
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
//==============================================================================

module hvl_top;
    
    import uvm_pkg::*;
    import axi4_test_pkg::*;
    
    initial begin
        // Run UVM test
        run_test();
    end
    
endmodule : hvl_top
""")
    
    def _generate_simulation_files(self, base_path):
        """Generate simulation scripts and makefiles"""
        # Main Makefile
        with open(os.path.join(base_path, "sim/Makefile"), "w") as f:
            f.write(f"""#==============================================================================
# Makefile for AXI4 VIP Simulation
# Generated by AMBA Bus Matrix Configuration Tool
# Date: {self.timestamp}
#==============================================================================

# Default simulator
SIM ?= {self.simulator}

# Test name
TEST ?= axi4_base_test

# Random seed
SEED ?= 1

# Directories
VIP_ROOT = ..
SIM_DIR = .
SCRIPT_DIR = $(SIM_DIR)/scripts
LOG_DIR = $(SIM_DIR)/logs
WAVE_DIR = $(SIM_DIR)/waves
COV_DIR = $(SIM_DIR)/coverage

# Export VIP_ROOT for use in compile file
export VIP_ROOT

# Create directories
$(shell mkdir -p $(LOG_DIR) $(WAVE_DIR) $(COV_DIR))

# Common compile options
COMMON_OPTS = +define+UVM_NO_DEPRECATED +define+UVM_OBJECT_MUST_HAVE_CONSTRUCTOR

# VCS options
VCS_COMP_OPTS = -full64 -sverilog -ntb_opts uvm-1.2 -timescale=1ns/1ps
VCS_COMP_OPTS += -debug_access+all +vcs+lic+wait
VCS_COMP_OPTS += $(COMMON_OPTS)

VCS_RUN_OPTS = +UVM_TESTNAME=$(TEST) +UVM_VERBOSITY=UVM_MEDIUM
VCS_RUN_OPTS += +ntb_random_seed=$(SEED)

# Questa options
QUESTA_COMP_OPTS = -64 -sv -mfcu -cuname design_cuname
QUESTA_COMP_OPTS += +define+QUESTA
QUESTA_COMP_OPTS += $(COMMON_OPTS)

QUESTA_RUN_OPTS = +UVM_TESTNAME=$(TEST) +UVM_VERBOSITY=UVM_MEDIUM
QUESTA_RUN_OPTS += -sv_seed $(SEED)

# Targets
.PHONY: all compile run clean

all: run

compile:
ifeq ($(SIM), vcs)
\tVIP_ROOT=$(VIP_ROOT) vcs $(VCS_COMP_OPTS) -f $(VIP_ROOT)/sim/axi4_compile.f -l $(LOG_DIR)/compile.log
else ifeq ($(SIM), questa)
\tVIP_ROOT=$(VIP_ROOT) vlog $(QUESTA_COMP_OPTS) -f $(VIP_ROOT)/sim/axi4_compile.f -l $(LOG_DIR)/compile.log
endif

run: compile
ifeq ($(SIM), vcs)
\t./simv $(VCS_RUN_OPTS) -l $(LOG_DIR)/$(TEST)_$(SEED).log
else ifeq ($(SIM), questa)
\tvsim -c design_cuname.hvl_top design_cuname.hdl_top $(QUESTA_RUN_OPTS) -do "run -all; quit" -l $(LOG_DIR)/$(TEST)_$(SEED).log
endif

clean:
\trm -rf csrc simv* *.log ucli.key
\trm -rf work transcript vsim.wlf
\trm -rf $(LOG_DIR)/* $(WAVE_DIR)/* $(COV_DIR)/*

help:
\t@echo "Usage: make [target] [options]"
\t@echo "Targets:"
\t@echo "  compile - Compile the design"
\t@echo "  run     - Compile and run simulation"
\t@echo "  clean   - Clean simulation files"
\t@echo "Options:"
\t@echo "  SIM={self.simulator}    - Simulator (vcs, questa)"
\t@echo "  TEST=test_name  - Test to run"
\t@echo "  SEED=value      - Random seed"
""")
        
        # Compile filelist
        with open(os.path.join(base_path, "sim/axi4_compile.f"), "w") as f:
            f.write(f"""#==============================================================================
# Compile File List
# Generated by AMBA Bus Matrix Configuration Tool
# Date: {self.timestamp}
#==============================================================================

# Include directories
+incdir+${{VIP_ROOT}}/include
+incdir+${{VIP_ROOT}}/intf
+incdir+${{VIP_ROOT}}/master
+incdir+${{VIP_ROOT}}/slave
+incdir+${{VIP_ROOT}}/seq/master_sequences
+incdir+${{VIP_ROOT}}/seq/slave_sequences
+incdir+${{VIP_ROOT}}/env
+incdir+${{VIP_ROOT}}/test

# Package files (order matters)
${{VIP_ROOT}}/pkg/axi4_globals_pkg.sv

# Interface
${{VIP_ROOT}}/intf/axi4_interface/axi4_if.sv

# Agent BFMs
${{VIP_ROOT}}/agent/master_agent_bfm/axi4_master_agent_bfm.sv
${{VIP_ROOT}}/agent/slave_agent_bfm/axi4_slave_agent_bfm.sv

# Master package and components
${{VIP_ROOT}}/master/axi4_master_pkg.sv

# Slave package and components
${{VIP_ROOT}}/slave/axi4_slave_pkg.sv

# Sequence packages
${{VIP_ROOT}}/seq/master_sequences/axi4_master_seq_pkg.sv
${{VIP_ROOT}}/seq/slave_sequences/axi4_slave_seq_pkg.sv

# Virtual sequencer and sequences
${{VIP_ROOT}}/virtual_seqr/axi4_virtual_sequencer.sv
${{VIP_ROOT}}/virtual_seq/axi4_virtual_seq_pkg.sv

# Environment package and components
${{VIP_ROOT}}/env/axi4_env_pkg.sv
${{VIP_ROOT}}/env/axi4_env_config.sv
${{VIP_ROOT}}/env/axi4_env.sv

# Test package and tests
${{VIP_ROOT}}/test/axi4_test_pkg.sv
${{VIP_ROOT}}/test/axi4_base_test.sv
${{VIP_ROOT}}/test/axi4_basic_rw_test.sv

""")
            if self.mode == "rtl_integration":
                f.write("""# RTL wrapper
${VIP_ROOT}/rtl_wrapper/dut_wrapper.sv

# Generated RTL (if applicable)
-f ${VIP_ROOT}/rtl_wrapper/rtl_files.f

""")
            f.write("""# Top modules
${VIP_ROOT}/top/hdl_top.sv
${VIP_ROOT}/top/hvl_top.sv
""")
    
    def _generate_documentation(self, base_path):
        """Generate documentation"""
        # README
        with open(os.path.join(base_path, "doc/README.md"), "w") as f:
            f.write(f"""# AXI4 VIP Environment

Generated by AMBA Bus Matrix Configuration Tool  
Date: {self.timestamp}

## Overview

This is a complete UVM-based AXI4 Verification IP environment following the tim_axi4_vip structure.

### Configuration
- Mode: {self.mode.replace('_', ' ').title()}
- Masters: {len(self.config.masters)}
- Slaves: {len(self.config.slaves)}
- Data Width: {self.config.data_width} bits
- Address Width: {self.config.addr_width} bits

### Directory Structure
```
├── agent/              # BFM agents
├── assertions/         # Protocol assertions
├── doc/                # Documentation
├── env/                # Environment components
├── include/            # Common includes
├── intf/               # Interface definitions
├── master/             # Master agent components
├── pkg/                # Package definitions
├── seq/                # Sequences
├── sim/                # Simulation scripts
├── slave/              # Slave agent components
├── test/               # Test cases
├── top/                # Top-level modules
├── virtual_seq/        # Virtual sequences
└── virtual_seqr/       # Virtual sequencer
```

## Quick Start

### 1. Compile and Run
```bash
cd sim
make run TEST=axi4_base_test
```

### 2. Run with Different Simulator
```bash
make run SIM=questa TEST=axi4_basic_rw_test
```

### 3. Run with Random Seed
```bash
make run TEST=axi4_basic_rw_test SEED=12345
```

## Available Tests

- `axi4_base_test` - Basic infrastructure test
- `axi4_basic_rw_test` - Simple read/write test

## Master Configuration
""")
            for i, master in enumerate(self.config.masters):
                f.write(f"""
### Master {i}: {master.name}
- ID Width: {master.id_width}
- QoS Support: {master.qos_support}
- Exclusive Support: {master.exclusive_support}
""")
            
            f.write("\n## Slave Configuration\n")
            for i, slave in enumerate(self.config.slaves):
                f.write(f"""
### Slave {i}: {slave.name}
- Base Address: 0x{slave.base_address:08X}
- Size: {slave.size} KB
- End Address: 0x{slave.get_end_address():08X}
""")
    
    def _generate_rtl_wrapper(self, base_path):
        """Generate RTL wrapper for integration mode"""
        if self.mode != "rtl_integration":
            return
            
        # Create wrapper following the enhanced multi-master/slave support
        wrapper_content = self._get_enhanced_rtl_wrapper()
        with open(os.path.join(base_path, "rtl_wrapper/dut_wrapper.sv"), "w") as f:
            f.write(wrapper_content)
            
        # Create RTL filelist - always create it to avoid file not found errors
        rtl_filelist_path = os.path.join(base_path, "rtl_wrapper/rtl_files.f")
        with open(rtl_filelist_path, "w") as f:
            f.write("""# RTL files to include
# Add your RTL files here or they will be auto-populated if using tool-generated RTL

# Example:
# ${VIP_ROOT}/rtl_wrapper/generated_rtl/axi4_interconnect.v
# ${VIP_ROOT}/rtl_wrapper/generated_rtl/axi4_address_decoder.v
# ${VIP_ROOT}/rtl_wrapper/generated_rtl/axi4_arbiter.v
# ${VIP_ROOT}/rtl_wrapper/generated_rtl/axi4_router.v

# Placeholder to avoid empty file issues
# Remove this comment when adding actual RTL files
""")
    
    def _get_enhanced_rtl_wrapper(self):
        """Get enhanced RTL wrapper with multi-master/slave support"""
        num_masters = len(self.config.masters)
        num_slaves = len(self.config.slaves)
        
        return f"""//==============================================================================
// DUT Wrapper for RTL Integration
// Generated by AMBA Bus Matrix Configuration Tool
// Date: {self.timestamp}
// Supports {num_masters} masters and {num_slaves} slaves
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = {self.config.addr_width},
    parameter DATA_WIDTH = {self.config.data_width},
    parameter ID_WIDTH   = 4
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave axi_if  // VIP connects as master to this slave interface
);

    // Internal signals for all masters
""" + self._generate_master_signals() + """
    
    // Internal signals for all slaves  
""" + self._generate_slave_signals() + """

    // Instantiate the generated interconnect
    axi4_interconnect_m{num_masters}s{num_slaves} #(
        .DATA_WIDTH(DATA_WIDTH),
        .ADDR_WIDTH(ADDR_WIDTH),
        .ID_WIDTH(ID_WIDTH)
    ) generated_interconnect (
        .aclk(clk),
        .aresetn(rst_n),
        
""" + self._generate_master_connections() + ("," if len(self.config.slaves) > 0 else "") + """
        
""" + self._generate_slave_connections() + """
    );
    
    // Connect VIP to Master 0
    assign m0_awid    = axi_if.awid;
    assign m0_awaddr  = axi_if.awaddr;
    assign m0_awlen   = axi_if.awlen;
    assign m0_awsize  = axi_if.awsize;
    assign m0_awburst = axi_if.awburst;
    assign m0_awlock  = axi_if.awlock;
    assign m0_awcache = axi_if.awcache;
    assign m0_awprot  = axi_if.awprot;
    assign m0_awvalid = axi_if.awvalid;
    assign axi_if.awready = m0_awready;
    
    assign m0_wdata  = axi_if.wdata;
    assign m0_wstrb  = axi_if.wstrb;
    assign m0_wlast  = axi_if.wlast;
    assign m0_wvalid = axi_if.wvalid;
    assign axi_if.wready = m0_wready;
    
    assign axi_if.bid    = m0_bid;
    assign axi_if.bresp  = m0_bresp;
    assign axi_if.bvalid = m0_bvalid;
    assign m0_bready = axi_if.bready;
    
    assign m0_arid    = axi_if.arid;
    assign m0_araddr  = axi_if.araddr;
    assign m0_arlen   = axi_if.arlen;
    assign m0_arsize  = axi_if.arsize;
    assign m0_arburst = axi_if.arburst;
    assign m0_arlock  = axi_if.arlock;
    assign m0_arcache = axi_if.arcache;
    assign m0_arprot  = axi_if.arprot;
    assign m0_arvalid = axi_if.arvalid;
    assign axi_if.arready = m0_arready;
    
    assign axi_if.rid    = m0_rid;
    assign axi_if.rdata  = m0_rdata;
    assign axi_if.rresp  = m0_rresp;
    assign axi_if.rlast  = m0_rlast;
    assign axi_if.rvalid = m0_rvalid;
    assign m0_rready = axi_if.rready;
    
""" + self._generate_master_termination() + """
    
""" + self._generate_slave_responses() + """

endmodule : dut_wrapper
"""
    
    def _generate_master_signals(self):
        """Generate signal declarations for all masters"""
        signals = []
        for i in range(len(self.config.masters)):
            signals.append(f"""    // Master {i} signals
    logic [ID_WIDTH-1:0]     m{i}_awid;
    logic [ADDR_WIDTH-1:0]   m{i}_awaddr;
    logic [7:0]              m{i}_awlen;
    logic [2:0]              m{i}_awsize;
    logic [1:0]              m{i}_awburst;
    logic                    m{i}_awlock;
    logic [3:0]              m{i}_awcache;
    logic [2:0]              m{i}_awprot;
    logic                    m{i}_awvalid;
    logic                    m{i}_awready;
    
    logic [DATA_WIDTH-1:0]   m{i}_wdata;
    logic [DATA_WIDTH/8-1:0] m{i}_wstrb;
    logic                    m{i}_wlast;
    logic                    m{i}_wvalid;
    logic                    m{i}_wready;
    
    logic [ID_WIDTH-1:0]     m{i}_bid;
    logic [1:0]              m{i}_bresp;
    logic                    m{i}_bvalid;
    logic                    m{i}_bready;
    
    logic [ID_WIDTH-1:0]     m{i}_arid;
    logic [ADDR_WIDTH-1:0]   m{i}_araddr;
    logic [7:0]              m{i}_arlen;
    logic [2:0]              m{i}_arsize;
    logic [1:0]              m{i}_arburst;
    logic                    m{i}_arlock;
    logic [3:0]              m{i}_arcache;
    logic [2:0]              m{i}_arprot;
    logic                    m{i}_arvalid;
    logic                    m{i}_arready;
    
    logic [ID_WIDTH-1:0]     m{i}_rid;
    logic [DATA_WIDTH-1:0]   m{i}_rdata;
    logic [1:0]              m{i}_rresp;
    logic                    m{i}_rlast;
    logic                    m{i}_rvalid;
    logic                    m{i}_rready;
""")
        return "\n".join(signals)
    
    def _generate_slave_signals(self):
        """Generate signal declarations for all slaves"""
        signals = []
        for i in range(len(self.config.slaves)):
            signals.append(f"""    // Slave {i} signals
    logic [ID_WIDTH-1:0]     s{i}_awid;
    logic [ADDR_WIDTH-1:0]   s{i}_awaddr;
    logic [7:0]              s{i}_awlen;
    logic [2:0]              s{i}_awsize;
    logic [1:0]              s{i}_awburst;
    logic                    s{i}_awlock;
    logic [3:0]              s{i}_awcache;
    logic [2:0]              s{i}_awprot;
    logic                    s{i}_awvalid;
    logic                    s{i}_awready;
    
    logic [DATA_WIDTH-1:0]   s{i}_wdata;
    logic [DATA_WIDTH/8-1:0] s{i}_wstrb;
    logic                    s{i}_wlast;
    logic                    s{i}_wvalid;
    logic                    s{i}_wready;
    
    logic [ID_WIDTH-1:0]     s{i}_bid;
    logic [1:0]              s{i}_bresp;
    logic                    s{i}_bvalid;
    logic                    s{i}_bready;
    
    logic [ID_WIDTH-1:0]     s{i}_arid;
    logic [ADDR_WIDTH-1:0]   s{i}_araddr;
    logic [7:0]              s{i}_arlen;
    logic [2:0]              s{i}_arsize;
    logic [1:0]              s{i}_arburst;
    logic                    s{i}_arlock;
    logic [3:0]              s{i}_arcache;
    logic [2:0]              s{i}_arprot;
    logic                    s{i}_arvalid;
    logic                    s{i}_arready;
    
    logic [ID_WIDTH-1:0]     s{i}_rid;
    logic [DATA_WIDTH-1:0]   s{i}_rdata;
    logic [1:0]              s{i}_rresp;
    logic                    s{i}_rlast;
    logic                    s{i}_rvalid;
    logic                    s{i}_rready;
""")
        return "\n".join(signals)
    
    def _generate_master_connections(self):
        """Generate master port connections"""
        connections = []
        for i, master in enumerate(self.config.masters):
            connections.append(f"""        // Master {i} - {master.name}
        .m{i}_awid(m{i}_awid),
        .m{i}_awaddr(m{i}_awaddr),
        .m{i}_awlen(m{i}_awlen),
        .m{i}_awsize(m{i}_awsize),
        .m{i}_awburst(m{i}_awburst),
        .m{i}_awlock(m{i}_awlock),
        .m{i}_awcache(m{i}_awcache),
        .m{i}_awprot(m{i}_awprot),
        .m{i}_awvalid(m{i}_awvalid),
        .m{i}_awready(m{i}_awready),
        
        .m{i}_wdata(m{i}_wdata),
        .m{i}_wstrb(m{i}_wstrb),
        .m{i}_wlast(m{i}_wlast),
        .m{i}_wvalid(m{i}_wvalid),
        .m{i}_wready(m{i}_wready),
        
        .m{i}_bid(m{i}_bid),
        .m{i}_bresp(m{i}_bresp),
        .m{i}_bvalid(m{i}_bvalid),
        .m{i}_bready(m{i}_bready),
        
        .m{i}_arid(m{i}_arid),
        .m{i}_araddr(m{i}_araddr),
        .m{i}_arlen(m{i}_arlen),
        .m{i}_arsize(m{i}_arsize),
        .m{i}_arburst(m{i}_arburst),
        .m{i}_arlock(m{i}_arlock),
        .m{i}_arcache(m{i}_arcache),
        .m{i}_arprot(m{i}_arprot),
        .m{i}_arvalid(m{i}_arvalid),
        .m{i}_arready(m{i}_arready),
        
        .m{i}_rid(m{i}_rid),
        .m{i}_rdata(m{i}_rdata),
        .m{i}_rresp(m{i}_rresp),
        .m{i}_rlast(m{i}_rlast),
        .m{i}_rvalid(m{i}_rvalid),
        .m{i}_rready(m{i}_rready)""")
            if i < len(self.config.masters) - 1:
                connections[-1] += ","
        return "\n".join(connections)
    
    def _generate_slave_connections(self):
        """Generate slave port connections"""
        connections = []
        for i, slave in enumerate(self.config.slaves):
            connections.append(f"""        // Slave {i} - {slave.name}
        .s{i}_awid(s{i}_awid),
        .s{i}_awaddr(s{i}_awaddr),
        .s{i}_awlen(s{i}_awlen),
        .s{i}_awsize(s{i}_awsize),
        .s{i}_awburst(s{i}_awburst),
        .s{i}_awlock(s{i}_awlock),
        .s{i}_awcache(s{i}_awcache),
        .s{i}_awprot(s{i}_awprot),
        .s{i}_awvalid(s{i}_awvalid),
        .s{i}_awready(s{i}_awready),
        
        .s{i}_wdata(s{i}_wdata),
        .s{i}_wstrb(s{i}_wstrb),
        .s{i}_wlast(s{i}_wlast),
        .s{i}_wvalid(s{i}_wvalid),
        .s{i}_wready(s{i}_wready),
        
        .s{i}_bid(s{i}_bid),
        .s{i}_bresp(s{i}_bresp),
        .s{i}_bvalid(s{i}_bvalid),
        .s{i}_bready(s{i}_bready),
        
        .s{i}_arid(s{i}_arid),
        .s{i}_araddr(s{i}_araddr),
        .s{i}_arlen(s{i}_arlen),
        .s{i}_arsize(s{i}_arsize),
        .s{i}_arburst(s{i}_arburst),
        .s{i}_arlock(s{i}_arlock),
        .s{i}_arcache(s{i}_arcache),
        .s{i}_arprot(s{i}_arprot),
        .s{i}_arvalid(s{i}_arvalid),
        .s{i}_arready(s{i}_arready),
        
        .s{i}_rid(s{i}_rid),
        .s{i}_rdata(s{i}_rdata),
        .s{i}_rresp(s{i}_rresp),
        .s{i}_rlast(s{i}_rlast),
        .s{i}_rvalid(s{i}_rvalid),
        .s{i}_rready(s{i}_rready)""")
        # Add comma between master and slave connections, and between slaves
        if len(connections) > 0:
            connections = [",\n" + conn if i > 0 else conn for i, conn in enumerate(connections)]
        return "\n".join(connections)
    
    def _generate_master_termination(self):
        """Generate termination logic for unused masters"""
        if len(self.config.masters) <= 1:
            return "    // No additional masters to terminate"
            
        termination = ["    // Terminate unused master interfaces"]
        for i in range(1, len(self.config.masters)):
            termination.append(f"""    assign m{i}_awvalid = 1'b0;
    assign m{i}_wvalid  = 1'b0;
    assign m{i}_bready  = 1'b1;
    assign m{i}_arvalid = 1'b0;
    assign m{i}_rready  = 1'b1;
""")
        return "\n".join(termination)
    
    def _generate_slave_responses(self):
        """Generate response logic for all slaves"""
        responses = ["    // Slave response logic for testing"]
        for i, slave in enumerate(self.config.slaves):
            responses.append(f"""    // Slave {i} ({slave.name}) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s{i}_awready <= 1'b0;
            s{i}_wready  <= 1'b0;
            s{i}_bvalid  <= 1'b0;
            s{i}_arready <= 1'b0;
            s{i}_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s{i}_awready <= 1'b1;
            s{i}_wready  <= 1'b1;
            s{i}_arready <= 1'b1;
            
            // Write response
            if (s{i}_awvalid && s{i}_awready && s{i}_wvalid && s{i}_wready && s{i}_wlast) begin
                s{i}_bvalid <= 1'b1;
                s{i}_bid    <= s{i}_awid;
                s{i}_bresp  <= 2'b00; // OKAY
            end else if (s{i}_bready && s{i}_bvalid) begin
                s{i}_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s{i}_arvalid && s{i}_arready) begin
                s{i}_rvalid <= 1'b1;
                s{i}_rid    <= s{i}_arid;
                s{i}_rdata  <= {{DATA_WIDTH{{1'b0}}}}; // Return zeros
                s{i}_rresp  <= 2'b00; // OKAY
                s{i}_rlast  <= 1'b1;  // Single beat
            end else if (s{i}_rready && s{i}_rvalid) begin
                s{i}_rvalid <= 1'b0;
            end
        end
    end
""")
        return "\n".join(responses)