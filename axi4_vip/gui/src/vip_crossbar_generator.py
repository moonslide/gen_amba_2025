#!/usr/bin/env python3
"""Generate complete AXI4 crossbar for VIP environment"""

def generate_crossbar_rtl(num_masters, num_slaves, data_width=256, addr_width=64, id_width=4):
    """Generate complete AXI4 crossbar RTL module"""
    
    code = []
    
    # Module header
    code.append(f"""//==============================================================================
// AXI4 Interconnect - {num_masters} Masters x {num_slaves} Slaves
// Generated by AMBA Bus Matrix Configuration Tool
// Compliant with AMBA AXI4 Protocol Specification (IHI0022D)
//==============================================================================

module axi4_interconnect_m{num_masters}s{num_slaves} #(
    parameter DATA_WIDTH = {data_width},
    parameter ADDR_WIDTH = {addr_width},
    parameter ID_WIDTH   = {id_width},
    parameter USER_WIDTH = 1
)(
    input wire                          aclk,
    input wire                          aresetn,
""")
    
    # Generate master ports
    for m in range(num_masters):
        code.append(f"""    
    // Master {m}
    // Write Address Channel
    input  wire [ID_WIDTH-1:0]     m{m}_awid,
    input  wire [ADDR_WIDTH-1:0]   m{m}_awaddr,
    input  wire [7:0]              m{m}_awlen,
    input  wire [2:0]              m{m}_awsize,
    input  wire [1:0]              m{m}_awburst,
    input  wire                    m{m}_awlock,
    input  wire [3:0]              m{m}_awcache,
    input  wire [2:0]              m{m}_awprot,
    input  wire [3:0]              m{m}_awqos,
    input  wire                    m{m}_awvalid,
    output wire                    m{m}_awready,
    
    // Write Data Channel
    input  wire [DATA_WIDTH-1:0]   m{m}_wdata,
    input  wire [DATA_WIDTH/8-1:0] m{m}_wstrb,
    input  wire                    m{m}_wlast,
    input  wire                    m{m}_wvalid,
    output wire                    m{m}_wready,
    
    // Write Response Channel
    output wire [ID_WIDTH-1:0]     m{m}_bid,
    output wire [1:0]              m{m}_bresp,
    output wire                    m{m}_bvalid,
    input  wire                    m{m}_bready,
    
    // Read Address Channel
    input  wire [ID_WIDTH-1:0]     m{m}_arid,
    input  wire [ADDR_WIDTH-1:0]   m{m}_araddr,
    input  wire [7:0]              m{m}_arlen,
    input  wire [2:0]              m{m}_arsize,
    input  wire [1:0]              m{m}_arburst,
    input  wire                    m{m}_arlock,
    input  wire [3:0]              m{m}_arcache,
    input  wire [2:0]              m{m}_arprot,
    input  wire [3:0]              m{m}_arqos,
    input  wire                    m{m}_arvalid,
    output wire                    m{m}_arready,
    
    // Read Data Channel
    output wire [ID_WIDTH-1:0]     m{m}_rid,
    output wire [DATA_WIDTH-1:0]   m{m}_rdata,
    output wire [1:0]              m{m}_rresp,
    output wire                    m{m}_rlast,
    output wire                    m{m}_rvalid,
    input  wire                    m{m}_rready,""")
    
    # Generate slave ports
    for s in range(num_slaves):
        code.append(f"""
    
    // Slave {s}
    // Write Address Channel
    output wire [ID_WIDTH-1:0]     s{s}_awid,
    output wire [ADDR_WIDTH-1:0]   s{s}_awaddr,
    output wire [7:0]              s{s}_awlen,
    output wire [2:0]              s{s}_awsize,
    output wire [1:0]              s{s}_awburst,
    output wire                    s{s}_awlock,
    output wire [3:0]              s{s}_awcache,
    output wire [2:0]              s{s}_awprot,
    output wire [3:0]              s{s}_awqos,
    output wire                    s{s}_awvalid,
    input  wire                    s{s}_awready,
    
    // Write Data Channel
    output wire [DATA_WIDTH-1:0]   s{s}_wdata,
    output wire [DATA_WIDTH/8-1:0] s{s}_wstrb,
    output wire                    s{s}_wlast,
    output wire                    s{s}_wvalid,
    input  wire                    s{s}_wready,
    
    // Write Response Channel
    input  wire [ID_WIDTH-1:0]     s{s}_bid,
    input  wire [1:0]              s{s}_bresp,
    input  wire                    s{s}_bvalid,
    output wire                    s{s}_bready,
    
    // Read Address Channel
    output wire [ID_WIDTH-1:0]     s{s}_arid,
    output wire [ADDR_WIDTH-1:0]   s{s}_araddr,
    output wire [7:0]              s{s}_arlen,
    output wire [2:0]              s{s}_arsize,
    output wire [1:0]              s{s}_arburst,
    output wire                    s{s}_arlock,
    output wire [3:0]              s{s}_arcache,
    output wire [2:0]              s{s}_arprot,
    output wire [3:0]              s{s}_arqos,
    output wire                    s{s}_arvalid,
    input  wire                    s{s}_arready,
    
    // Read Data Channel
    input  wire [ID_WIDTH-1:0]     s{s}_rid,
    input  wire [DATA_WIDTH-1:0]   s{s}_rdata,
    input  wire [1:0]              s{s}_rresp,
    input  wire                    s{s}_rlast,
    input  wire                    s{s}_rvalid,
    output wire                    s{s}_rready""")
        
        if s < num_slaves - 1:
            code.append(",")
    
    code.append("""
);

//------------------------------------------------------------------------------
// AXI4 Crossbar Switch Implementation
// Full crossbar allowing any master to access any slave
// Based on address decoding and round-robin arbitration
//------------------------------------------------------------------------------

// Address decoding - each slave gets equal address space
// Calculate address bits needed for slave selection
localparam SLAVE_ADDR_BITS = $clog2(""" + str(num_slaves) + """);
""")
    
    # Generate address decoders for each master
    for m in range(num_masters):
        code.append(f"""
// Master {m} address decoder
wire [{num_slaves-1}:0] m{m}_aw_slave_select;
wire [{num_slaves-1}:0] m{m}_ar_slave_select;
""")
        
        # Generate address decoding logic
        for s in range(num_slaves):
            # Use upper address bits for slave selection
            code.append(f"assign m{m}_aw_slave_select[{s}] = m{m}_awvalid && (m{m}_awaddr[ADDR_WIDTH-1:ADDR_WIDTH-SLAVE_ADDR_BITS] == {s});")
            code.append(f"assign m{m}_ar_slave_select[{s}] = m{m}_arvalid && (m{m}_araddr[ADDR_WIDTH-1:ADDR_WIDTH-SLAVE_ADDR_BITS] == {s});")
    
    # Generate arbitration logic for each slave
    code.append("""
//------------------------------------------------------------------------------
// Arbitration logic - Round-robin for each slave
//------------------------------------------------------------------------------
""")
    
    # Use smaller grant width for efficiency
    grant_width = "$clog2(" + str(num_masters) + ")"
    
    for s in range(num_slaves):
        code.append(f"""
// Slave {s} arbitration
reg [{grant_width}:0] s{s}_aw_grant;  // Which master has AW grant (MSB=1 means no grant)
reg [{grant_width}:0] s{s}_ar_grant;  // Which master has AR grant (MSB=1 means no grant)
reg [{grant_width}-1:0] s{s}_aw_last_grant;
reg [{grant_width}-1:0] s{s}_ar_last_grant;

// Collect requests from all masters for this slave
wire [{num_masters-1}:0] s{s}_aw_requests = {{""")
        
        # Build request vector
        reqs = []
        for m in range(num_masters-1, -1, -1):
            reqs.append(f"m{m}_aw_slave_select[{s}]")
        code.append(", ".join(reqs))
        code.append("};\n")
        
        code.append(f"wire [{num_masters-1}:0] s{s}_ar_requests = {{")
        reqs = []
        for m in range(num_masters-1, -1, -1):
            reqs.append(f"m{m}_ar_slave_select[{s}]")
        code.append(", ".join(reqs))
        code.append("};\n")
        
        # Round-robin arbitration
        code.append(f"""
// Round-robin arbitration for slave {s}
always @(posedge aclk or negedge aresetn) begin
    if (!aresetn) begin
        s{s}_aw_grant <= {{1'b1, {grant_width}'b0}}; // No grant
        s{s}_ar_grant <= {{1'b1, {grant_width}'b0}}; // No grant
        s{s}_aw_last_grant <= {grant_width}'d0;
        s{s}_ar_last_grant <= {grant_width}'d0;
    end else begin
        // AW channel arbitration
        if (s{s}_aw_grant[{grant_width}]) begin // No current grant
            // Simple priority: grant to lowest numbered requesting master
            if (s{s}_aw_requests != {num_masters}'b0) begin""")
        
        for m in range(num_masters):
            if m == 0:
                code.append(f"""
                if (s{s}_aw_requests[{m}]) s{s}_aw_grant <= {grant_width+1}'d{m};""")
            else:
                code.append(f"""
                else if (s{s}_aw_requests[{m}]) s{s}_aw_grant <= {grant_width+1}'d{m};""")
        
        code.append(f"""
            end
        end else if (s{s}_awready && s{s}_awvalid) begin
            // Transaction accepted, release grant
            s{s}_aw_last_grant <= s{s}_aw_grant[{grant_width}-1:0];
            s{s}_aw_grant <= {{1'b1, {grant_width}'b0}};
        end
        
        // AR channel arbitration
        if (s{s}_ar_grant[{grant_width}]) begin // No current grant
            // Simple priority: grant to lowest numbered requesting master
            if (s{s}_ar_requests != {num_masters}'b0) begin""")
        
        for m in range(num_masters):
            if m == 0:
                code.append(f"""
                if (s{s}_ar_requests[{m}]) s{s}_ar_grant <= {grant_width+1}'d{m};""")
            else:
                code.append(f"""
                else if (s{s}_ar_requests[{m}]) s{s}_ar_grant <= {grant_width+1}'d{m};""")
        
        code.append(f"""
            end
        end else if (s{s}_arready && s{s}_arvalid) begin
            // Transaction accepted, release grant
            s{s}_ar_last_grant <= s{s}_ar_grant[{grant_width}-1:0];
            s{s}_ar_grant <= {{1'b1, {grant_width}'b0}};
        end
    end
end
""")
    
    # Generate crossbar multiplexing for each slave
    code.append("""
//------------------------------------------------------------------------------
// Crossbar multiplexing - connect granted master to each slave
//------------------------------------------------------------------------------
""")
    
    for s in range(num_slaves):
        code.append(f"""
// Slave {s} input multiplexing
// AW channel
assign s{s}_awid    = """)
        for m in range(num_masters):
            if m == 0:
                code.append(f"(!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_awid :")
            elif m < num_masters - 1:
                code.append(f"""
                      (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_awid :""")
            else:
                code.append(f"""
                      (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_awid : {{ID_WIDTH{{1'b0}}}};""")
        
        # Generate all other AW signals
        aw_signals = [
            ('awaddr', 'ADDR_WIDTH'),
            ('awlen', '8'),
            ('awsize', '3'),
            ('awburst', '2'),
            ('awlock', '1'),
            ('awcache', '4'),
            ('awprot', '3'),
            ('awqos', '4')
        ]
        
        for sig, width in aw_signals:
            code.append(f"""
assign s{s}_{sig} = """)
            for m in range(num_masters):
                if m == 0:
                    code.append(f"(!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :")
                elif m < num_masters - 1:
                    code.append(f"""
                    (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :""")
                else:
                    if width == '1':
                        code.append(f"""
                    (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : 1'b0;""")
                    else:
                        code.append(f"""
                    (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : {width}'b0;""")
        
        # awvalid with slave select
        code.append(f"""
assign s{s}_awvalid = """)
        for m in range(num_masters):
            if m == 0:
                code.append(f"(!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? (m{m}_awvalid & m{m}_aw_slave_select[{s}]) :")
            elif m < num_masters - 1:
                code.append(f"""
                      (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? (m{m}_awvalid & m{m}_aw_slave_select[{s}]) :""")
            else:
                code.append(f"""
                      (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? (m{m}_awvalid & m{m}_aw_slave_select[{s}]) : 1'b0;""")
        
        # W channel signals (follow AW grant)
        w_signals = [
            ('wdata', 'DATA_WIDTH'),
            ('wstrb', 'DATA_WIDTH/8'),
            ('wlast', '1'),
            ('wvalid', '1'),
            ('bready', '1')
        ]
        
        for sig, width in w_signals:
            code.append(f"""
assign s{s}_{sig} = """)
            for m in range(num_masters):
                if m == 0:
                    code.append(f"(!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :")
                elif m < num_masters - 1:
                    code.append(f"""
                   (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :""")
                else:
                    if width == '1':
                        code.append(f"""
                   (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : 1'b0;""")
                    else:
                        code.append(f"""
                   (!s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : {{{width}{{1'b0}}}};""")
        
        # AR channel signals
        code.append(f"""

// AR channel
assign s{s}_arid = """)
        for m in range(num_masters):
            if m == 0:
                code.append(f"(!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_arid :")
            elif m < num_masters - 1:
                code.append(f"""
                  (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_arid :""")
            else:
                code.append(f"""
                  (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_arid : {{ID_WIDTH{{1'b0}}}};""")
        
        # Other AR signals
        ar_signals = [
            ('araddr', 'ADDR_WIDTH'),
            ('arlen', '8'),
            ('arsize', '3'),
            ('arburst', '2'),
            ('arlock', '1'),
            ('arcache', '4'),
            ('arprot', '3'),
            ('arqos', '4')
        ]
        
        for sig, width in ar_signals:
            code.append(f"""
assign s{s}_{sig} = """)
            for m in range(num_masters):
                if m == 0:
                    code.append(f"(!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :")
                elif m < num_masters - 1:
                    code.append(f"""
                   (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} :""")
                else:
                    if width == '1':
                        code.append(f"""
                   (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : 1'b0;""")
                    else:
                        code.append(f"""
                   (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_{sig} : {width}'b0;""")
        
        # arvalid with slave select
        code.append(f"""
assign s{s}_arvalid = """)
        for m in range(num_masters):
            if m == 0:
                code.append(f"(!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? (m{m}_arvalid & m{m}_ar_slave_select[{s}]) :")
            elif m < num_masters - 1:
                code.append(f"""
                      (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? (m{m}_arvalid & m{m}_ar_slave_select[{s}]) :""")
            else:
                code.append(f"""
                      (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? (m{m}_arvalid & m{m}_ar_slave_select[{s}]) : 1'b0;""")
        
        code.append(f"""
assign s{s}_rready = """)
        for m in range(num_masters):
            if m == 0:
                code.append(f"(!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_rready :")
            elif m < num_masters - 1:
                code.append(f"""
                    (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_rready :""")
            else:
                code.append(f"""
                    (!s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? m{m}_rready : 1'b0;""")
    
    # Generate response routing back to masters
    code.append("""

//------------------------------------------------------------------------------
// Response routing - route slave responses back to requesting master
//------------------------------------------------------------------------------
""")
    
    for m in range(num_masters):
        code.append(f"""
// Master {m} response routing
// Use address to determine target slave
wire [SLAVE_ADDR_BITS-1:0] m{m}_aw_target = m{m}_awaddr[ADDR_WIDTH-1:ADDR_WIDTH-SLAVE_ADDR_BITS];
wire [SLAVE_ADDR_BITS-1:0] m{m}_ar_target = m{m}_araddr[ADDR_WIDTH-1:ADDR_WIDTH-SLAVE_ADDR_BITS];

// AW ready - from target slave if granted
assign m{m}_awready = """)
        
        for s in range(num_slaves):
            if s == 0:
                code.append(f"(m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_awready :")
            elif s < num_slaves - 1:
                code.append(f"""
                     (m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_awready :""")
            else:
                code.append(f"""
                     (m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_awready : 1'b0;""")
        
        code.append(f"""

// W ready - from target slave if granted  
assign m{m}_wready = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"(m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_wready :")
            elif s < num_slaves - 1:
                code.append(f"""
                    (m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_wready :""")
            else:
                code.append(f"""
                    (m{m}_aw_target == {s} && !s{s}_aw_grant[{grant_width}] && s{s}_aw_grant[{grant_width}-1:0] == {m}) ? s{s}_wready : 1'b0;""")
        
        # B response - OR from all slaves
        code.append(f"""

// B response - from any slave
assign m{m}_bid = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_bvalid ? s{s}_bid :")
            elif s < num_slaves - 1:
                code.append(f"""
                 s{s}_bvalid ? s{s}_bid :""")
            else:
                code.append(f"""
                 s{s}_bvalid ? s{s}_bid : {{ID_WIDTH{{1'b0}}}};""")
        
        code.append(f"""
assign m{m}_bresp = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_bvalid ? s{s}_bresp :")
            elif s < num_slaves - 1:
                code.append(f"""
                   s{s}_bvalid ? s{s}_bresp :""")
            else:
                code.append(f"""
                   s{s}_bvalid ? s{s}_bresp : 2'b00;""")
        
        code.append(f"""
assign m{m}_bvalid = """)
        vals = [f"s{s}_bvalid" for s in range(num_slaves)]
        code.append(" | ".join(vals) + ";")
        
        # AR ready
        code.append(f"""

// AR ready - from target slave if granted
assign m{m}_arready = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"(m{m}_ar_target == {s} && !s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? s{s}_arready :")
            elif s < num_slaves - 1:
                code.append(f"""
                     (m{m}_ar_target == {s} && !s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? s{s}_arready :""")
            else:
                code.append(f"""
                     (m{m}_ar_target == {s} && !s{s}_ar_grant[{grant_width}] && s{s}_ar_grant[{grant_width}-1:0] == {m}) ? s{s}_arready : 1'b0;""")
        
        # R response - OR from all slaves
        code.append(f"""

// R response - from any slave
assign m{m}_rid = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_rvalid ? s{s}_rid :")
            elif s < num_slaves - 1:
                code.append(f"""
                 s{s}_rvalid ? s{s}_rid :""")
            else:
                code.append(f"""
                 s{s}_rvalid ? s{s}_rid : {{ID_WIDTH{{1'b0}}}};""")
        
        code.append(f"""
assign m{m}_rdata = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_rvalid ? s{s}_rdata :")
            elif s < num_slaves - 1:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rdata :""")
            else:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rdata : {{DATA_WIDTH{{1'b0}}}};""")
        
        code.append(f"""
assign m{m}_rresp = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_rvalid ? s{s}_rresp :")
            elif s < num_slaves - 1:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rresp :""")
            else:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rresp : 2'b00;""")
        
        code.append(f"""
assign m{m}_rlast = """)
        for s in range(num_slaves):
            if s == 0:
                code.append(f"s{s}_rvalid ? s{s}_rlast :")
            elif s < num_slaves - 1:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rlast :""")
            else:
                code.append(f"""
                   s{s}_rvalid ? s{s}_rlast : 1'b0;""")
        
        code.append(f"""
assign m{m}_rvalid = """)
        vals = [f"s{s}_rvalid" for s in range(num_slaves)]
        code.append(" | ".join(vals) + ";")
        
        code.append("\n")
    
    code.append("""
endmodule
""")
    
    return '\n'.join(code)

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python3 vip_crossbar_generator.py <num_masters> <num_slaves>")
        sys.exit(1)
    
    num_m = int(sys.argv[1])
    num_s = int(sys.argv[2])
    print(generate_crossbar_rtl(num_m, num_s))