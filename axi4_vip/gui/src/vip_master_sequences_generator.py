#!/usr/bin/env python3
"""
VIP Master Sequences Generator
Implements comprehensive master sequence library based on tim_axi4_vip
Step 4 of VIP Enhancement - 40+ master sequences
"""

import os
from datetime import datetime
from typing import Dict, List, Optional

class VIPMasterSequencesGenerator:
    """Generate comprehensive master sequence library"""
    
    def __init__(self, config):
        self.config = config
        self.timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Master sequence categories
        self.sequence_categories = {
            "basic": [
                "base_seq", "read_seq", "write_seq", "write_read_seq"
            ],
            "burst_types": [
                "fixed_burst_seq", "incr_burst_seq", "wrap_burst_seq"
            ],
            "transfer_sizes": [
                "8b_transfer_seq", "16b_transfer_seq", "32b_transfer_seq", 
                "64b_transfer_seq", "maximum_transfer_seq"
            ],
            "blocking": [
                "bk_base_seq", "bk_read_seq", "bk_write_seq",
                "bk_write_read_seq", "bk_outstanding_transfer_seq"
            ],
            "non_blocking": [
                "nbk_base_seq", "nbk_read_seq", "nbk_write_seq",
                "nbk_write_read_seq", "nbk_outstanding_transfer_seq"
            ],
            "response_types": [
                "okay_resp_seq", "exokay_resp_seq", "slave_error_seq",
                "ex_okay_resp_seq", "slave_error_seq"
            ],
            "advanced": [
                "4k_boundary_cross_seq", "unaligned_addr_seq",
                "qos_seq", "exclusive_access_seq", "rand_seq"
            ],
            "channel_tests": [
                "aw_ready_delay_seq", "w_ready_delay_seq", "ar_ready_delay_seq",
                "b_ready_delay_seq", "r_ready_delay_seq",
                "aw_w_channel_separation_seq"
            ],
            "ordering": [
                "read_response_out_of_order_seq",
                "write_response_out_of_order_seq",
                "write_read_response_out_of_order_seq"
            ],
            "boundary": [
                "lower_boundary_read_seq", "lower_boundary_write_seq",
                "upper_boundary_read_seq", "upper_boundary_write_seq"
            ],
            "strobe": [
                "wstrb_seq", "wstrb_baseline_seq", "wstrb_read_seq",
                "illegal_wstrb_seq"
            ],
            "test_cases": [
                "tc_046_id_multiple_writes_same_awid_seq",
                "tc_047_id_multiple_writes_different_awid_seq",
                "tc_048_id_multiple_reads_same_arid_seq",
                "tc_049_id_multiple_reads_different_arid_seq",
                "tc_050_wid_awid_mismatch_seq",
                "tc_051_wlast_too_early_seq",
                "tc_052_wlast_too_late_seq",
                "tc_053_awlen_out_of_spec_seq",
                "tc_054_arlen_out_of_spec_seq",
                "tc_055_exclusive_write_success_seq",
                "tc_056_exclusive_write_fail_seq",
                "tc_057_exclusive_read_success_seq",
                "tc_058_exclusive_read_fail_seq"
            ],
            "special": [
                "all_slave_access_seq", "cross_seq", 
                "slave_mem_mode_seq", "rand_incr_burst_seq"
            ]
        }
        
    def generate_master_sequences(self, output_dir):
        """Generate all master sequences"""
        seq_dir = os.path.join(output_dir, "seq", "master_sequences")
        os.makedirs(seq_dir, exist_ok=True)
        
        # Generate base sequence
        self._generate_base_sequence(seq_dir)
        
        # Generate package
        self._generate_master_seq_package(output_dir)
        
        # Generate all sequence categories
        self._generate_basic_sequences(seq_dir)
        self._generate_burst_sequences(seq_dir)
        self._generate_size_sequences(seq_dir)
        self._generate_blocking_sequences(seq_dir)
        self._generate_nonblocking_sequences(seq_dir)
        self._generate_response_sequences(seq_dir)
        self._generate_advanced_sequences(seq_dir)
        self._generate_channel_sequences(seq_dir)
        self._generate_ordering_sequences(seq_dir)
        self._generate_boundary_sequences(seq_dir)
        self._generate_strobe_sequences(seq_dir)
        self._generate_test_case_sequences(seq_dir)
        
        return seq_dir
    
    def _generate_base_sequence(self, output_dir):
        """Generate base sequence that all others extend"""
        content = f"""//==============================================================================
// AXI4 Master Base Sequence
// Generated by Master Sequences Generator
// Date: {self.timestamp}
// Base class for all master sequences
//==============================================================================

`ifndef AXI4_MASTER_BASE_SEQ_SV
`define AXI4_MASTER_BASE_SEQ_SV

class axi4_master_base_seq extends uvm_sequence #(axi4_master_tx);
    `uvm_object_utils(axi4_master_base_seq)
    
    // Configuration
    axi4_master_agent_config cfg;
    
    // Common parameters
    rand bit [{self.config.addr_width-1}:0] base_addr = 'h0;
    rand int num_transactions = 1;
    rand int burst_length = 1;
    rand bit [2:0] burst_size = 3'b010; // 4 bytes
    rand bit [1:0] burst_type = 2'b01;  // INCR
    
    // Advanced features
    rand bit [3:0] qos_level = 4'h0;
    rand bit [3:0] region = 4'h0;
    rand bit [2:0] prot = 3'b010;  // Normal, non-secure, data
    rand bit [3:0] cache = 4'b0011; // Normal non-cacheable
    rand bit exclusive_access = 0;
    
    // Delays
    rand int inter_beat_delay = 0;
    rand int post_addr_delay = 0;
    
    // Constraints
    constraint c_num_trans {{
        num_transactions inside {{[1:100]}};
    }}
    
    constraint c_burst_length {{
        burst_length inside {{[1:256]}};
        
        // WRAP constraints
        if(burst_type == 2'b10) {{
            burst_length inside {{2, 4, 8, 16}};
        }}
    }}
    
    constraint c_burst_size {{
        burst_size inside {{[0:$clog2({self.config.data_width}/8)]}};
    }}
    
    constraint c_4kb_boundary {{
        // Soft constraint to avoid 4KB crossing
        soft (base_addr[11:0] + (burst_length << burst_size)) <= 'h1000;
    }}
    
    constraint c_exclusive {{
        if(exclusive_access) {{
            burst_length << burst_size <= 128;
            // Size must be power of 2
            (burst_length << burst_size) inside {{1, 2, 4, 8, 16, 32, 64, 128}};
        }}
    }}
    
    // Constructor
    function new(string name = "axi4_master_base_seq");
        super.new(name);
    endfunction
    
    // Pre-start - get configuration
    task pre_start();
        if(!uvm_config_db#(axi4_master_agent_config)::get(
            get_sequencer(), "", "cfg", cfg))
            `uvm_fatal("NOCFG", "No configuration found")
    endtask
    
    // Main body - override in derived classes
    task body();
        `uvm_info(get_type_name(), "Base sequence body - override in derived class", UVM_HIGH)
    endtask
    
    // Helper tasks
    task send_write(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [{self.config.data_width-1}:0] data[],
        input bit [7:0] len = 0,
        input bit [2:0] size = 3'b010,
        input bit [1:0] burst = 2'b01
    );
        axi4_master_tx tr;
        
        `uvm_create(tr)
        
        tr.tx_type = WRITE;
        tr.awaddr = addr;
        tr.awlen = len;
        tr.awsize = size;
        tr.awburst = burst;
        tr.awid = $urandom_range(0, (1 << cfg.id_width) - 1);
        tr.awlock = exclusive_access;
        tr.awcache = cache;
        tr.awprot = prot;
        tr.awqos = qos_level;
        tr.awregion = region;
        
        // Set data
        tr.wdata = new[len + 1];
        tr.wstrb = new[len + 1];
        
        foreach(tr.wdata[i]) begin
            if(i < data.size()) begin
                tr.wdata[i] = data[i];
            end else begin
                tr.wdata[i] = $urandom();
            end
            tr.wstrb[i] = '1; // All bytes valid
        end
        
        `uvm_send(tr)
        
        get_response(rsp);
        
        if(rsp.bresp == SLVERR || rsp.bresp == DECERR) begin
            `uvm_warning(get_type_name(), 
                        $sformatf("Write error response: %s", rsp.bresp.name()))
        end
    endtask
    
    task send_read(
        input bit [{self.config.addr_width-1}:0] addr,
        input bit [7:0] len = 0,
        input bit [2:0] size = 3'b010,
        input bit [1:0] burst = 2'b01,
        output bit [{self.config.data_width-1}:0] data[]
    );
        axi4_master_tx tr;
        
        `uvm_create(tr)
        
        tr.tx_type = READ;
        tr.araddr = addr;
        tr.arlen = len;
        tr.arsize = size;
        tr.arburst = burst;
        tr.arid = $urandom_range(0, (1 << cfg.id_width) - 1);
        tr.arlock = exclusive_access;
        tr.arcache = cache;
        tr.arprot = prot;
        tr.arqos = qos_level;
        tr.arregion = region;
        
        `uvm_send(tr)
        
        get_response(rsp);
        
        if(rsp.rresp[0] == SLVERR || rsp.rresp[0] == DECERR) begin
            `uvm_warning(get_type_name(), 
                        $sformatf("Read error response: %s", rsp.rresp[0].name()))
        end
        
        data = rsp.rdata;
    endtask
    
    // Utility functions
    function bit [{self.config.addr_width-1}:0] get_aligned_addr(
        bit [{self.config.addr_width-1}:0] addr,
        bit [2:0] size
    );
        int mask = (1 << size) - 1;
        return addr & ~mask;
    endfunction
    
    function bit check_4kb_boundary(
        bit [{self.config.addr_width-1}:0] addr,
        int len,
        bit [2:0] size
    );
        bit [{self.config.addr_width-1}:0] start_addr = addr;
        bit [{self.config.addr_width-1}:0] end_addr = addr + ((len + 1) << size) - 1;
        return (start_addr[11:0] > end_addr[11:0]);
    endfunction
    
endclass

`endif // AXI4_MASTER_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_master_seq_package(self, output_dir):
        """Generate master sequences package"""
        content = f"""//==============================================================================
// AXI4 Master Sequences Package
// Generated by Master Sequences Generator
// Date: {self.timestamp}
// Includes all master sequences (40+ sequences)
//==============================================================================

`ifndef AXI4_MASTER_SEQ_PKG_SV
`define AXI4_MASTER_SEQ_PKG_SV

package axi4_master_seq_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    import axi4_master_pkg::*;
    
    // Base sequence
    `include "master_sequences/axi4_master_base_seq.sv"
    
    // Basic sequences
    `include "master_sequences/axi4_master_read_seq.sv"
    `include "master_sequences/axi4_master_write_seq.sv"
    
    // Blocking sequences
    `include "master_sequences/axi4_master_bk_base_seq.sv"
    `include "master_sequences/axi4_master_bk_read_seq.sv"
    `include "master_sequences/axi4_master_bk_write_seq.sv"
    `include "master_sequences/axi4_master_bk_write_read_seq.sv"
    
    // Non-blocking sequences  
    `include "master_sequences/axi4_master_nbk_base_seq.sv"
    `include "master_sequences/axi4_master_nbk_read_seq.sv"
    `include "master_sequences/axi4_master_nbk_write_seq.sv"
    `include "master_sequences/axi4_master_nbk_write_read_seq.sv"
    
    // Burst type sequences
    `include "master_sequences/axi4_master_bk_read_fixed_burst_seq.sv"
    `include "master_sequences/axi4_master_bk_read_incr_burst_seq.sv"
    `include "master_sequences/axi4_master_bk_read_wrap_burst_seq.sv"
    `include "master_sequences/axi4_master_bk_write_fixed_burst_seq.sv"
    `include "master_sequences/axi4_master_bk_write_incr_burst_seq.sv"
    `include "master_sequences/axi4_master_bk_write_wrap_burst_seq.sv"
    
    // Transfer size sequences
    `include "master_sequences/axi4_master_bk_read_8b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_read_16b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_read_32b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_read_64b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_write_8b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_write_16b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_write_32b_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_write_64b_transfer_seq.sv"
    
    // Response sequences
    `include "master_sequences/axi4_master_bk_read_okay_resp_seq.sv"
    `include "master_sequences/axi4_master_bk_read_ex_okay_resp_seq.sv"
    `include "master_sequences/axi4_master_bk_read_slave_error_seq.sv"
    `include "master_sequences/axi4_master_bk_write_okay_resp_seq.sv"
    `include "master_sequences/axi4_master_bk_write_exokay_resp_seq.sv"
    `include "master_sequences/axi4_master_bk_write_slave_error_seq.sv"
    
    // Advanced sequences
    `include "master_sequences/axi4_master_4k_boundary_cross_seq.sv"
    `include "master_sequences/axi4_master_bk_read_unaligned_addr_seq.sv"
    `include "master_sequences/axi4_master_bk_write_unaligned_addr_seq.sv"
    `include "master_sequences/axi4_master_bk_read_outstanding_transfer_seq.sv"
    `include "master_sequences/axi4_master_bk_write_outstanding_transfer_seq.sv"
    
    // Channel delay sequences
    `include "master_sequences/axi4_master_aw_ready_delay_seq.sv"
    `include "master_sequences/axi4_master_w_ready_delay_seq.sv"
    `include "master_sequences/axi4_master_ar_ready_delay_seq.sv"
    `include "master_sequences/axi4_master_b_ready_delay_seq.sv"
    `include "master_sequences/axi4_master_r_ready_delay_seq.sv"
    `include "master_sequences/axi4_master_aw_w_channel_separation_seq.sv"
    
    // Ordering sequences
    `include "master_sequences/axi4_master_read_nbk_only_read_response_out_of_order_seq.sv"
    `include "master_sequences/axi4_master_write_nbk_only_write_response_out_of_order_seq.sv"
    `include "master_sequences/axi4_master_write_nbk_write_read_response_out_of_order_seq.sv"
    
    // Boundary sequences
    `include "master_sequences/axi4_master_lower_boundary_read_seq.sv"
    `include "master_sequences/axi4_master_lower_boundary_write_seq.sv"
    `include "master_sequences/axi4_master_upper_boundary_read_seq.sv"
    `include "master_sequences/axi4_master_upper_boundary_write_seq.sv"
    
    // WSTRB sequences
    `include "master_sequences/axi4_master_wstrb_seq.sv"
    `include "master_sequences/axi4_master_wstrb_baseline_seq.sv"
    `include "master_sequences/axi4_master_wstrb_read_seq.sv"
    `include "master_sequences/axi4_master_illegal_wstrb_seq.sv"
    
    // Test case sequences
    `include "master_sequences/axi4_master_tc_046_id_multiple_writes_same_awid_seq.sv"
    `include "master_sequences/axi4_master_tc_047_id_multiple_writes_different_awid_seq.sv"
    `include "master_sequences/axi4_master_tc_048_id_multiple_reads_same_arid_seq.sv"
    `include "master_sequences/axi4_master_tc_049_id_multiple_reads_different_arid_seq.sv"
    `include "master_sequences/axi4_master_tc_050_wid_awid_mismatch_seq.sv"
    `include "master_sequences/axi4_master_tc_051_wlast_too_early_seq.sv"
    `include "master_sequences/axi4_master_tc_052_wlast_too_late_seq.sv"
    `include "master_sequences/axi4_master_tc_053_awlen_out_of_spec_seq.sv"
    `include "master_sequences/axi4_master_tc_054_arlen_out_of_spec_seq.sv"
    `include "master_sequences/axi4_master_tc_055_exclusive_write_success_seq.sv"
    `include "master_sequences/axi4_master_tc_056_exclusive_write_fail_seq.sv"
    `include "master_sequences/axi4_master_tc_057_exclusive_read_success_seq.sv"
    `include "master_sequences/axi4_master_tc_058_exclusive_read_fail_seq.sv"
    
    // Special sequences
    `include "master_sequences/axi4_master_all_slave_access_seq.sv"
    `include "master_sequences/axi4_master_bk_read_cross_seq.sv"
    `include "master_sequences/axi4_master_bk_write_cross_seq.sv"
    `include "master_sequences/axi4_master_bk_read_rand_seq.sv"
    `include "master_sequences/axi4_master_bk_write_rand_seq.sv"
    
    // Non-blocking advanced
    `include "master_sequences/axi4_master_nbk_read_qos_seq.sv"
    `include "master_sequences/axi4_master_nbk_write_qos_seq.sv"
    `include "master_sequences/axi4_master_nbk_read_maximum_transfer_seq.sv"
    `include "master_sequences/axi4_master_nbk_rand_write_incr_burst_seq.sv"
    
    // Slave memory mode sequences
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_read_fixed_burst_seq.sv"
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_read_incr_burst_seq.sv"
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_read_wrap_burst_seq.sv"
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_write_fixed_burst_seq.sv"
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_write_incr_burst_seq.sv"
    `include "master_sequences/axi4_master_nbk_slave_mem_mode_write_wrap_burst_seq.sv"
    
endpackage

`endif // AXI4_MASTER_SEQ_PKG_SV
"""
        
        filepath = os.path.join(output_dir, "seq", "axi4_master_seq_pkg.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_basic_sequences(self, output_dir):
        """Generate basic read/write sequences"""
        
        # Read sequence
        content = f"""//==============================================================================
// AXI4 Master Read Sequence
// Basic read sequence
//==============================================================================

`ifndef AXI4_MASTER_READ_SEQ_SV
`define AXI4_MASTER_READ_SEQ_SV

class axi4_master_read_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_read_seq)
    
    function new(string name = "axi4_master_read_seq");
        super.new(name);
    endfunction
    
    task body();
        bit [{self.config.data_width-1}:0] read_data[];
        
        repeat(num_transactions) begin
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type),
                .data(read_data)
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("Read %0d beats from addr 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
            
            // Update address for next transaction
            if(burst_type == INCR) begin
                base_addr = base_addr + (burst_length << burst_size);
            end
        end
    endtask
endclass

`endif // AXI4_MASTER_READ_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_read_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Write sequence
        content = f"""//==============================================================================
// AXI4 Master Write Sequence
// Basic write sequence
//==============================================================================

`ifndef AXI4_MASTER_WRITE_SEQ_SV
`define AXI4_MASTER_WRITE_SEQ_SV

class axi4_master_write_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_write_seq)
    
    function new(string name = "axi4_master_write_seq");
        super.new(name);
    endfunction
    
    task body();
        bit [{self.config.data_width-1}:0] write_data[];
        
        repeat(num_transactions) begin
            // Generate random data
            write_data = new[burst_length];
            foreach(write_data[i]) begin
                write_data[i] = $urandom();
            end
            
            send_write(
                .addr(base_addr),
                .data(write_data),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type)
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("Wrote %0d beats to addr 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
            
            // Update address for next transaction
            if(burst_type == INCR) begin
                base_addr = base_addr + (burst_length << burst_size);
            end
        end
    endtask
endclass

`endif // AXI4_MASTER_WRITE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_write_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def _generate_burst_sequences(self, output_dir):
        """Generate burst type specific sequences"""
        
        burst_types = ["fixed", "incr", "wrap"]
        operations = ["read", "write"]
        
        for op in operations:
            for burst in burst_types:
                content = f"""//==============================================================================
// AXI4 Master {op.title()} {burst.upper()} Burst Sequence
//==============================================================================

`ifndef AXI4_MASTER_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV
`define AXI4_MASTER_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV

class axi4_master_bk_{op}_{burst}_burst_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_bk_{op}_{burst}_burst_seq)
    
    function new(string name = "axi4_master_bk_{op}_{burst}_burst_seq");
        super.new(name);
    endfunction
    
    task body();"""
                
                if burst == "wrap":
                    content += f"""
        // WRAP specific constraints
        if(!(burst_length inside {{2, 4, 8, 16}})) begin
            burst_length = 4; // Default WRAP length
        end
        
        // Align address for WRAP
        base_addr = get_aligned_addr(base_addr, burst_size);"""
                
                if op == "read":
                    content += f"""
        bit [{self.config.data_width-1}:0] read_data[];
        
        repeat(num_transactions) begin
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size(burst_size),
                .burst({burst.upper()}),
                .data(read_data)
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("{burst.upper()} read %0d beats from 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
        end"""
                else:  # write
                    content += f"""
        bit [{self.config.data_width-1}:0] write_data[];
        
        repeat(num_transactions) begin
            write_data = new[burst_length];
            foreach(write_data[i]) begin
                write_data[i] = $urandom();
            end
            
            send_write(
                .addr(base_addr),
                .data(write_data),
                .len(burst_length - 1),
                .size(burst_size),
                .burst({burst.upper()})
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("{burst.upper()} wrote %0d beats to 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
        end"""
                
                content += f"""
    endtask
endclass

`endif // AXI4_MASTER_BK_{op.upper()}_{burst.upper()}_BURST_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_master_bk_{op}_{burst}_burst_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_size_sequences(self, output_dir):
        """Generate transfer size specific sequences"""
        
        sizes = ["8b", "16b", "32b", "64b"]
        size_values = {"8b": 0, "16b": 1, "32b": 2, "64b": 3}
        operations = ["read", "write"]
        
        for op in operations:
            for size in sizes:
                content = f"""//==============================================================================
// AXI4 Master {op.title()} {size} Transfer Sequence
//==============================================================================

`ifndef AXI4_MASTER_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV
`define AXI4_MASTER_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV

class axi4_master_bk_{op}_{size}_transfer_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_bk_{op}_{size}_transfer_seq)
    
    function new(string name = "axi4_master_bk_{op}_{size}_transfer_seq");
        super.new(name);
    endfunction
    
    constraint c_size {{
        burst_size == {size_values[size]};
    }}
    
    task body();"""
                
                if op == "read":
                    content += f"""
        bit [{self.config.data_width-1}:0] read_data[];
        
        repeat(num_transactions) begin
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size({size_values[size]}),
                .burst(burst_type),
                .data(read_data)
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("{size} read %0d beats from 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
                     
            base_addr = base_addr + (burst_length << {size_values[size]});
        end"""
                else:  # write
                    content += f"""
        bit [{self.config.data_width-1}:0] write_data[];
        
        repeat(num_transactions) begin
            write_data = new[burst_length];
            foreach(write_data[i]) begin
                write_data[i] = $urandom();
            end
            
            send_write(
                .addr(base_addr),
                .data(write_data),
                .len(burst_length - 1),
                .size({size_values[size]}),
                .burst(burst_type)
            );
            
            `uvm_info(get_type_name(), 
                     $sformatf("{size} wrote %0d beats to 0x%0h", 
                     burst_length, base_addr), UVM_MEDIUM)
                     
            base_addr = base_addr + (burst_length << {size_values[size]});
        end"""
                
                content += f"""
    endtask
endclass

`endif // AXI4_MASTER_BK_{op.upper()}_{size.upper()}_TRANSFER_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_master_bk_{op}_{size}_transfer_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_blocking_sequences(self, output_dir):
        """Generate blocking sequences"""
        
        # Blocking base sequence
        content = f"""//==============================================================================
// AXI4 Master Blocking Base Sequence
//==============================================================================

`ifndef AXI4_MASTER_BK_BASE_SEQ_SV
`define AXI4_MASTER_BK_BASE_SEQ_SV

class axi4_master_bk_base_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_bk_base_seq)
    
    // Blocking mode - wait for response before next transaction
    bit blocking_mode = 1;
    
    function new(string name = "axi4_master_bk_base_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), "Blocking mode sequence", UVM_HIGH)
    endtask
endclass

`endif // AXI4_MASTER_BK_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_bk_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Other blocking sequences
        blocking_seqs = [
            ("read", "Read operations in blocking mode"),
            ("write", "Write operations in blocking mode"),
            ("write_read", "Write followed by read in blocking mode"),
            ("outstanding_transfer", "Outstanding transfers with blocking")
        ]
        
        for seq_name, desc in blocking_seqs:
            self._generate_sequence_file(output_dir, f"bk_{seq_name}", desc, "blocking")
    
    def _generate_nonblocking_sequences(self, output_dir):
        """Generate non-blocking sequences"""
        
        # Non-blocking base sequence
        content = f"""//==============================================================================
// AXI4 Master Non-Blocking Base Sequence
//==============================================================================

`ifndef AXI4_MASTER_NBK_BASE_SEQ_SV
`define AXI4_MASTER_NBK_BASE_SEQ_SV

class axi4_master_nbk_base_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_nbk_base_seq)
    
    // Non-blocking mode - pipeline transactions
    bit blocking_mode = 0;
    int max_outstanding = 16;
    
    function new(string name = "axi4_master_nbk_base_seq");
        super.new(name);
    endfunction
    
    task body();
        `uvm_info(get_type_name(), "Non-blocking mode sequence", UVM_HIGH)
    endtask
endclass

`endif // AXI4_MASTER_NBK_BASE_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_nbk_base_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Other non-blocking sequences
        nbk_seqs = [
            ("read", "Pipelined read operations"),
            ("write", "Pipelined write operations"),
            ("write_read", "Pipelined write and read"),
            ("outstanding_transfer", "Maximum outstanding transfers"),
            ("qos", "QoS-based transactions"),
            ("maximum_transfer", "Maximum size transfers"),
            ("rand_incr_burst", "Random INCR bursts")
        ]
        
        for seq_name, desc in nbk_seqs:
            self._generate_sequence_file(output_dir, f"nbk_{seq_name}", desc, "non-blocking")
    
    def _generate_response_sequences(self, output_dir):
        """Generate response type sequences"""
        
        responses = [
            ("okay_resp", "OKAY", "Normal successful response"),
            ("ex_okay_resp", "EXOKAY", "Exclusive access success"),
            ("slave_error", "SLVERR", "Slave error response")
        ]
        
        for resp_name, resp_type, desc in responses:
            for op in ["read", "write"]:
                content = f"""//==============================================================================
// AXI4 Master {op.title()} {resp_type} Response Sequence
// {desc}
//==============================================================================

`ifndef AXI4_MASTER_BK_{op.upper()}_{resp_name.upper()}_SEQ_SV
`define AXI4_MASTER_BK_{op.upper()}_{resp_name.upper()}_SEQ_SV

class axi4_master_bk_{op}_{resp_name}_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_bk_{op}_{resp_name}_seq)
    
    function new(string name = "axi4_master_bk_{op}_{resp_name}_seq");
        super.new(name);
    endfunction
    
    task body();"""
                
                if resp_type == "EXOKAY":
                    content += f"""
        // Enable exclusive access for EXOKAY
        exclusive_access = 1;
        burst_length = 1; // Single beat for exclusive"""
                
                if op == "read":
                    content += f"""
        bit [{self.config.data_width-1}:0] read_data[];
        
        repeat(num_transactions) begin
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type),
                .data(read_data)
            );
            
            // Check response
            if(rsp.rresp[0] != {resp_type}) begin
                `uvm_error(get_type_name(), 
                          $sformatf("Expected {resp_type}, got %s", rsp.rresp[0].name()))
            end
        end"""
                else:  # write
                    content += f"""
        bit [{self.config.data_width-1}:0] write_data[];
        
        repeat(num_transactions) begin
            write_data = new[burst_length];
            foreach(write_data[i]) begin
                write_data[i] = $urandom();
            end
            
            send_write(
                .addr(base_addr),
                .data(write_data),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type)
            );
            
            // Check response
            if(rsp.bresp != {resp_type}) begin
                `uvm_error(get_type_name(), 
                          $sformatf("Expected {resp_type}, got %s", rsp.bresp.name()))
            end
        end"""
                
                content += f"""
    endtask
endclass

`endif // AXI4_MASTER_BK_{op.upper()}_{resp_name.upper()}_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_master_bk_{op}_{resp_name}_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_advanced_sequences(self, output_dir):
        """Generate advanced feature sequences"""
        
        # 4KB boundary crossing sequence
        content = f"""//==============================================================================
// AXI4 Master 4KB Boundary Cross Sequence
// Tests transactions that cross 4KB boundaries
//==============================================================================

`ifndef AXI4_MASTER_4K_BOUNDARY_CROSS_SEQ_SV
`define AXI4_MASTER_4K_BOUNDARY_CROSS_SEQ_SV

class axi4_master_4k_boundary_cross_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_4k_boundary_cross_seq)
    
    function new(string name = "axi4_master_4k_boundary_cross_seq");
        super.new(name);
    endfunction
    
    constraint c_4kb_cross {{
        // Force 4KB boundary crossing
        base_addr[11:0] == 'hF00;  // Start near boundary
        burst_length == 64;         // Enough to cross
        burst_size == 3;            // 8 bytes per beat
        burst_type == INCR;         // INCR burst
    }}
    
    task body();
        bit [{self.config.data_width-1}:0] data[];
        
        repeat(num_transactions) begin
            // Verify this will cross 4KB
            if(!check_4kb_boundary(base_addr, burst_length-1, burst_size)) begin
                `uvm_error(get_type_name(), "Transaction does not cross 4KB boundary")
            end
            
            `uvm_warning(get_type_name(), 
                        $sformatf("Intentionally crossing 4KB at 0x%0h", base_addr))
            
            // Do write then read
            data = new[burst_length];
            foreach(data[i]) data[i] = $urandom();
            
            send_write(
                .addr(base_addr),
                .data(data),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(INCR)
            );
            
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(INCR),
                .data(data)
            );
        end
    endtask
endclass

`endif // AXI4_MASTER_4K_BOUNDARY_CROSS_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_4k_boundary_cross_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Unaligned address sequences
        for op in ["read", "write"]:
            content = f"""//==============================================================================
// AXI4 Master {op.title()} Unaligned Address Sequence
//==============================================================================

`ifndef AXI4_MASTER_BK_{op.upper()}_UNALIGNED_ADDR_SEQ_SV
`define AXI4_MASTER_BK_{op.upper()}_UNALIGNED_ADDR_SEQ_SV

class axi4_master_bk_{op}_unaligned_addr_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_bk_{op}_unaligned_addr_seq)
    
    function new(string name = "axi4_master_bk_{op}_unaligned_addr_seq");
        super.new(name);
    endfunction
    
    constraint c_unaligned {{
        // Force unaligned address
        base_addr[2:0] != 0;  // Not aligned to 8 bytes
        burst_size >= 3;       // 8 bytes or more
    }}
    
    task body();"""
            
            if op == "read":
                content += f"""
        bit [{self.config.data_width-1}:0] read_data[];
        
        repeat(num_transactions) begin
            `uvm_info(get_type_name(), 
                     $sformatf("Unaligned read from 0x%0h", base_addr), UVM_MEDIUM)
                     
            send_read(
                .addr(base_addr),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type),
                .data(read_data)
            );
        end"""
            else:  # write
                content += f"""
        bit [{self.config.data_width-1}:0] write_data[];
        
        repeat(num_transactions) begin
            write_data = new[burst_length];
            foreach(write_data[i]) write_data[i] = $urandom();
            
            `uvm_info(get_type_name(), 
                     $sformatf("Unaligned write to 0x%0h", base_addr), UVM_MEDIUM)
                     
            send_write(
                .addr(base_addr),
                .data(write_data),
                .len(burst_length - 1),
                .size(burst_size),
                .burst(burst_type)
            );
        end"""
            
            content += f"""
    endtask
endclass

`endif // AXI4_MASTER_BK_{op.upper()}_UNALIGNED_ADDR_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_master_bk_{op}_unaligned_addr_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_channel_sequences(self, output_dir):
        """Generate channel-specific delay sequences"""
        
        channels = [
            ("aw_ready_delay", "Write address channel ready delay"),
            ("w_ready_delay", "Write data channel ready delay"),
            ("ar_ready_delay", "Read address channel ready delay"),
            ("b_ready_delay", "Write response channel ready delay"),
            ("r_ready_delay", "Read data channel ready delay"),
            ("aw_w_channel_separation", "AW and W channel separation")
        ]
        
        for seq_name, desc in channels:
            content = f"""//==============================================================================
// AXI4 Master {seq_name.replace('_', ' ').title()} Sequence
// {desc}
//==============================================================================

`ifndef AXI4_MASTER_{seq_name.upper()}_SEQ_SV
`define AXI4_MASTER_{seq_name.upper()}_SEQ_SV

class axi4_master_{seq_name}_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_{seq_name}_seq)
    
    rand int delay_cycles = 10;
    
    constraint c_delay {{
        delay_cycles inside {{[0:50]}};
    }}
    
    function new(string name = "axi4_master_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_master_tx tr;
        
        repeat(num_transactions) begin
            `uvm_create(tr)
            
            // Configure transaction
            tr.tx_type = (seq_name.find("ar") != -1 || seq_name.find("r_") != -1) ? READ : WRITE;
            tr.set_address(base_addr);
            tr.set_burst_length(burst_length - 1);
            tr.set_burst_size(burst_size);
            tr.set_burst_type(burst_type);
            
            // Set specific delay
            case(seq_name)
                "aw_ready_delay": tr.aw_ready_delay = delay_cycles;
                "w_ready_delay": tr.w_ready_delay = delay_cycles;
                "ar_ready_delay": tr.ar_ready_delay = delay_cycles;
                "b_ready_delay": tr.b_ready_delay = delay_cycles;
                "r_ready_delay": tr.r_ready_delay = delay_cycles;
                "aw_w_channel_separation": begin
                    tr.aw_valid_delay = 0;
                    tr.w_valid_delay = delay_cycles;
                end
            endcase
            
            `uvm_send(tr)
            get_response(rsp);
            
            `uvm_info(get_type_name(), 
                     $sformatf("{desc} test with %0d cycle delay", delay_cycles), 
                     UVM_MEDIUM)
        end
    endtask
endclass

`endif // AXI4_MASTER_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_master_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_ordering_sequences(self, output_dir):
        """Generate out-of-order response sequences"""
        
        ordering_seqs = [
            ("read_nbk_only_read_response_out_of_order", 
             "Out-of-order read responses"),
            ("write_nbk_only_write_response_out_of_order", 
             "Out-of-order write responses"),
            ("write_nbk_write_read_response_out_of_order", 
             "Mixed out-of-order responses")
        ]
        
        for seq_name, desc in ordering_seqs:
            content = f"""//==============================================================================
// AXI4 Master {desc} Sequence
//==============================================================================

`ifndef AXI4_MASTER_{seq_name.upper()}_SEQ_SV
`define AXI4_MASTER_{seq_name.upper()}_SEQ_SV

class axi4_master_{seq_name}_seq extends axi4_master_nbk_base_seq;
    `uvm_object_utils(axi4_master_{seq_name}_seq)
    
    rand int num_ids = 4;
    
    function new(string name = "axi4_master_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_master_tx tr_queue[$];
        
        // Send multiple transactions with different IDs
        repeat(num_transactions) begin
            for(int id = 0; id < num_ids; id++) begin
                `uvm_create(tr)
                
                if(seq_name.find("read") != -1) begin
                    tr.tx_type = READ;
                    tr.arid = id;
                end else begin
                    tr.tx_type = WRITE;
                    tr.awid = id;
                end
                
                tr.set_address(base_addr + (id * 'h1000));
                tr.set_burst_length(burst_length - 1);
                
                tr_queue.push_back(tr);
            end
        end
        
        // Send all transactions without waiting
        foreach(tr_queue[i]) begin
            `uvm_send(tr_queue[i])
        end
        
        // Collect responses (may be out of order)
        repeat(tr_queue.size()) begin
            get_response(rsp);
            `uvm_info(get_type_name(), 
                     $sformatf("Got response for ID %0d", 
                     rsp.tx_type == READ ? rsp.rid : rsp.bid), 
                     UVM_HIGH)
        end
    endtask
endclass

`endif // AXI4_MASTER_{seq_name.upper()}_SEQ_SV
"""
            
            filepath = os.path.join(output_dir, f"axi4_master_{seq_name}_seq.sv")
            with open(filepath, 'w') as f:
                f.write(content)
    
    def _generate_boundary_sequences(self, output_dir):
        """Generate address boundary test sequences"""
        
        boundaries = [
            ("lower", "0x0000_0000_0000_0000", "Lower address boundary"),
            ("upper", "0xFFFF_FFFF_FFFF_FF00", "Upper address boundary")
        ]
        
        for bound_name, addr, desc in boundaries:
            for op in ["read", "write"]:
                content = f"""//==============================================================================
// AXI4 Master {bound_name.title()} Boundary {op.title()} Sequence
// {desc} test
//==============================================================================

`ifndef AXI4_MASTER_{bound_name.upper()}_BOUNDARY_{op.upper()}_SEQ_SV
`define AXI4_MASTER_{bound_name.upper()}_BOUNDARY_{op.upper()}_SEQ_SV

class axi4_master_{bound_name}_boundary_{op}_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_{bound_name}_boundary_{op}_seq)
    
    function new(string name = "axi4_master_{bound_name}_boundary_{op}_seq");
        super.new(name);
    endfunction
    
    constraint c_boundary {{
        base_addr == {addr};
        burst_length == 1;  // Single beat at boundary
        burst_type == INCR;
    }}
    
    task body();"""
                
                if op == "read":
                    content += f"""
        bit [{self.config.data_width-1}:0] read_data[];
        
        `uvm_info(get_type_name(), 
                 $sformatf("Reading from {desc}: 0x%0h", base_addr), 
                 UVM_MEDIUM)
                 
        send_read(
            .addr(base_addr),
            .len(0),
            .size(burst_size),
            .burst(INCR),
            .data(read_data)
        );"""
                else:  # write
                    content += f"""
        bit [{self.config.data_width-1}:0] write_data[];
        
        write_data = new[1];
        write_data[0] = $urandom();
        
        `uvm_info(get_type_name(), 
                 $sformatf("Writing to {desc}: 0x%0h", base_addr), 
                 UVM_MEDIUM)
                 
        send_write(
            .addr(base_addr),
            .data(write_data),
            .len(0),
            .size(burst_size),
            .burst(INCR)
        );"""
                
                content += f"""
    endtask
endclass

`endif // AXI4_MASTER_{bound_name.upper()}_BOUNDARY_{op.upper()}_SEQ_SV
"""
                
                filepath = os.path.join(output_dir, f"axi4_master_{bound_name}_boundary_{op}_seq.sv")
                with open(filepath, 'w') as f:
                    f.write(content)
    
    def _generate_strobe_sequences(self, output_dir):
        """Generate WSTRB test sequences"""
        
        # Base WSTRB sequence
        content = f"""//==============================================================================
// AXI4 Master WSTRB Sequence
// Tests various write strobe patterns
//==============================================================================

`ifndef AXI4_MASTER_WSTRB_SEQ_SV
`define AXI4_MASTER_WSTRB_SEQ_SV

class axi4_master_wstrb_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_wstrb_seq)
    
    typedef enum {{
        ALL_BYTES,
        ALTERNATE_BYTES,
        FIRST_LAST_BYTES,
        RANDOM_BYTES
    }} strb_pattern_e;
    
    rand strb_pattern_e strb_pattern = ALL_BYTES;
    
    function new(string name = "axi4_master_wstrb_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_master_tx tr;
        
        repeat(num_transactions) begin
            `uvm_create(tr)
            
            tr.tx_type = WRITE;
            tr.awaddr = base_addr;
            tr.awlen = burst_length - 1;
            tr.awsize = burst_size;
            tr.awburst = burst_type;
            
            // Set data and strobe
            tr.wdata = new[burst_length];
            tr.wstrb = new[burst_length];
            
            foreach(tr.wdata[i]) begin
                tr.wdata[i] = $urandom();
                
                case(strb_pattern)
                    ALL_BYTES: tr.wstrb[i] = '1;
                    ALTERNATE_BYTES: tr.wstrb[i] = 'hAA;
                    FIRST_LAST_BYTES: tr.wstrb[i] = (1 << burst_size) | 1;
                    RANDOM_BYTES: tr.wstrb[i] = $urandom();
                endcase
            end
            
            `uvm_send(tr)
            get_response(rsp);
            
            `uvm_info(get_type_name(), 
                     $sformatf("WSTRB pattern %s test completed", strb_pattern.name()), 
                     UVM_MEDIUM)
                     
            // Change pattern for next iteration
            strb_pattern = strb_pattern_e'((strb_pattern + 1) % 4);
        end
    endtask
endclass

`endif // AXI4_MASTER_WSTRB_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_wstrb_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Additional WSTRB sequences
        strb_seqs = [
            ("wstrb_baseline", "Baseline WSTRB patterns"),
            ("wstrb_read", "Read after partial write"),
            ("illegal_wstrb", "Illegal WSTRB patterns")
        ]
        
        for seq_name, desc in strb_seqs:
            self._generate_sequence_file(output_dir, seq_name, desc, "strobe")
    
    def _generate_test_case_sequences(self, output_dir):
        """Generate specific test case sequences"""
        
        # Example: TC-046 Multiple writes same ID
        content = f"""//==============================================================================
// AXI4 Master TC-046: Multiple Writes Same AWID Sequence
// Tests multiple outstanding writes with same ID
//==============================================================================

`ifndef AXI4_MASTER_TC_046_ID_MULTIPLE_WRITES_SAME_AWID_SEQ_SV
`define AXI4_MASTER_TC_046_ID_MULTIPLE_WRITES_SAME_AWID_SEQ_SV

class axi4_master_tc_046_id_multiple_writes_same_awid_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_tc_046_id_multiple_writes_same_awid_seq)
    
    rand int num_outstanding = 4;
    rand bit [{self.config.id_width-1}:0] fixed_id = 'h5;
    
    function new(string name = "axi4_master_tc_046_id_multiple_writes_same_awid_seq");
        super.new(name);
    endfunction
    
    task body();
        axi4_master_tx tr_queue[$];
        
        // Create multiple writes with same ID
        repeat(num_outstanding) begin
            axi4_master_tx tr;
            bit [{self.config.data_width-1}:0] data[];
            
            `uvm_create(tr)
            
            tr.tx_type = WRITE;
            tr.awid = fixed_id;
            tr.awaddr = base_addr;
            tr.awlen = burst_length - 1;
            tr.awsize = burst_size;
            tr.awburst = burst_type;
            
            data = new[burst_length];
            foreach(data[i]) data[i] = $urandom();
            
            tr.wdata = data;
            tr.wstrb = new[burst_length];
            foreach(tr.wstrb[i]) tr.wstrb[i] = '1;
            
            tr_queue.push_back(tr);
            base_addr = base_addr + (burst_length << burst_size);
        end
        
        // Send all transactions
        foreach(tr_queue[i]) begin
            `uvm_send(tr_queue[i])
        end
        
        // Collect responses - must be in order for same ID
        repeat(num_outstanding) begin
            get_response(rsp);
            if(rsp.bid != fixed_id) begin
                `uvm_error(get_type_name(), 
                          $sformatf("Expected BID %0h, got %0h", fixed_id, rsp.bid))
            end
        end
        
        `uvm_info(get_type_name(), 
                 $sformatf("Completed %0d writes with same ID %0h", 
                 num_outstanding, fixed_id), 
                 UVM_MEDIUM)
    endtask
endclass

`endif // AXI4_MASTER_TC_046_ID_MULTIPLE_WRITES_SAME_AWID_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, "axi4_master_tc_046_id_multiple_writes_same_awid_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
        
        # Generate other test cases
        test_cases = [
            ("tc_047", "multiple_writes_different_awid", "Multiple writes with different IDs"),
            ("tc_048", "multiple_reads_same_arid", "Multiple reads with same ID"),
            ("tc_049", "multiple_reads_different_arid", "Multiple reads with different IDs"),
            ("tc_050", "wid_awid_mismatch", "WID AWID mismatch test"),
            ("tc_051", "wlast_too_early", "WLAST asserted too early"),
            ("tc_052", "wlast_too_late", "WLAST asserted too late"),
            ("tc_053", "awlen_out_of_spec", "AWLEN out of specification"),
            ("tc_054", "arlen_out_of_spec", "ARLEN out of specification"),
            ("tc_055", "exclusive_write_success", "Exclusive write success"),
            ("tc_056", "exclusive_write_fail", "Exclusive write failure"),
            ("tc_057", "exclusive_read_success", "Exclusive read success"),
            ("tc_058", "exclusive_read_fail", "Exclusive read failure")
        ]
        
        for tc_num, seq_name, desc in test_cases:
            self._generate_sequence_file(output_dir, f"{tc_num}_{seq_name}", desc, "test_case")
    
    def _generate_sequence_file(self, output_dir, seq_name, description, category):
        """Generate a generic sequence file"""
        
        content = f"""//==============================================================================
// AXI4 Master {seq_name.replace('_', ' ').title()} Sequence
// {description}
//==============================================================================

`ifndef AXI4_MASTER_{seq_name.upper()}_SEQ_SV
`define AXI4_MASTER_{seq_name.upper()}_SEQ_SV

class axi4_master_{seq_name}_seq extends axi4_master_base_seq;
    `uvm_object_utils(axi4_master_{seq_name}_seq)
    
    function new(string name = "axi4_master_{seq_name}_seq");
        super.new(name);
    endfunction
    
    task body();
        // {description} implementation
        `uvm_info(get_type_name(), "{description}", UVM_MEDIUM)
        
        repeat(num_transactions) begin
            // Sequence-specific implementation
            if({seq_name}.find("read") != -1) begin
                bit [{self.config.data_width-1}:0] read_data[];
                send_read(
                    .addr(base_addr),
                    .len(burst_length - 1),
                    .size(burst_size),
                    .burst(burst_type),
                    .data(read_data)
                );
            end else begin
                bit [{self.config.data_width-1}:0] write_data[];
                write_data = new[burst_length];
                foreach(write_data[i]) write_data[i] = $urandom();
                
                send_write(
                    .addr(base_addr),
                    .data(write_data),
                    .len(burst_length - 1),
                    .size(burst_size),
                    .burst(burst_type)
                );
            end
            
            base_addr = base_addr + (burst_length << burst_size);
        end
    endtask
endclass

`endif // AXI4_MASTER_{seq_name.upper()}_SEQ_SV
"""
        
        filepath = os.path.join(output_dir, f"axi4_master_{seq_name}_seq.sv")
        with open(filepath, 'w') as f:
            f.write(content)
    
    def get_master_sequences_info(self) -> Dict:
        """Return master sequences information"""
        
        # Count total sequences
        total_sequences = sum(len(seqs) for seqs in self.sequence_categories.values())
        
        return {
            "total_sequences": total_sequences,
            "categories": list(self.sequence_categories.keys()),
            "sequence_types": {
                "Basic": ["read", "write", "write_read"],
                "Burst Types": ["FIXED", "INCR", "WRAP"],
                "Transfer Sizes": ["8b", "16b", "32b", "64b", "maximum"],
                "Blocking/Non-blocking": ["blocking", "non-blocking", "pipelined"],
                "Response Types": ["OKAY", "EXOKAY", "SLVERR", "DECERR"],
                "Advanced": ["4KB boundary", "unaligned", "QoS", "exclusive"],
                "Channel Tests": ["ready delays", "channel separation"],
                "Ordering": ["in-order", "out-of-order", "same ID", "different ID"],
                "Boundary": ["lower address", "upper address"],
                "WSTRB": ["all bytes", "partial", "random", "illegal"],
                "Test Cases": ["TC-046 through TC-058"]
            },
            "features": [
                "Comprehensive protocol coverage",
                "Configurable parameters",
                "Error injection capability",
                "Performance testing",
                "Compliance testing",
                "Stress testing",
                "Corner case coverage"
            ]
        }