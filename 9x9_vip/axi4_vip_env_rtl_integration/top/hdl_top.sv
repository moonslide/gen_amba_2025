//==============================================================================
// HDL Top Module
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-04 09:53:21
//==============================================================================

module hdl_top;
    
    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Clock and reset
    logic aclk;
    logic aresetn;
    
    // Clock generation
    initial begin
        aclk = 0;
        forever #5ns aclk = ~aclk;
    end
    
    // Reset generation
    initial begin
        aresetn = 0;
        repeat(10) @(posedge aclk);
        aresetn = 1;
    end
    
    // AXI4 interfaces
    axi4_if axi_if[NO_OF_MASTERS](aclk, aresetn);
    
    // Master agent BFMs - connected to AXI interfaces
    genvar i;
    generate
        for (i = 0; i < NO_OF_MASTERS; i++) begin : gen_master_bfms
            axi4_master_agent_bfm #(
                .ADDR_WIDTH(ADDRESS_WIDTH),
                .DATA_WIDTH(DATA_WIDTH),
                .ID_WIDTH(ID_WIDTH)
            ) master_bfm (
                .aclk(aclk),
                .aresetn(aresetn),
                .axi_intf(axi_if[i])
            );
        end
    endgenerate
    
    // Additional slave interfaces for slave BFMs (connected to DUT outputs)
    // Slave interfaces need wider ID width to accommodate master ID concatenation
    axi4_if #(
        .ADDR_WIDTH(ADDRESS_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH+$clog2(NO_OF_MASTERS))  // Extended ID width for slaves
    ) slave_if[NO_OF_SLAVES](aclk, aresetn);
    
    // Slave agent BFMs - connected to slave interfaces
    generate
        for (i = 0; i < NO_OF_SLAVES; i++) begin : gen_slave_bfms
            axi4_slave_agent_bfm #(
                .ADDR_WIDTH(ADDRESS_WIDTH),
                .DATA_WIDTH(DATA_WIDTH),
                .ID_WIDTH(ID_WIDTH+$clog2(NO_OF_MASTERS))  // Slave ID includes master ID
            ) slave_bfm (
                .aclk(aclk),
                .aresetn(aresetn),
                .axi_intf(slave_if[i])
            );
        end
    endgenerate
    
    // BFM initialization and control
    initial begin
        $display("[%0t] HDL Top: BFMs instantiated and connected", $time);
        $display("[%0t] HDL Top: %0d Master BFMs connected to axi_if interfaces", $time, NO_OF_MASTERS);
        $display("[%0t] HDL Top: %0d Slave BFMs connected to slave_if interfaces", $time, NO_OF_SLAVES);
        $display("[%0t] HDL Top: Signal driving is now handled by BFMs", $time);
    end
    
    // Unified FSDB/VCD dumping with plusarg support
    `ifdef DUMP_FSDB
    initial begin
        string dump_file = "axi4_vip.fsdb";  // Default filename
        
        // Check for custom filename from plusargs
        if ($value$plusargs("fsdb_file=%s", dump_file)) begin
            $display("[%0t] Using custom FSDB file: %s", $time, dump_file);
        end else begin
            $display("[%0t] Using default FSDB file: %s", $time, dump_file);
        end
        
        // Start FSDB dumping with determined filename
        $display("[%0t] Starting FSDB dump", $time);
        $fsdbDumpfile(dump_file);
        $fsdbDumpvars(0, hdl_top, "+all");
        $fsdbDumpSVA();
        $fsdbDumpMDA();
        $fsdbDumpon();
    end
    `endif
    
    // VCD dumping (alternative)
    `ifdef DUMP_VCD
    initial begin
        string dump_file = "axi4_vip.vcd";  // Default filename
        
        // Check for custom filename from plusargs
        if ($value$plusargs("vcd_file=%s", dump_file)) begin
            $display("[%0t] Using custom VCD file: %s", $time, dump_file);
        end else begin
            $display("[%0t] Using default VCD file: %s", $time, dump_file);
        end
        
        $display("[%0t] Starting VCD dump", $time);
        $dumpfile(dump_file);
        $dumpvars(0, hdl_top);
        $dumpon();
    end
    `endif
    
    // Waveform control tasks
    task enable_wave_dump();
        `ifdef DUMP_FSDB
            $fsdbDumpon();
            $display("[%0t] FSDB dumping enabled", $time);
        `elsif DUMP_VCD
            $dumpon();
            $display("[%0t] VCD dumping enabled", $time);
        `else
            $display("[%0t] No waveform dumping configured. Use +define+DUMP_FSDB or +define+DUMP_VCD", $time);
        `endif
    endtask
    
    task disable_wave_dump();
        `ifdef DUMP_FSDB
            $fsdbDumpoff();
            $display("[%0t] FSDB dumping disabled", $time);
        `elsif DUMP_VCD
            $dumpoff();
            $display("[%0t] VCD dumping disabled", $time);
        `endif
    endtask
    
    // RTL DUT instance - Full 9x9 interconnect
    dut_wrapper #(
        .ADDR_WIDTH(ADDRESS_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .ID_WIDTH(ID_WIDTH),
        .NUM_MASTERS(NO_OF_MASTERS),
        .NUM_SLAVES(NO_OF_SLAVES)
    ) dut (
        .clk(aclk),
        .rst_n(aresetn),
        .master_if(axi_if),    // All master interfaces from VIP
        .slave_if(slave_if)    // All slave interfaces to VIP slave BFMs
    );
    
    // Additional waveform dumping for DUT internals
    `ifdef DUMP_FSDB
    initial begin
        #1;  // Wait for DUT instantiation
        $fsdbDumpvars(0, dut, "+all");
        $display("[%0t] Added DUT internal signals to FSDB dump", $time);
    end
    `endif
    
    `ifdef DUMP_VCD  
    initial begin
        #1;  // Wait for DUT instantiation
        $dumpvars(0, dut);
        $display("[%0t] Added DUT internal signals to VCD dump", $time);
    end
    `endif
    
endmodule : hdl_top
