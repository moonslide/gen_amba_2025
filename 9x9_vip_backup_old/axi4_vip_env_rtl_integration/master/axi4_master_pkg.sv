//==============================================================================
// AXI4 Master Package
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-08-04 09:31:30
//==============================================================================

package axi4_master_pkg;
    
    import uvm_pkg::*;
    `include "uvm_macros.svh"
    
    import axi4_globals_pkg::*;
    
    // Transaction class
    class axi4_master_tx extends uvm_sequence_item;
        `uvm_object_utils(axi4_master_tx)
        
        // Transaction type
        typedef enum {WRITE, READ} tx_type_e;
        rand tx_type_e tx_type;
        
        // Address channel
        rand bit [ADDRESS_WIDTH-1:0] awaddr;
        rand bit [7:0] awlen;
        rand bit [2:0] awsize;
        rand bit [1:0] awburst;
        rand bit [3:0] awid;
        rand bit [3:0] awqos;
        rand bit [3:0] awregion;
        rand bit awlock;
        rand bit [3:0] awcache;
        rand bit [2:0] awprot;
        
        // Data channel
        rand bit [DATA_WIDTH-1:0] wdata[];
        
        // Read address channel  
        rand bit [ADDRESS_WIDTH-1:0] araddr;
        rand bit [7:0] arlen;
        rand bit [2:0] arsize;
        rand bit [1:0] arburst;
        rand bit [3:0] arid;
        rand bit [3:0] arqos;
        rand bit [3:0] arregion;
        rand bit arlock;
        rand bit [3:0] arcache;
        rand bit [2:0] arprot;
        
        // Read data
        bit [DATA_WIDTH-1:0] rdata[];
        bit [1:0] rresp[];
        
        function new(string name = "axi4_master_tx");
            super.new(name);
        endfunction
    endclass
    
    // Master agent config
    class axi4_master_agent_config extends uvm_object;
        `uvm_object_utils(axi4_master_agent_config)
        
        bit is_active = UVM_ACTIVE;
        
        function new(string name = "axi4_master_agent_config");
            super.new(name);
        endfunction
    endclass
    
    // Sequencer class
    class axi4_master_sequencer extends uvm_sequencer #(axi4_master_tx);
        `uvm_component_utils(axi4_master_sequencer)
        
        function new(string name = "axi4_master_sequencer", uvm_component parent = null);
            super.new(name, parent);
        endfunction
    endclass
    
    // Driver class (stub)
    class axi4_master_driver extends uvm_driver #(axi4_master_tx);
        `uvm_component_utils(axi4_master_driver)
        
        function new(string name = "axi4_master_driver", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master driver run_phase", UVM_LOW)
            forever begin
                `uvm_info(get_type_name(), "Waiting for next transaction from sequencer", UVM_HIGH)
                seq_item_port.get_next_item(req);
                
                `uvm_info(get_type_name(), $sformatf("Got %s transaction - addr=0x%0h, len=%0d, size=%0d, burst=%0d", 
                    req.tx_type.name(), 
                    (req.tx_type == WRITE) ? req.awaddr : req.araddr,
                    (req.tx_type == WRITE) ? req.awlen : req.arlen,
                    (req.tx_type == WRITE) ? req.awsize : req.arsize,
                    (req.tx_type == WRITE) ? req.awburst : req.arburst), UVM_MEDIUM)
                
                `uvm_info(get_type_name(), $sformatf("Transaction details - id=%0d, qos=%0d, region=%0d, cache=0x%0h, prot=%0d",
                    (req.tx_type == WRITE) ? req.awid : req.arid,
                    (req.tx_type == WRITE) ? req.awqos : req.arqos,
                    (req.tx_type == WRITE) ? req.awregion : req.arregion,
                    (req.tx_type == WRITE) ? req.awcache : req.arcache,
                    (req.tx_type == WRITE) ? req.awprot : req.arprot), UVM_HIGH)
                
                if (req.tx_type == WRITE && req.wdata.size() > 0) begin
                    `uvm_info(get_type_name(), $sformatf("Write data: %0d beats, first_data=0x%0h", 
                        req.wdata.size(), req.wdata[0]), UVM_HIGH)
                end
                
                `uvm_info(get_type_name(), "Driving transaction to BFM interface", UVM_HIGH)
                #100ns;
                
                `uvm_info(get_type_name(), "Transaction completed, signaling item_done", UVM_HIGH)
                seq_item_port.item_done();
            end
        endtask
    endclass
    
    // Monitor class (stub)
    class axi4_master_monitor extends uvm_monitor;
        `uvm_component_utils(axi4_master_monitor)
        
        uvm_analysis_port #(axi4_master_tx) item_collected_port;
        
        function new(string name = "axi4_master_monitor", uvm_component parent = null);
            super.new(name, parent);
            item_collected_port = new("item_collected_port", this);
        endfunction
        
        virtual task run_phase(uvm_phase phase);
            `uvm_info(get_type_name(), "Starting master monitor run_phase", UVM_LOW)
            `uvm_info(get_type_name(), "Monitoring AXI4 master interface for transactions", UVM_MEDIUM)
            
            forever begin
                @(posedge vif.aclk);
                
                // Monitor write address channel
                if (vif.awvalid && vif.awready) begin
                    `uvm_info(get_type_name(), $sformatf("WRITE_ADDR: addr=0x%0h, id=%0d, len=%0d, size=%0d, burst=%0d",
                        vif.awaddr, vif.awid, vif.awlen, vif.awsize, vif.awburst), UVM_MEDIUM)
                    `uvm_info(get_type_name(), $sformatf("WRITE_ADDR_PROT: qos=%0d, region=%0d, cache=0x%0h, prot=%0d",
                        vif.awqos, vif.awregion, vif.awcache, vif.awprot), UVM_HIGH)
                end
                
                // Monitor write data channel
                if (vif.wvalid && vif.wready) begin
                    `uvm_info(get_type_name(), $sformatf("WRITE_DATA: data=0x%0h, strb=0x%0h, last=%b",
                        vif.wdata, vif.wstrb, vif.wlast), UVM_HIGH)
                end
                
                // Monitor write response channel
                if (vif.bvalid && vif.bready) begin
                    `uvm_info(get_type_name(), $sformatf("WRITE_RESP: id=%0d, resp=%0d",
                        vif.bid, vif.bresp), UVM_MEDIUM)
                end
                
                // Monitor read address channel
                if (vif.arvalid && vif.arready) begin
                    `uvm_info(get_type_name(), $sformatf("READ_ADDR: addr=0x%0h, id=%0d, len=%0d, size=%0d, burst=%0d",
                        vif.araddr, vif.arid, vif.arlen, vif.arsize, vif.arburst), UVM_MEDIUM)
                    `uvm_info(get_type_name(), $sformatf("READ_ADDR_PROT: qos=%0d, region=%0d, cache=0x%0h, prot=%0d",
                        vif.arqos, vif.arregion, vif.arcache, vif.arprot), UVM_HIGH)
                end
                
                // Monitor read data channel
                if (vif.rvalid && vif.rready) begin
                    `uvm_info(get_type_name(), $sformatf("READ_DATA: data=0x%0h, id=%0d, resp=%0d, last=%b",
                        vif.rdata, vif.rid, vif.rresp, vif.rlast), UVM_MEDIUM)
                end
            end
        endtask
    endclass
    
    // Agent class
    class axi4_master_agent extends uvm_agent;
        `uvm_component_utils(axi4_master_agent)
        
        axi4_master_agent_config cfg;
        axi4_master_sequencer sequencer;
        axi4_master_driver driver;
        axi4_master_monitor monitor;
        
        function new(string name = "axi4_master_agent", uvm_component parent = null);
            super.new(name, parent);
        endfunction
        
        function void build_phase(uvm_phase phase);
            super.build_phase(phase);
            
            // Get configuration
            if(!uvm_config_db#(axi4_master_agent_config)::get(this, "", "cfg", cfg))
                `uvm_fatal("CONFIG", "Cannot get master agent config from uvm_config_db")
            
            if(cfg.is_active == UVM_ACTIVE) begin
                sequencer = axi4_master_sequencer::type_id::create("sequencer", this);
                driver = axi4_master_driver::type_id::create("driver", this);
            end
            monitor = axi4_master_monitor::type_id::create("monitor", this);
        endfunction
        
        function void connect_phase(uvm_phase phase);
            super.connect_phase(phase);
            if(cfg.is_active == UVM_ACTIVE) begin
                driver.seq_item_port.connect(sequencer.seq_item_export);
            end
        endfunction
    endclass
    
endpackage : axi4_master_pkg
