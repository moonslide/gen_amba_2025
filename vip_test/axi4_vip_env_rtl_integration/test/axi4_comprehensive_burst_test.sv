//==============================================================================
// AXI4 Comprehensive Burst Test - VCS Compatible Generated
// Generated by VCS-Compatible VIP Generator
//==============================================================================

class axi4_comprehensive_burst_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_comprehensive_burst_test)
    
    function new(string name = "axi4_comprehensive_burst_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_burst_seq burst_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting comprehensive burst test", UVM_LOW)
        
        // Test different WRAP burst lengths with safe master indices
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 5; j++) begin
                automatic int master_idx = (i + j) % 2;
                automatic int wrap_length;
                automatic int burst_size;
                
                // Set wrap length based on index
                case (i)
                    0: wrap_length = 2;
                    1: wrap_length = 4;
                    2: wrap_length = 8;
                    3: wrap_length = 16;
                endcase
                
                // Set burst size based on index
                case (j)
                    0: burst_size = 1;
                    1: burst_size = 2;
                    2: burst_size = 4;
                    3: burst_size = 8;
                    4: burst_size = 16;
                endcase
                
                burst_seq = axi4_master_burst_seq::type_id::create($sformatf("wrap_burst_%0d_%0d", i, j));
                burst_seq.start_address = 64'h0000_2000 + (i * 4096) + (j * 256);
                burst_seq.burst_type = axi4_globals_pkg::WRAP; 
                burst_seq.burst_length = wrap_length;
                burst_seq.burst_size = burst_size;
                burst_seq.align_address_for_wrap = 1;
                // Distribute across multiple masters using modulo
                burst_seq.start(env.master_agent[master_idx].sequencer);
                #50ns;
            end
        end
        
        // Test concurrent bursts from multiple masters with valid indices
        `uvm_info(get_type_name(), "Testing concurrent burst operations", UVM_MEDIUM)
        fork
            // Distribute concurrent bursts across available masters
            begin
                foreach(env.master_agent[i]) begin
                    automatic int burst_id = i;
                    fork
                        begin
                            burst_seq = axi4_master_burst_seq::type_id::create($sformatf("concurrent_burst_%0d", burst_id));
                            burst_seq.burst_type = (burst_id % 2 == 0) ? axi4_globals_pkg::INCR : axi4_globals_pkg::FIXED;
                            burst_seq.burst_length = 16 + (burst_id * 8);
                            burst_seq.start_address = 64'h0000_5000 + (burst_id * 2048);
                            burst_seq.start(env.master_agent[burst_id].sequencer);
                        end
                    join_none
                end
            end
        join
        
        `uvm_info(get_type_name(), "Completed comprehensive burst test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_comprehensive_burst_test
