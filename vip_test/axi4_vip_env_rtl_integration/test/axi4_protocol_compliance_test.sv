//==============================================================================
// AXI4 Protocol Compliance Test - VCS Compatible Generated
// Generated by VCS-Compatible VIP Generator  
//==============================================================================

class axi4_protocol_compliance_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_protocol_compliance_test)
    
    function new(string name = "axi4_protocol_compliance_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting protocol compliance test", UVM_LOW)
        
        // Test handshake timing with valid master index
        test_handshake_simultaneous();
        test_valid_ready_timing(); 
        test_response_types();
        test_exclusive_access();
        
        `uvm_info(get_type_name(), "Completed protocol compliance test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
    // Test simultaneous VALID/READY assertion
    task test_handshake_simultaneous();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing simultaneous VALID/READY", UVM_MEDIUM)
        
        // Test on multiple masters
        foreach(env.master_agent[i]) begin
            write_seq = axi4_master_write_seq::type_id::create($sformatf("handshake_simultaneous_%0d", i));
            write_seq.start_address = 64'h0000_3000 + (i * 1024);
            write_seq.burst_length = 4;
            write_seq.simultaneous_valid_ready = 1;
            write_seq.start(env.master_agent[i].sequencer);
            #100ns;
        end
    endtask
    
    // Test VALID/READY timing rules
    task test_valid_ready_timing();
        axi4_master_read_seq read_seq;
        
        `uvm_info(get_type_name(), "Testing VALID before READY timing", UVM_MEDIUM)
        
        // Test timing on multiple masters with different delays
        foreach(env.master_agent[i]) begin
            read_seq = axi4_master_read_seq::type_id::create($sformatf("timing_valid_first_%0d", i));
            read_seq.start_address = 64'h0000_4000 + (i * 1024);
            read_seq.burst_length = 8;
            read_seq.test_valid_stability = 1;
            read_seq.ready_delay = 5 + (i * 2); // Different delays per master
            read_seq.start(env.master_agent[i].sequencer);
            #150ns;
        end
    endtask
    
    // Test response types with proper enum casting
    task test_response_types();
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing response types", UVM_MEDIUM)
        
        // OKAY, EXOKAY (SLVERR/DECERR tested separately)
        for (int i = 0; i < 2; i++) begin
            automatic int master_idx = i % 2;
            automatic int resp_type;
            
            // Set response type based on index
            case (i)
                0: resp_type = 0; // OKAY
                1: resp_type = 1; // EXOKAY
            endcase
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("response_type_%0d", i));
            write_seq.start_address = 64'h0004_2000 + (i * 1024);
            write_seq.burst_length = 4;
            // Safe enum assignment with proper casting
            write_seq.expected_response = axi4_response_type_e'(resp_type);
            write_seq.lock_type = (resp_type == 1) ? axi4_globals_pkg::EXCLUSIVE : axi4_globals_pkg::NORMAL;
            write_seq.start(env.master_agent[master_idx].sequencer);
            #100ns;
        end
    endtask
    
    // Test exclusive access with safe master indices
    task test_exclusive_access();
        axi4_master_read_seq read_seq;
        axi4_master_write_seq write_seq;
        
        `uvm_info(get_type_name(), "Testing exclusive access", UVM_MEDIUM)
        
        fork
            begin
                foreach(env.master_agent[i]) begin
                    automatic int burst_id = i;
                    fork
                        begin
                            read_seq = axi4_master_read_seq::type_id::create($sformatf("exclusive_read_%0d", burst_id));
                            read_seq.start_address = 64'h0006_0000 + (burst_id * 1024);
                            read_seq.burst_length = 1;
                            read_seq.burst_size = 8;
                            read_seq.lock_type = axi4_globals_pkg::EXCLUSIVE;
                            read_seq.axi_id = 10 + burst_id;
                            read_seq.start(env.master_agent[burst_id].sequencer);
                            #50ns;
                            
                            write_seq = axi4_master_write_seq::type_id::create($sformatf("exclusive_write_%0d", burst_id));
                            write_seq.start_address = 64'h0006_0000 + (burst_id * 1024);
                            write_seq.burst_length = 1;
                            write_seq.burst_size = 8;
                            write_seq.lock_type = axi4_globals_pkg::EXCLUSIVE;
                            write_seq.axi_id = 10 + burst_id;
                            write_seq.expect_response = axi4_globals_pkg::EXOKAY;
                            write_seq.start(env.master_agent[burst_id].sequencer);
                            #50ns;
                        end
                    join_none
                end
            end
        join
    endtask
    
endclass : axi4_protocol_compliance_test
