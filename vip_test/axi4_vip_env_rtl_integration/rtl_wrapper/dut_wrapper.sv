//==============================================================================
// DUT Wrapper for RTL Integration
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-07-29 14:34:40
// Supports 2 masters and 3 slaves
//==============================================================================

module dut_wrapper #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32,
    parameter ID_WIDTH   = 4,
    parameter WIDTH_SID  = (1 + ID_WIDTH)  // WIDTH_CID + WIDTH_ID where WIDTH_CID = $clog2(2) = 1
) (
    input  logic clk,
    input  logic rst_n,
    axi4_if.slave axi_if  // VIP connects as master to this slave interface
);

    // Internal signals for all masters
    // Master 0 signals
    logic [ID_WIDTH-1:0]     m0_awid;
    logic [ADDR_WIDTH-1:0]   m0_awaddr;
    logic [7:0]              m0_awlen;
    logic [2:0]              m0_awsize;
    logic [1:0]              m0_awburst;
    logic                    m0_awlock;
    logic [3:0]              m0_awcache;
    logic [2:0]              m0_awprot;
    logic [3:0]              m0_awqos;
    logic                    m0_awvalid;
    logic                    m0_awready;
    
    logic [DATA_WIDTH-1:0]   m0_wdata;
    logic [DATA_WIDTH/8-1:0] m0_wstrb;
    logic                    m0_wlast;
    logic                    m0_wvalid;
    logic                    m0_wready;
    
    logic [ID_WIDTH-1:0]     m0_bid;
    logic [1:0]              m0_bresp;
    logic                    m0_bvalid;
    logic                    m0_bready;
    
    logic [ID_WIDTH-1:0]     m0_arid;
    logic [ADDR_WIDTH-1:0]   m0_araddr;
    logic [7:0]              m0_arlen;
    logic [2:0]              m0_arsize;
    logic [1:0]              m0_arburst;
    logic                    m0_arlock;
    logic [3:0]              m0_arcache;
    logic [2:0]              m0_arprot;
    logic [3:0]              m0_arqos;
    logic                    m0_arvalid;
    logic                    m0_arready;
    
    logic [ID_WIDTH-1:0]     m0_rid;
    logic [DATA_WIDTH-1:0]   m0_rdata;
    logic [1:0]              m0_rresp;
    logic                    m0_rlast;
    logic                    m0_rvalid;
    logic                    m0_rready;

    // Master 1 signals
    logic [ID_WIDTH-1:0]     m1_awid;
    logic [ADDR_WIDTH-1:0]   m1_awaddr;
    logic [7:0]              m1_awlen;
    logic [2:0]              m1_awsize;
    logic [1:0]              m1_awburst;
    logic                    m1_awlock;
    logic [3:0]              m1_awcache;
    logic [2:0]              m1_awprot;
    logic [3:0]              m1_awqos;
    logic                    m1_awvalid;
    logic                    m1_awready;
    
    logic [DATA_WIDTH-1:0]   m1_wdata;
    logic [DATA_WIDTH/8-1:0] m1_wstrb;
    logic                    m1_wlast;
    logic                    m1_wvalid;
    logic                    m1_wready;
    
    logic [ID_WIDTH-1:0]     m1_bid;
    logic [1:0]              m1_bresp;
    logic                    m1_bvalid;
    logic                    m1_bready;
    
    logic [ID_WIDTH-1:0]     m1_arid;
    logic [ADDR_WIDTH-1:0]   m1_araddr;
    logic [7:0]              m1_arlen;
    logic [2:0]              m1_arsize;
    logic [1:0]              m1_arburst;
    logic                    m1_arlock;
    logic [3:0]              m1_arcache;
    logic [2:0]              m1_arprot;
    logic [3:0]              m1_arqos;
    logic                    m1_arvalid;
    logic                    m1_arready;
    
    logic [ID_WIDTH-1:0]     m1_rid;
    logic [DATA_WIDTH-1:0]   m1_rdata;
    logic [1:0]              m1_rresp;
    logic                    m1_rlast;
    logic                    m1_rvalid;
    logic                    m1_rready;

    
    // Internal signals for all slaves  
    // Slave 0 signals
    logic [WIDTH_SID-1:0]    s0_awid;
    logic [ADDR_WIDTH-1:0]   s0_awaddr;
    logic [7:0]              s0_awlen;
    logic [2:0]              s0_awsize;
    logic [1:0]              s0_awburst;
    logic                    s0_awlock;
    logic [3:0]              s0_awcache;
    logic [2:0]              s0_awprot;
    logic [3:0]              s0_awqos;
    logic                    s0_awvalid;
    logic                    s0_awready;
    
    logic [DATA_WIDTH-1:0]   s0_wdata;
    logic [DATA_WIDTH/8-1:0] s0_wstrb;
    logic                    s0_wlast;
    logic                    s0_wvalid;
    logic                    s0_wready;
    
    logic [WIDTH_SID-1:0]    s0_bid;
    logic [1:0]              s0_bresp;
    logic                    s0_bvalid;
    logic                    s0_bready;
    
    logic [WIDTH_SID-1:0]    s0_arid;
    logic [ADDR_WIDTH-1:0]   s0_araddr;
    logic [7:0]              s0_arlen;
    logic [2:0]              s0_arsize;
    logic [1:0]              s0_arburst;
    logic                    s0_arlock;
    logic [3:0]              s0_arcache;
    logic [2:0]              s0_arprot;
    logic [3:0]              s0_arqos;
    logic                    s0_arvalid;
    logic                    s0_arready;
    
    logic [WIDTH_SID-1:0]    s0_rid;
    logic [DATA_WIDTH-1:0]   s0_rdata;
    logic [1:0]              s0_rresp;
    logic                    s0_rlast;
    logic                    s0_rvalid;
    logic                    s0_rready;

    // Slave 1 signals
    logic [WIDTH_SID-1:0]    s1_awid;
    logic [ADDR_WIDTH-1:0]   s1_awaddr;
    logic [7:0]              s1_awlen;
    logic [2:0]              s1_awsize;
    logic [1:0]              s1_awburst;
    logic                    s1_awlock;
    logic [3:0]              s1_awcache;
    logic [2:0]              s1_awprot;
    logic [3:0]              s1_awqos;
    logic                    s1_awvalid;
    logic                    s1_awready;
    
    logic [DATA_WIDTH-1:0]   s1_wdata;
    logic [DATA_WIDTH/8-1:0] s1_wstrb;
    logic                    s1_wlast;
    logic                    s1_wvalid;
    logic                    s1_wready;
    
    logic [WIDTH_SID-1:0]    s1_bid;
    logic [1:0]              s1_bresp;
    logic                    s1_bvalid;
    logic                    s1_bready;
    
    logic [WIDTH_SID-1:0]    s1_arid;
    logic [ADDR_WIDTH-1:0]   s1_araddr;
    logic [7:0]              s1_arlen;
    logic [2:0]              s1_arsize;
    logic [1:0]              s1_arburst;
    logic                    s1_arlock;
    logic [3:0]              s1_arcache;
    logic [2:0]              s1_arprot;
    logic [3:0]              s1_arqos;
    logic                    s1_arvalid;
    logic                    s1_arready;
    
    logic [WIDTH_SID-1:0]    s1_rid;
    logic [DATA_WIDTH-1:0]   s1_rdata;
    logic [1:0]              s1_rresp;
    logic                    s1_rlast;
    logic                    s1_rvalid;
    logic                    s1_rready;

    // Slave 2 signals
    logic [WIDTH_SID-1:0]    s2_awid;
    logic [ADDR_WIDTH-1:0]   s2_awaddr;
    logic [7:0]              s2_awlen;
    logic [2:0]              s2_awsize;
    logic [1:0]              s2_awburst;
    logic                    s2_awlock;
    logic [3:0]              s2_awcache;
    logic [2:0]              s2_awprot;
    logic [3:0]              s2_awqos;
    logic                    s2_awvalid;
    logic                    s2_awready;
    
    logic [DATA_WIDTH-1:0]   s2_wdata;
    logic [DATA_WIDTH/8-1:0] s2_wstrb;
    logic                    s2_wlast;
    logic                    s2_wvalid;
    logic                    s2_wready;
    
    logic [WIDTH_SID-1:0]    s2_bid;
    logic [1:0]              s2_bresp;
    logic                    s2_bvalid;
    logic                    s2_bready;
    
    logic [WIDTH_SID-1:0]    s2_arid;
    logic [ADDR_WIDTH-1:0]   s2_araddr;
    logic [7:0]              s2_arlen;
    logic [2:0]              s2_arsize;
    logic [1:0]              s2_arburst;
    logic                    s2_arlock;
    logic [3:0]              s2_arcache;
    logic [2:0]              s2_arprot;
    logic [3:0]              s2_arqos;
    logic                    s2_arvalid;
    logic                    s2_arready;
    
    logic [WIDTH_SID-1:0]    s2_rid;
    logic [DATA_WIDTH-1:0]   s2_rdata;
    logic [1:0]              s2_rresp;
    logic                    s2_rlast;
    logic                    s2_rvalid;
    logic                    s2_rready;


    // Instantiate the generated interconnect
    amba_axi_m2s3 #(
        .WIDTH_DA(DATA_WIDTH),
        .WIDTH_AD(ADDR_WIDTH),
        .WIDTH_ID(ID_WIDTH)
    ) generated_interconnect (
        .ACLK(clk),
        .ARESETn(rst_n),
        
        // Master 0 - Master_0
        .M0_AWID(m0_awid),
        .M0_AWADDR(m0_awaddr),
        .M0_AWLEN(m0_awlen),
        .M0_AWSIZE(m0_awsize),
        .M0_AWBURST(m0_awburst),
        .M0_AWLOCK(m0_awlock),
        .M0_AWVALID(m0_awvalid),
        .M0_AWREADY(m0_awready),
        
        .M0_WDATA(m0_wdata),
        .M0_WSTRB(m0_wstrb),
        .M0_WLAST(m0_wlast),
        .M0_WVALID(m0_wvalid),
        .M0_WREADY(m0_wready),
        
        .M0_BID(m0_bid),
        .M0_BRESP(m0_bresp),
        .M0_BVALID(m0_bvalid),
        .M0_BREADY(m0_bready),
        
        .M0_ARID(m0_arid),
        .M0_ARADDR(m0_araddr),
        .M0_ARLEN(m0_arlen),
        .M0_ARSIZE(m0_arsize),
        .M0_ARBURST(m0_arburst),
        .M0_ARLOCK(m0_arlock),
        .M0_ARVALID(m0_arvalid),
        .M0_ARREADY(m0_arready),
        
        .M0_RID(m0_rid),
        .M0_RDATA(m0_rdata),
        .M0_RRESP(m0_rresp),
        .M0_RLAST(m0_rlast),
        .M0_RVALID(m0_rvalid),
        .M0_RREADY(m0_rready),
        // Master 1 - Master_1
        .M1_AWID(m1_awid),
        .M1_AWADDR(m1_awaddr),
        .M1_AWLEN(m1_awlen),
        .M1_AWSIZE(m1_awsize),
        .M1_AWBURST(m1_awburst),
        .M1_AWLOCK(m1_awlock),
        .M1_AWVALID(m1_awvalid),
        .M1_AWREADY(m1_awready),
        
        .M1_WDATA(m1_wdata),
        .M1_WSTRB(m1_wstrb),
        .M1_WLAST(m1_wlast),
        .M1_WVALID(m1_wvalid),
        .M1_WREADY(m1_wready),
        
        .M1_BID(m1_bid),
        .M1_BRESP(m1_bresp),
        .M1_BVALID(m1_bvalid),
        .M1_BREADY(m1_bready),
        
        .M1_ARID(m1_arid),
        .M1_ARADDR(m1_araddr),
        .M1_ARLEN(m1_arlen),
        .M1_ARSIZE(m1_arsize),
        .M1_ARBURST(m1_arburst),
        .M1_ARLOCK(m1_arlock),
        .M1_ARVALID(m1_arvalid),
        .M1_ARREADY(m1_arready),
        
        .M1_RID(m1_rid),
        .M1_RDATA(m1_rdata),
        .M1_RRESP(m1_rresp),
        .M1_RLAST(m1_rlast),
        .M1_RVALID(m1_rvalid),
        .M1_RREADY(m1_rready),
        
        // Slave 0 - Slave_0
        .S0_AWID(s0_awid),
        .S0_AWADDR(s0_awaddr),
        .S0_AWLEN(s0_awlen),
        .S0_AWSIZE(s0_awsize),
        .S0_AWBURST(s0_awburst),
        .S0_AWLOCK(s0_awlock),
        .S0_AWVALID(s0_awvalid),
        .S0_AWREADY(s0_awready),
        
        .S0_WDATA(s0_wdata),
        .S0_WSTRB(s0_wstrb),
        .S0_WLAST(s0_wlast),
        .S0_WVALID(s0_wvalid),
        .S0_WREADY(s0_wready),
        
        .S0_BID(s0_bid),
        .S0_BRESP(s0_bresp),
        .S0_BVALID(s0_bvalid),
        .S0_BREADY(s0_bready),
        
        .S0_ARID(s0_arid),
        .S0_ARADDR(s0_araddr),
        .S0_ARLEN(s0_arlen),
        .S0_ARSIZE(s0_arsize),
        .S0_ARBURST(s0_arburst),
        .S0_ARLOCK(s0_arlock),
        .S0_ARVALID(s0_arvalid),
        .S0_ARREADY(s0_arready),
        
        .S0_RID(s0_rid),
        .S0_RDATA(s0_rdata),
        .S0_RRESP(s0_rresp),
        .S0_RLAST(s0_rlast),
        .S0_RVALID(s0_rvalid),
        .S0_RREADY(s0_rready)
,
        // Slave 1 - Slave_1
        .S1_AWID(s1_awid),
        .S1_AWADDR(s1_awaddr),
        .S1_AWLEN(s1_awlen),
        .S1_AWSIZE(s1_awsize),
        .S1_AWBURST(s1_awburst),
        .S1_AWLOCK(s1_awlock),
        .S1_AWVALID(s1_awvalid),
        .S1_AWREADY(s1_awready),
        
        .S1_WDATA(s1_wdata),
        .S1_WSTRB(s1_wstrb),
        .S1_WLAST(s1_wlast),
        .S1_WVALID(s1_wvalid),
        .S1_WREADY(s1_wready),
        
        .S1_BID(s1_bid),
        .S1_BRESP(s1_bresp),
        .S1_BVALID(s1_bvalid),
        .S1_BREADY(s1_bready),
        
        .S1_ARID(s1_arid),
        .S1_ARADDR(s1_araddr),
        .S1_ARLEN(s1_arlen),
        .S1_ARSIZE(s1_arsize),
        .S1_ARBURST(s1_arburst),
        .S1_ARLOCK(s1_arlock),
        .S1_ARVALID(s1_arvalid),
        .S1_ARREADY(s1_arready),
        
        .S1_RID(s1_rid),
        .S1_RDATA(s1_rdata),
        .S1_RRESP(s1_rresp),
        .S1_RLAST(s1_rlast),
        .S1_RVALID(s1_rvalid),
        .S1_RREADY(s1_rready)
,
        // Slave 2 - Slave_2
        .S2_AWID(s2_awid),
        .S2_AWADDR(s2_awaddr),
        .S2_AWLEN(s2_awlen),
        .S2_AWSIZE(s2_awsize),
        .S2_AWBURST(s2_awburst),
        .S2_AWLOCK(s2_awlock),
        .S2_AWVALID(s2_awvalid),
        .S2_AWREADY(s2_awready),
        
        .S2_WDATA(s2_wdata),
        .S2_WSTRB(s2_wstrb),
        .S2_WLAST(s2_wlast),
        .S2_WVALID(s2_wvalid),
        .S2_WREADY(s2_wready),
        
        .S2_BID(s2_bid),
        .S2_BRESP(s2_bresp),
        .S2_BVALID(s2_bvalid),
        .S2_BREADY(s2_bready),
        
        .S2_ARID(s2_arid),
        .S2_ARADDR(s2_araddr),
        .S2_ARLEN(s2_arlen),
        .S2_ARSIZE(s2_arsize),
        .S2_ARBURST(s2_arburst),
        .S2_ARLOCK(s2_arlock),
        .S2_ARVALID(s2_arvalid),
        .S2_ARREADY(s2_arready),
        
        .S2_RID(s2_rid),
        .S2_RDATA(s2_rdata),
        .S2_RRESP(s2_rresp),
        .S2_RLAST(s2_rlast),
        .S2_RVALID(s2_rvalid),
        .S2_RREADY(s2_rready)
    );
    
    // Connect VIP to Master 0
    assign m0_awid    = axi_if.awid;
    assign m0_awaddr  = axi_if.awaddr;
    assign m0_awlen   = axi_if.awlen;
    assign m0_awsize  = axi_if.awsize;
    assign m0_awburst = axi_if.awburst;
    assign m0_awlock  = axi_if.awlock;
    assign m0_awcache = axi_if.awcache;
    assign m0_awprot  = axi_if.awprot;
    assign m0_awqos   = 4'b0000; // Default QoS value
    assign m0_awvalid = axi_if.awvalid;
    assign axi_if.awready = m0_awready;
    
    assign m0_wdata  = axi_if.wdata;
    assign m0_wstrb  = axi_if.wstrb;
    assign m0_wlast  = axi_if.wlast;
    assign m0_wvalid = axi_if.wvalid;
    assign axi_if.wready = m0_wready;
    
    assign axi_if.bid    = m0_bid;
    assign axi_if.bresp  = m0_bresp;
    assign axi_if.bvalid = m0_bvalid;
    assign m0_bready = axi_if.bready;
    
    assign m0_arid    = axi_if.arid;
    assign m0_araddr  = axi_if.araddr;
    assign m0_arlen   = axi_if.arlen;
    assign m0_arsize  = axi_if.arsize;
    assign m0_arburst = axi_if.arburst;
    assign m0_arlock  = axi_if.arlock;
    assign m0_arcache = axi_if.arcache;
    assign m0_arprot  = axi_if.arprot;
    assign m0_arqos   = 4'b0000; // Default QoS value
    assign m0_arvalid = axi_if.arvalid;
    assign axi_if.arready = m0_arready;
    
    assign axi_if.rid    = m0_rid;
    assign axi_if.rdata  = m0_rdata;
    assign axi_if.rresp  = m0_rresp;
    assign axi_if.rlast  = m0_rlast;
    assign axi_if.rvalid = m0_rvalid;
    assign m0_rready = axi_if.rready;
    
    // Terminate unused master interfaces
    // Master 1 termination
    // Write Address Channel
    assign m1_awid    = {ID_WIDTH{1'b0}};
    assign m1_awaddr  = {ADDR_WIDTH{1'b0}};
    assign m1_awlen   = 8'd0;
    assign m1_awsize  = 3'd0;
    assign m1_awburst = 2'b01;
    assign m1_awlock  = 1'b0;
    assign m1_awcache = 4'b0000;
    assign m1_awprot  = 3'b000;
    assign m1_awqos   = 4'b0000;
    assign m1_awvalid = 1'b0;
    
    // Write Data Channel
    assign m1_wdata   = {DATA_WIDTH{1'b0}};
    assign m1_wstrb   = {(DATA_WIDTH/8){1'b0}};
    assign m1_wlast   = 1'b0;
    assign m1_wvalid  = 1'b0;
    
    // Write Response Channel
    assign m1_bready  = 1'b1;
    
    // Read Address Channel
    assign m1_arid    = {ID_WIDTH{1'b0}};
    assign m1_araddr  = {ADDR_WIDTH{1'b0}};
    assign m1_arlen   = 8'd0;
    assign m1_arsize  = 3'd0;
    assign m1_arburst = 2'b01;
    assign m1_arlock  = 1'b0;
    assign m1_arcache = 4'b0000;
    assign m1_arprot  = 3'b000;
    assign m1_arqos   = 4'b0000;
    assign m1_arvalid = 1'b0;
    
    // Read Data Channel
    assign m1_rready  = 1'b1;

    
    // Slave response logic for testing
    // Slave 0 (Slave_0) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s0_awready <= 1'b0;
            s0_wready  <= 1'b0;
            s0_bvalid  <= 1'b0;
            s0_arready <= 1'b0;
            s0_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s0_awready <= 1'b1;
            s0_wready  <= 1'b1;
            s0_arready <= 1'b1;
            
            // Write response
            if (s0_awvalid && s0_awready && s0_wvalid && s0_wready && s0_wlast) begin
                s0_bvalid <= 1'b1;
                s0_bid    <= s0_awid;
                s0_bresp  <= 2'b00; // OKAY
            end else if (s0_bready && s0_bvalid) begin
                s0_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s0_arvalid && s0_arready) begin
                s0_rvalid <= 1'b1;
                s0_rid    <= s0_arid;
                s0_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s0_rresp  <= 2'b00; // OKAY
                s0_rlast  <= 1'b1;  // Single beat
            end else if (s0_rready && s0_rvalid) begin
                s0_rvalid <= 1'b0;
            end
        end
    end

    // Slave 1 (Slave_1) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s1_awready <= 1'b0;
            s1_wready  <= 1'b0;
            s1_bvalid  <= 1'b0;
            s1_arready <= 1'b0;
            s1_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s1_awready <= 1'b1;
            s1_wready  <= 1'b1;
            s1_arready <= 1'b1;
            
            // Write response
            if (s1_awvalid && s1_awready && s1_wvalid && s1_wready && s1_wlast) begin
                s1_bvalid <= 1'b1;
                s1_bid    <= s1_awid;
                s1_bresp  <= 2'b00; // OKAY
            end else if (s1_bready && s1_bvalid) begin
                s1_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s1_arvalid && s1_arready) begin
                s1_rvalid <= 1'b1;
                s1_rid    <= s1_arid;
                s1_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s1_rresp  <= 2'b00; // OKAY
                s1_rlast  <= 1'b1;  // Single beat
            end else if (s1_rready && s1_rvalid) begin
                s1_rvalid <= 1'b0;
            end
        end
    end

    // Slave 2 (Slave_2) - Simple memory model
    always @(posedge clk) begin
        if (!rst_n) begin
            s2_awready <= 1'b0;
            s2_wready  <= 1'b0;
            s2_bvalid  <= 1'b0;
            s2_arready <= 1'b0;
            s2_rvalid  <= 1'b0;
        end else begin
            // Simple handshaking
            s2_awready <= 1'b1;
            s2_wready  <= 1'b1;
            s2_arready <= 1'b1;
            
            // Write response
            if (s2_awvalid && s2_awready && s2_wvalid && s2_wready && s2_wlast) begin
                s2_bvalid <= 1'b1;
                s2_bid    <= s2_awid;
                s2_bresp  <= 2'b00; // OKAY
            end else if (s2_bready && s2_bvalid) begin
                s2_bvalid <= 1'b0;
            end
            
            // Read response (single beat for now)
            if (s2_arvalid && s2_arready) begin
                s2_rvalid <= 1'b1;
                s2_rid    <= s2_arid;
                s2_rdata  <= {DATA_WIDTH{1'b0}}; // Return zeros
                s2_rresp  <= 2'b00; // OKAY
                s2_rlast  <= 1'b1;  // Single beat
            end else if (s2_rready && s2_rvalid) begin
                s2_rvalid <= 1'b0;
            end
        end
    end


endmodule : dut_wrapper
