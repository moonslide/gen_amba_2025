//==============================================================================
// AXI4 Master Read Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-07-29 14:34:40
//==============================================================================

class axi4_master_read_seq extends axi4_master_base_seq;
    
    `uvm_object_utils(axi4_master_read_seq)
    
    // Configurable parameters
    rand bit [63:0] start_address = 64'h0;
    rand int unsigned burst_length = 1;
    rand int unsigned burst_size = 4;  // Default 4 bytes
    rand bit [1:0] burst_type = 2'b01; // INCR
    rand axi4_lock_type_e lock_type = NORMAL;  // Lock type
    rand bit [3:0] axi_id = 4'h0;  // Transaction ID
    
    // Protocol timing controls
    rand bit test_valid_stability = 0;  // Test valid signal stability
    rand int unsigned ready_delay = 0;  // Cycles to delay ready after valid
    
    // Protocol compliance test controls
    rand bit test_ready_toggling = 0;
    rand bit test_combinatorial_path = 0;
    rand bit test_response_ordering = 0;
    
    // Additional protocol properties
    rand bit [2:0] protection_type = 3'b000;  // Protection type
    rand bit [3:0] region_value = 4'b0000;  // Region value
    rand axi4_response_type_e expect_response = OKAY;  // Expected response
    rand bit enable_error_checking = 0;  // Enable error checking
    rand bit simulate_resp_timeout = 0;  // Simulate response channel timeout
    rand int unsigned timeout_cycles = 100;  // Timeout cycle count
    rand bit test_recovery = 0;  // Test recovery mechanism
    rand int inject_error_at_beat = -1;  // Beat number for error injection (-1 = no injection)
    string error_type = "none";  // Type of error to inject
    rand bit random_error_injection = 0;  // Enable random error injection
    real error_probability = 0.01;  // Error injection probability
    rand bit [3:0] qos_value = 4'b0000;  // QoS value
    rand int target_slave = 0;  // Target slave ID for directed traffic
    rand bit measure_completion_time = 0;  // Measure transaction completion time
    rand bit contention_aware = 0;  // Contention aware mode
    rand bit max_throughput_mode = 0;  // Maximum throughput mode
    string expected_data_pattern = "RANDOM";  // Expected data pattern
    rand bit enable_data_check = 0;  // Enable data integrity checking
    rand bit enable_unaligned = 0;  // Enable unaligned transfers (same as in write seq)
    rand bit verify_incremental_data = 0;  // Verify incremental data pattern
    rand bit verify_data_width = 0;  // Verify data width compliance
    rand bit verify_burst_data_pattern = 0;  // Verify burst data pattern
    rand bit [(DATA_WIDTH/8)-1:0] expected_wstrb_pattern = '1;  // Expected WSTRB pattern
    rand int unsigned expected_data_increment = 1;  // Expected data increment
    rand bit verify_continuous_pattern = 0;  // Verify continuous pattern
    rand int unsigned pattern_offset = 0;  // Pattern offset
    rand bit enable_wstrb_check = 0;  // Enable WSTRB checking
    rand bit verify_partial_write = 0;  // Verify partial write
    rand int unsigned pattern_seed = 12345;  // Pattern seed
    rand bit check_write_ordering = 0;  // Check write ordering
    rand bit verify_overlap_handling = 0;  // Verify overlap handling
    rand bit use_prng_verify = 0;  // Use PRNG for verification
    rand int unsigned prng_seed = 54321;  // PRNG seed
    rand bit verify_coherency = 0;  // Verify coherency
    rand bit save_read_data = 0;  // Save read data
    rand bit verify_counter_value = 0;  // Verify counter value
    rand int unsigned expected_increments = 0;  // Expected increments
    rand int unsigned increment_size = 1;  // Increment size
    
    // Constructor
    function new(string name = "axi4_master_read_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_tx tx;
        
        repeat(num_trans) begin
            `uvm_do_with(tx, {
                tx.tx_type == axi4_master_tx::READ;
                tx.araddr == start_address;
                tx.arburst == burst_type;
                tx.arsize == $clog2(burst_size);
                tx.arlen == burst_length - 1;
            })
        end
    endtask : body
    
endclass : axi4_master_read_seq
