//==============================================================================
// AXI4 Master Write Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-07-29 14:34:40
//==============================================================================

class axi4_master_write_seq extends axi4_master_base_seq;
    
    `uvm_object_utils(axi4_master_write_seq)
    
    // Configurable parameters
    rand bit [63:0] start_address = 64'h0;
    rand int unsigned burst_length = 1;
    rand int unsigned burst_size = 4;  // Default 4 bytes
    rand bit [1:0] burst_type = 2'b01; // INCR
    rand bit enable_unaligned = 0;  // Enable unaligned transfers
    rand axi4_lock_type_e lock_type = NORMAL;  // Lock type
    rand bit [3:0] axi_id = 4'h0;  // Transaction ID
    rand axi4_response_type_e expect_response = OKAY;  // Expected response
    
    // Protocol timing controls
    rand bit valid_before_ready = 1;  // Assert valid before ready
    rand bit ready_before_valid = 0;  // Assert ready before valid  
    rand bit simultaneous_valid_ready = 0;  // Assert valid and ready simultaneously
    rand int unsigned ready_delay = 0;  // Cycles to delay ready after valid
    rand int unsigned valid_delay = 0;  // Cycles to delay valid
    
    // Protocol compliance test controls
    rand bit test_address_compliance = 0;
    rand bit test_address_alignment = 0;
    rand bit test_data_ordering = 0;
    rand bit test_wlast_signal = 0;
    rand bit test_no_interleaving = 0;
    rand bit test_response_timing = 0;
    rand bit test_wstrb_compliance = 0;
    rand bit test_partial_writes = 0;
    
    // Additional protocol properties
    rand axi4_response_type_e expected_response = OKAY;  // Expected response (same as expect_response)
    rand int unsigned data_width = DATA_WIDTH;  // Data width
    rand bit [(DATA_WIDTH/8)-1:0] custom_wstrb = '1;  // Custom write strobes
    rand bit [3:0] cache_type = 4'b0000;  // Cache type
    rand bit [3:0] qos_value = 4'b0000;  // QoS value
    rand bit enable_error_checking = 0;  // Enable error checking
    rand bit test_error_propagation = 0;  // Test error propagation
    rand bit test_boundary_crossing = 0;  // Test boundary crossing
    rand bit expect_protocol_error = 0;  // Expect protocol error
    rand bit force_boundary_crossing = 0;  // Force boundary crossing
    rand bit force_unaligned_wrap = 0;  // Force unaligned wrap burst
    rand bit axi3_compatibility_mode = 0;  // AXI3 compatibility mode
    rand bit simulate_addr_timeout = 0;  // Simulate address channel timeout
    rand bit simulate_data_timeout = 0;  // Simulate data channel timeout
    rand int unsigned timeout_cycles = 100;  // Timeout cycle count
    rand bit create_deadlock_scenario = 0;  // Create deadlock scenario
    rand int deadlock_partner = 0;  // Deadlock partner ID
    rand bit test_recovery = 0;  // Test recovery mechanism
    rand bit test_system_recovery = 0;  // Test system recovery
    rand int inject_error_at_beat = -1;  // Beat number for error injection (-1 = no injection)
    string error_type = "none";  // Type of error to inject
    rand int target_slave = 0;  // Target slave ID for directed traffic
    rand bit measure_completion_time = 0;  // Measure transaction completion time
    rand bit expect_preemption = 0;  // Expect transaction preemption
    rand int priority_level = 0;  // Priority level for arbitration
    rand bit measure_latency = 0;  // Measure transaction latency
    rand bit hold_resource = 0;  // Hold resource for testing
    rand bit detect_priority_inversion = 0;  // Detect priority inversion
    rand bit fair_share_mode = 0;  // Fair share arbitration mode
    real bandwidth_weight = 1.0;  // Bandwidth weight for weighted arbitration
    rand bit contention_aware = 0;  // Contention aware mode
    rand bit enable_backoff = 0;  // Enable exponential backoff
    real backoff_multiplier = 2.0;  // Backoff multiplier
    rand bit measure_interference = 0;  // Measure interference
    rand bit high_priority = 0;  // High priority mode
    rand bit max_throughput_mode = 0;  // Maximum throughput mode
    string test_data_pattern = "RANDOM";  // Test data pattern
    rand bit enable_data_check = 0;  // Enable data integrity checking
    rand bit calculate_wstrb_from_address = 0;  // Calculate WSTRB from address
    rand bit generate_incremental_data = 0;  // Generate incremental data pattern
    rand bit verify_data_width = 0;  // Verify data width compliance
    rand bit generate_burst_data_pattern = 0;  // Generate burst data pattern
    rand int unsigned data_increment = 1;  // Data increment value
    rand bit continuous_data_pattern = 0;  // Continuous data pattern
    rand int unsigned pattern_seed = 12345;  // Pattern seed
    rand bit enable_wstrb_check = 0;  // Enable WSTRB checking
    rand bit use_prng_data = 0;  // Use PRNG for data generation
    rand int unsigned prng_seed = 54321;  // PRNG seed
    rand bit use_read_modify_write = 0;  // Use read-modify-write
    rand int unsigned increment_value = 1;  // Increment value
    
    // Constructor
    function new(string name = "axi4_master_write_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_tx tx;
        int trans_cnt = 0;
        
        `uvm_info(get_type_name(), $sformatf("Starting WRITE sequence: addr=0x%0h, burst_len=%0d, burst_size=%0d, num_trans=%0d",
            start_address, burst_length, burst_size, num_trans), UVM_MEDIUM)
        
        repeat(num_trans) begin
            trans_cnt++;
            `uvm_info(get_type_name(), $sformatf("Creating transaction %0d/%0d", 
                trans_cnt, num_trans), UVM_HIGH)
            
            `uvm_do_with(tx, {
                tx.tx_type == axi4_master_tx::WRITE;
                tx.awaddr == start_address;
                tx.awburst == burst_type;
                tx.awsize == $clog2(burst_size);
                tx.awlen == burst_length - 1;
            })
            
            `uvm_info(get_type_name(), $sformatf("WRITE transaction sent: addr=0x%0h, id=%0d, len=%0d, size=%0d, burst=%0d",
                tx.awaddr, tx.awid, tx.awlen, tx.awsize, tx.awburst), UVM_MEDIUM)
            
            if (tx.wdata.size() > 0) begin
                `uvm_info(get_type_name(), $sformatf("Write data: %0d beats, first_data=0x%0h", 
                    tx.wdata.size(), tx.wdata[0]), UVM_HIGH)
            end
            
            // Update address for next transaction
            if (burst_type == 2'b01) begin // INCR
                start_address = start_address + (burst_length * burst_size);
                `uvm_info(get_type_name(), $sformatf("Next address: 0x%0h", start_address), UVM_HIGH)
            end
        end
        
        `uvm_info(get_type_name(), "WRITE sequence completed", UVM_MEDIUM)
    endtask : body
    
endclass : axi4_master_write_seq
