//==============================================================================
// AXI4 Virtual Performance Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-07-29 09:33:31
//==============================================================================

class axi4_virtual_performance_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_performance_seq)
    
    // Parameters
    int num_iterations = 100;
    bit measure_latency = 0;
    real total_latency = 0;
    int latency_count = 0;
    
    // Constructor
    function new(string name = "axi4_virtual_performance_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        axi4_master_write_seq write_seq[8];
        axi4_master_read_seq read_seq[8];
        real start_time, end_time;
        
        `uvm_info(get_type_name(), "Starting virtual performance sequence on all masters", UVM_MEDIUM)
        
        repeat(num_iterations) begin
            if (measure_latency) start_time = $realtime;
            
            // Run sequences on all masters concurrently
            fork
                begin
                    write_seq[0] = axi4_master_write_seq::type_id::create("write_seq_0");
                    write_seq[0].start(p_sequencer.master_seqr[0]);
                    read_seq[0] = axi4_master_read_seq::type_id::create("read_seq_0");
                    read_seq[0].start(p_sequencer.master_seqr[0]);
                end
                begin
                    write_seq[1] = axi4_master_write_seq::type_id::create("write_seq_1");
                    write_seq[1].start(p_sequencer.master_seqr[1]);
                    read_seq[1] = axi4_master_read_seq::type_id::create("read_seq_1");
                    read_seq[1].start(p_sequencer.master_seqr[1]);
                end
                begin
                    write_seq[2] = axi4_master_write_seq::type_id::create("write_seq_2");
                    write_seq[2].start(p_sequencer.master_seqr[2]);
                    read_seq[2] = axi4_master_read_seq::type_id::create("read_seq_2");
                    read_seq[2].start(p_sequencer.master_seqr[2]);
                end
                begin
                    write_seq[3] = axi4_master_write_seq::type_id::create("write_seq_3");
                    write_seq[3].start(p_sequencer.master_seqr[3]);
                    read_seq[3] = axi4_master_read_seq::type_id::create("read_seq_3");
                    read_seq[3].start(p_sequencer.master_seqr[3]);
                end
                begin
                    write_seq[4] = axi4_master_write_seq::type_id::create("write_seq_4");
                    write_seq[4].start(p_sequencer.master_seqr[4]);
                    read_seq[4] = axi4_master_read_seq::type_id::create("read_seq_4");
                    read_seq[4].start(p_sequencer.master_seqr[4]);
                end
                begin
                    write_seq[5] = axi4_master_write_seq::type_id::create("write_seq_5");
                    write_seq[5].start(p_sequencer.master_seqr[5]);
                    read_seq[5] = axi4_master_read_seq::type_id::create("read_seq_5");
                    read_seq[5].start(p_sequencer.master_seqr[5]);
                end
                begin
                    write_seq[6] = axi4_master_write_seq::type_id::create("write_seq_6");
                    write_seq[6].start(p_sequencer.master_seqr[6]);
                    read_seq[6] = axi4_master_read_seq::type_id::create("read_seq_6");
                    read_seq[6].start(p_sequencer.master_seqr[6]);
                end
                begin
                    write_seq[7] = axi4_master_write_seq::type_id::create("write_seq_7");
                    write_seq[7].start(p_sequencer.master_seqr[7]);
                    read_seq[7] = axi4_master_read_seq::type_id::create("read_seq_7");
                    read_seq[7].start(p_sequencer.master_seqr[7]);
                end
            join
            
            if (measure_latency) begin
                end_time = $realtime;
                total_latency += (end_time - start_time);
                latency_count++;
            end
        end
        
        if (measure_latency && latency_count > 0) begin
            `uvm_info(get_type_name(), $sformatf("Average latency: %0.2f ns", total_latency/latency_count/1ns), UVM_LOW)
        end
    endtask : body
    
endclass : axi4_virtual_performance_seq
