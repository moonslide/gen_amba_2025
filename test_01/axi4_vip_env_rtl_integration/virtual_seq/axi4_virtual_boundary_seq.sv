//==============================================================================
// AXI4 Virtual Boundary Sequence
// Generated by AMBA Bus Matrix Configuration Tool
// Date: 2025-07-29 09:33:31
//==============================================================================

class axi4_virtual_boundary_seq extends axi4_virtual_base_seq;
    
    `uvm_object_utils(axi4_virtual_boundary_seq)
    
    // Test options
    bit test_4k_boundary = 1;
    bit test_slave_boundary = 1;
    bit test_max_burst = 1;
    
    // Constructor
    function new(string name = "axi4_virtual_boundary_seq");
        super.new(name);
    endfunction
    
    // Body method
    virtual task body();
        `uvm_info(get_type_name(), "Starting virtual boundary sequence", UVM_MEDIUM)
        
        if (test_4k_boundary) begin
            test_4k_boundary_crossing();
        end
        
        if (test_slave_boundary) begin
            test_slave_address_boundary();
        end
        
        if (test_max_burst) begin
            test_maximum_burst_length();
        end
    endtask : body
    
    // Test 4K boundary crossing
    task test_4k_boundary_crossing();
        axi4_master_tx tx;
        
        `uvm_info(get_type_name(), "Testing 4K boundary crossing", UVM_MEDIUM)
        
        `uvm_do_on_with(tx, p_sequencer.master_seqr[0], {
            tx.tx_type == axi4_master_tx::WRITE;
            tx.awaddr == 'h0FF0; // Near 4K boundary
            tx.awlen == 15; // 16 beats
            tx.awsize == axi4_globals_pkg::SIZE_4B;
            tx.awburst == axi4_globals_pkg::INCR;
        })
    endtask
    
    // Test slave address boundary
    task test_slave_address_boundary();
        axi4_master_tx tx;
        axi4_env_config cfg;
        
        `uvm_info(get_type_name(), "Testing slave address boundary", UVM_MEDIUM)
        
        // Cast env_cfg to proper type
        if (!$cast(cfg, p_sequencer.env_cfg)) begin
            `uvm_error(get_type_name(), "Failed to cast env_cfg to axi4_env_config")
            return;
        end
        
        // Test access at slave boundaries
        foreach(cfg.slave_cfg[i]) begin
            `uvm_do_on_with(tx, p_sequencer.master_seqr[0], {
                tx.tx_type == axi4_master_tx::READ;
                tx.araddr == cfg.slave_cfg[i].end_addr - 8;
                tx.arlen == 1;
                tx.arsize == axi4_globals_pkg::SIZE_8B;
            })
        end
    endtask
    
    // Test maximum burst length
    task test_maximum_burst_length();
        axi4_master_tx tx;
        
        `uvm_info(get_type_name(), "Testing maximum burst length", UVM_MEDIUM)
        
        `uvm_do_on_with(tx, p_sequencer.master_seqr[0], {
            tx.tx_type == axi4_master_tx::WRITE;
            tx.awlen == 255; // Maximum burst length for AXI4
            tx.awsize == axi4_globals_pkg::SIZE_4B;
            tx.awburst == axi4_globals_pkg::INCR;
        })
    endtask
    
endclass : axi4_virtual_boundary_seq
