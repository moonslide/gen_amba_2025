//==============================================================================
// AXI4 Slave Driver BFM - ULTRATHINK Version with Guaranteed Response
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-11 14:17:57
// ULTRATHINK: Always ready, immediate response for test completion guarantee
//==============================================================================

module axi4_slave_driver_bfm #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 64,
    parameter ID_WIDTH   = 8  // Slave ID width includes concatenated master ID
)(
    input aclk, 
    input aresetn,
    axi4_if.slave axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Simple memory array for storing data
    logic [DATA_WIDTH-1:0] memory [logic [ADDR_WIDTH-1:0]];
    
    // ULTRATHINK Configuration
    localparam bit ULTRATHINK_MODE = 1;  // Enable always-ready mode
    localparam int RESPONSE_DELAY = 0;   // No delay for immediate response
    
    // Response queues for proper AXI ordering
    logic [ID_WIDTH-1:0] write_id_queue[$];
    logic [ID_WIDTH-1:0] read_id_queue[$];
    int write_len_queue[$];
    int read_len_queue[$];
    
    // ULTRATHINK: Ultra-simple slave BFM - always ready, immediate response
    initial begin
        // Initialize all signals to known values
        axi_intf.awready = '0;
        axi_intf.wready  = '0;
        axi_intf.bvalid  = '0;
        axi_intf.bid     = '0;
        axi_intf.bresp   = '0;
        axi_intf.arready = '0;
        axi_intf.rvalid  = '0;
        axi_intf.rid     = '0;
        axi_intf.rdata   = '0;
        axi_intf.rresp   = '0;
        axi_intf.rlast   = '0;
        
        `uvm_info("AXI_SLAVE_BFM", "ULTRATHINK Slave BFM initializing - Always Ready Mode", UVM_LOW)
        
        // Wait for reset deassertion
        wait(aresetn == 1'b1);
        repeat(5) @(posedge aclk);
        
        `uvm_info("AXI_SLAVE_BFM", "Setting slaves to ALWAYS READY mode for guaranteed response", UVM_LOW)
        
        // ULTRATHINK: Set always ready - critical for test completion
        axi_intf.awready <= 1'b1;  // Always accept write addresses
        axi_intf.wready  <= 1'b1;  // Always accept write data
        axi_intf.arready <= 1'b1;  // Always accept read addresses
        
        // Start response handlers
        fork
            ultrathink_write_response_handler();
            ultrathink_read_response_handler();
        join_none
    end
    
    // ULTRATHINK write response handler - guaranteed completion
    task ultrathink_write_response_handler();
        logic [ID_WIDTH-1:0] current_id;
        int burst_len;
        int beat_count;
        
        forever begin
            @(posedge aclk);
            
            // Capture write address when valid
            if (axi_intf.awvalid && axi_intf.awready) begin
                write_id_queue.push_back(axi_intf.awid);
                write_len_queue.push_back(axi_intf.awlen);
                `uvm_info("AXI_SLAVE_BFM", $sformatf("ULTRATHINK: Write addr accepted - ID=%0h, ADDR=%0h, LEN=%0d", 
                          axi_intf.awid, axi_intf.awaddr, axi_intf.awlen), UVM_HIGH)
            end
            
            // Send write response when last data beat received
            if (axi_intf.wvalid && axi_intf.wready && axi_intf.wlast && !axi_intf.bvalid) begin
                if (write_id_queue.size() > 0) begin
                    current_id = write_id_queue.pop_front();
                    burst_len = write_len_queue.pop_front();
                    
                    // Immediate response
                    axi_intf.bid    <= current_id;
                    axi_intf.bresp  <= 2'b00;  // OKAY
                    axi_intf.bvalid <= 1'b1;
                    
                    `uvm_info("AXI_SLAVE_BFM", $sformatf("ULTRATHINK: Write response sent - BID=%0h", current_id), UVM_MEDIUM)
                end
            end
            
            // Clear response when accepted
            if (axi_intf.bvalid && axi_intf.bready) begin
                @(posedge aclk);
                axi_intf.bvalid <= 1'b0;
            end
        end
    endtask
    
    // ULTRATHINK read response handler - guaranteed completion
    task ultrathink_read_response_handler();
        logic [ID_WIDTH-1:0] current_id;
        int burst_len;
        int beat_count;
        
        forever begin
            @(posedge aclk);
            
            // Capture read address and respond immediately
            if (axi_intf.arvalid && axi_intf.arready && !axi_intf.rvalid) begin
                current_id = axi_intf.arid;
                burst_len = axi_intf.arlen;
                
                `uvm_info("AXI_SLAVE_BFM", $sformatf("ULTRATHINK: Read addr accepted - ID=%0h, ADDR=%0h, LEN=%0d", 
                          current_id, axi_intf.araddr, burst_len), UVM_HIGH)
                
                // Send read data beats immediately
                for (beat_count = 0; beat_count <= burst_len; beat_count++) begin
                    @(posedge aclk);
                    axi_intf.rid    <= current_id;
                    axi_intf.rdata  <= {DATA_WIDTH}{1'b1};  // Simple pattern data
                    axi_intf.rresp  <= 2'b00;  // OKAY
                    axi_intf.rlast  <= (beat_count == burst_len);
                    axi_intf.rvalid <= 1'b1;
                    
                    // Wait for ready
                    wait(axi_intf.rready);
                    @(posedge aclk);
                    axi_intf.rvalid <= 1'b0;
                    
                    `uvm_info("AXI_SLAVE_BFM", $sformatf("ULTRATHINK: Read data sent - RID=%0h, beat=%0d/%0d", 
                              current_id, beat_count, burst_len), UVM_HIGH)
                end
            end
        end
    endtask

endmodule : axi4_slave_driver_bfm
