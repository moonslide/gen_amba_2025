//==============================================================================
// AXI4 Master Driver BFM - Drives AXI interface signals for visibility
// Generated by AMBA Bus Matrix Configuration Tool  
// Date: 2025-08-11 14:17:57
//==============================================================================

module axi4_master_driver_bfm #(
    parameter ADDR_WIDTH = 64,
    parameter DATA_WIDTH = 256,
    parameter ID_WIDTH   = 4
)(
    input aclk, 
    input aresetn,
    axi4_if.master axi_intf
);

    import axi4_globals_pkg::*;
    import uvm_pkg::*;
    
    // Control signals for BFM operation
    bit enable_auto_drive = 0;
    bit bfm_enable = 0;
    int transaction_count = 0;
    
    // Driver task to generate AXI transactions for visibility
    task automatic drive_axi_transactions();
        int transaction_id = 0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", "Starting AXI transaction generation for waveform visibility", UVM_LOW)
        
        // Wait for reset deassertion
        wait(aresetn == 1'b1);
        repeat(10) @(posedge aclk);
        
        forever begin
            transaction_id++;
            
            // Random delay between transactions
            repeat($urandom_range(5, 20)) @(posedge aclk);
            
            // Generate write transaction
            drive_write_transaction(transaction_id);
            
            // Random delay
            repeat($urandom_range(5, 15)) @(posedge aclk);
            
            // Generate read transaction
            drive_read_transaction(transaction_id);
            
            // Increment transaction counter
            transaction_count++;
            
            // Limit transaction rate and check if still enabled
            repeat($urandom_range(20, 50)) @(posedge aclk);
            
            // Exit if BFM is disabled
            if (!bfm_enable) begin
                `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving disabled, stopping transactions", UVM_LOW)
                break;
            end
        end
    endtask
    
    // Drive a write transaction
    task automatic drive_write_transaction(int trans_id);
        logic [ADDR_WIDTH-1:0] addr;
        logic [7:0] len;
        logic [2:0] size;
        logic [1:0] burst;
        logic [ID_WIDTH-1:0] id;
        int b_timeout_count;
        
        // Generate transaction parameters
        // Select a random slave (0-9) and generate address in its range
        int slave_sel = $urandom_range(0, 9);
        case (slave_sel)
            0: addr = 64'h0000000000 + ($urandom() & 64'hFFFFFF);      // DDR4_Channel_0: 0x0000000000-0x01FFFFFFFF
            1: addr = 64'h0200000000 + ($urandom() & 64'hFFFFFF);      // DDR4_Channel_1: 0x0200000000-0x03FFFFFFFF
            2: addr = 64'h0400000000 + ($urandom() & 64'hFFFFFF);      // L3_Cache_SRAM: 0x0400000000-0x0400FFFFFF
            3: addr = 64'h1000000000 + ($urandom() & 64'h3FFFF);       // Boot_ROM: 0x1000000000-0x100003FFFF
            4: addr = 64'h2000000000 + ($urandom() & 64'hFFFF);        // System_Registers: 0x2000000000-0x200000FFFF
            5: addr = 64'h4000000000 + ($urandom() & 64'h3FFFFFF);     // PCIe_Config_Space: 0x4000000000-0x4003FFFFFF
            6: addr = 64'h8000000000 + ($urandom() & 64'h3FFFF);       // Crypto_Engine: 0x8000000000-0x800003FFFF
            7: addr = 64'h0800000000 + ($urandom() & 64'hFFFFF);       // Debug_APB_Bridge: 0x0800000000-0x08000FFFFF
            8: addr = 64'h0900000000 + ($urandom() & 64'hFFFFF);       // Slave0: 0x0900000000-0x09000FFFFF
            9: addr = 64'h0A00000000 + ($urandom() & 64'hFFFFF);       // Slave1: 0x0A00000000-0x0A000FFFFF
            default: addr = 64'h0 + ($urandom() & 64'hFFFFFF);
        endcase
        
        len   = $urandom_range(0, 15);  // 1-16 beats
        size  = $urandom_range(0, $clog2(DATA_WIDTH/8));  // Up to full data width
        burst = $urandom_range(0, 2);   // FIXED, INCR, WRAP
        id    = $urandom_range(0, (1<<ID_WIDTH)-1);
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write Transaction %0d: addr=0x%010x, len=%0d, size=%0d, burst=%0d, id=%0d", 
                  trans_id, addr, len, size, burst, id), UVM_MEDIUM)
        
        // Write Address Phase
        @(posedge aclk);
        axi_intf.awid    <= id;
        axi_intf.awaddr  <= addr;
        axi_intf.awlen   <= len;
        axi_intf.awsize  <= size;
        axi_intf.awburst <= burst;
        axi_intf.awlock  <= 1'b0;
        axi_intf.awcache <= 4'b0000;
        axi_intf.awprot  <= (slave_sel == 4) ? 3'b001 : 3'b000;  // Set privileged access for System_Registers
        axi_intf.awqos   <= 4'b0000;
        axi_intf.awregion <= 4'b0000;
        axi_intf.awvalid <= 1'b1;
        
        // Wait for awready
        while (!axi_intf.awready) @(posedge aclk);
        @(posedge aclk);
        axi_intf.awvalid <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write address accepted for transaction %0d", trans_id), UVM_HIGH)
        
        // Write Data Phase
        for (int beat = 0; beat <= len; beat++) begin
            @(posedge aclk);
            axi_intf.wdata  <= $urandom();
            axi_intf.wstrb  <= {DATA_WIDTH/8{1'b1}};  // All bytes valid
            axi_intf.wlast  <= (beat == len);
            axi_intf.wvalid <= 1'b1;
            
            // Wait for wready
            while (!axi_intf.wready) @(posedge aclk);
            `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Write data beat %0d sent for transaction %0d, data=0x%016x", 
                      beat, trans_id, axi_intf.wdata), UVM_HIGH)
        end
        
        @(posedge aclk);
        axi_intf.wvalid <= 1'b0;
        axi_intf.wlast  <= 1'b0;
        
        // Write Response Phase - Enhanced B-channel AXI4 flow
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Starting B-channel response phase for transaction %0d, expecting BID=%0d", 
                  trans_id, id), UVM_HIGH)
        
        // Assert BREADY to indicate readiness to receive response
        axi_intf.bready <= 1'b1;
        
        // Wait for BVALID with timeout protection
        b_timeout_count = 0;
        while (!axi_intf.bvalid) begin
            @(posedge aclk);
            b_timeout_count++;
            if (b_timeout_count > 1000) begin
                `uvm_error("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel timeout for transaction %0d", trans_id))
                break;
            end
        end
        
        // Process B-channel response
        if (axi_intf.bvalid) begin
            // Check BID matches expected AWID
            if (axi_intf.bid !== id) begin
                `uvm_warning("AXI_MASTER_DRIVER_BFM", $sformatf("BID mismatch for transaction %0d: expected=%0d, received=%0d", 
                            trans_id, id, axi_intf.bid))
            end
            
            // Check BRESP
            case (axi_intf.bresp)
                2'b00: `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel OKAY response for transaction %0d", trans_id), UVM_MEDIUM)
                2'b01: `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel EXOKAY response for transaction %0d", trans_id), UVM_MEDIUM)
                2'b10: `uvm_warning("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel SLVERR response for transaction %0d", trans_id))
                2'b11: `uvm_error("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel DECERR response for transaction %0d", trans_id))
            endcase
            
            `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel response received: trans=%0d, bid=%0d, bresp=%0b", 
                      trans_id, axi_intf.bid, axi_intf.bresp), UVM_MEDIUM)
        end
        
        // Complete B-channel handshake
        // Wait for handshake to complete (both BVALID and BREADY high)
        while (!(axi_intf.bvalid && axi_intf.bready)) @(posedge aclk);
        @(posedge aclk);
        axi_intf.bready <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("B-channel handshake completed for transaction %0d", trans_id), UVM_HIGH)
    endtask
    
    // Drive a read transaction
    task automatic drive_read_transaction(int trans_id);
        logic [ADDR_WIDTH-1:0] addr;
        logic [7:0] len;
        logic [2:0] size;
        logic [1:0] burst;
        logic [ID_WIDTH-1:0] id;
        int beat_count;
        
        // Generate transaction parameters
        // Select a random slave (0-9) and generate address in its range
        int slave_sel = $urandom_range(0, 9);
        case (slave_sel)
            0: addr = 64'h0000000000 + ($urandom() & 64'hFFFFFF);      // DDR4_Channel_0: 0x0000000000-0x01FFFFFFFF
            1: addr = 64'h0200000000 + ($urandom() & 64'hFFFFFF);      // DDR4_Channel_1: 0x0200000000-0x03FFFFFFFF
            2: addr = 64'h0400000000 + ($urandom() & 64'hFFFFFF);      // L3_Cache_SRAM: 0x0400000000-0x0400FFFFFF
            3: addr = 64'h1000000000 + ($urandom() & 64'h3FFFF);       // Boot_ROM: 0x1000000000-0x100003FFFF
            4: addr = 64'h2000000000 + ($urandom() & 64'hFFFF);        // System_Registers: 0x2000000000-0x200000FFFF
            5: addr = 64'h4000000000 + ($urandom() & 64'h3FFFFFF);     // PCIe_Config_Space: 0x4000000000-0x4003FFFFFF
            6: addr = 64'h8000000000 + ($urandom() & 64'h3FFFF);       // Crypto_Engine: 0x8000000000-0x800003FFFF
            7: addr = 64'h0800000000 + ($urandom() & 64'hFFFFF);       // Debug_APB_Bridge: 0x0800000000-0x08000FFFFF
            8: addr = 64'h0900000000 + ($urandom() & 64'hFFFFF);       // Slave0: 0x0900000000-0x09000FFFFF
            9: addr = 64'h0A00000000 + ($urandom() & 64'hFFFFF);       // Slave1: 0x0A00000000-0x0A000FFFFF
            default: addr = 64'h0 + ($urandom() & 64'hFFFFFF);
        endcase
        
        len   = $urandom_range(0, 15);  // 1-16 beats
        size  = $urandom_range(0, $clog2(DATA_WIDTH/8));  // Up to full data width
        burst = $urandom_range(0, 2);   // FIXED, INCR, WRAP
        id    = $urandom_range(0, (1<<ID_WIDTH)-1);
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read Transaction %0d: addr=0x%010x, len=%0d, size=%0d, burst=%0d, id=%0d", 
                  trans_id, addr, len, size, burst, id), UVM_MEDIUM)
        
        // Read Address Phase
        @(posedge aclk);
        axi_intf.arid    <= id;
        axi_intf.araddr  <= addr;
        axi_intf.arlen   <= len;
        axi_intf.arsize  <= size;
        axi_intf.arburst <= burst;
        axi_intf.arlock  <= 1'b0;
        axi_intf.arcache <= 4'b0000;
        axi_intf.arprot  <= (slave_sel == 4) ? 3'b001 : 3'b000;  // Set privileged access for System_Registers
        axi_intf.arqos   <= 4'b0000;
        axi_intf.arregion <= 4'b0000;
        axi_intf.arvalid <= 1'b1;
        
        // Wait for arready
        while (!axi_intf.arready) @(posedge aclk);
        @(posedge aclk);
        axi_intf.arvalid <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read address accepted for transaction %0d", trans_id), UVM_HIGH)
        
        // Read Data Phase - Enhanced R-channel handling
        axi_intf.rready <= 1'b1;
        beat_count = 0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Starting R-channel data phase for transaction %0d, expecting %0d beats", 
                  trans_id, len + 1), UVM_HIGH)
        
        while (beat_count <= len) begin
            // Wait for rvalid with timeout
            begin
                int r_timeout = 0;
                while (!axi_intf.rvalid) begin
                    @(posedge aclk);
                    r_timeout++;
                    if (r_timeout > 1000) begin
                        `uvm_error("AXI_MASTER_DRIVER_BFM", $sformatf("R-channel timeout for transaction %0d, beat %0d", trans_id, beat_count))
                        break;
                    end
                end
            end
            
            if (axi_intf.rvalid) begin
                // Check RID matches expected ARID
                if (axi_intf.rid !== id) begin
                    `uvm_warning("AXI_MASTER_DRIVER_BFM", $sformatf("RID mismatch for transaction %0d: expected=%0d, received=%0d", 
                                trans_id, id, axi_intf.rid))
                end
                
                // Check RRESP
                case (axi_intf.rresp)
                    2'b00: `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("R-channel OKAY response for transaction %0d, beat %0d", trans_id, beat_count), UVM_HIGH)
                    2'b01: `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("R-channel EXOKAY response for transaction %0d, beat %0d", trans_id, beat_count), UVM_HIGH)
                    2'b10: `uvm_warning("AXI_MASTER_DRIVER_BFM", $sformatf("R-channel SLVERR response for transaction %0d, beat %0d", trans_id, beat_count))
                    2'b11: `uvm_error("AXI_MASTER_DRIVER_BFM", $sformatf("R-channel DECERR response for transaction %0d, beat %0d", trans_id, beat_count))
                endcase
                
                `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read data beat %0d received: trans=%0d, rid=%0d, data=0x%016x, rresp=%0b, rlast=%0b", 
                          beat_count, trans_id, axi_intf.rid, axi_intf.rdata, axi_intf.rresp, axi_intf.rlast), UVM_MEDIUM)
                
                @(posedge aclk);
                beat_count++;
                
                if (axi_intf.rlast) begin
                    if (beat_count - 1 != len) begin
                        `uvm_warning("AXI_MASTER_DRIVER_BFM", $sformatf("RLAST asserted early: expected at beat %0d, got at %0d", len, beat_count - 1))
                    end
                    break;
                end
            end
        end
        
        @(posedge aclk);
        axi_intf.rready <= 1'b0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", $sformatf("Read transaction %0d completed", trans_id), UVM_MEDIUM)
    endtask
    
    // Initialize signals and start driving if enabled
    initial begin
        // Initialize all master output signals
        axi_intf.awid     = '0;
        axi_intf.awaddr   = '0;
        axi_intf.awlen    = '0;
        axi_intf.awsize   = '0;
        axi_intf.awburst  = '0;
        axi_intf.awlock   = '0;
        axi_intf.awcache  = '0;
        axi_intf.awprot   = '0;
        axi_intf.awqos    = '0;
        axi_intf.awregion = '0;
        axi_intf.awvalid  = '0;
        
        axi_intf.wdata    = '0;
        axi_intf.wstrb    = '0;
        axi_intf.wlast    = '0;
        axi_intf.wvalid   = '0;
        
        axi_intf.bready   = '0;
        
        axi_intf.arid     = '0;
        axi_intf.araddr   = '0;
        axi_intf.arlen    = '0;
        axi_intf.arsize   = '0;
        axi_intf.arburst  = '0;
        axi_intf.arlock   = '0;
        axi_intf.arcache  = '0;
        axi_intf.arprot   = '0;
        axi_intf.arqos    = '0;
        axi_intf.arregion = '0;
        axi_intf.arvalid  = '0;
        
        axi_intf.rready   = '0;
        
        `uvm_info("AXI_MASTER_DRIVER_BFM", "Master BFM signals initialized", UVM_LOW)
        
        // Check if auto-drive is enabled via plusarg or start immediately for testing
        if ($value$plusargs("BFM_AUTO_DRIVE=%d", enable_auto_drive)) begin
            if (enable_auto_drive) begin
                `uvm_info("AXI_MASTER_DRIVER_BFM", "Auto-drive mode enabled via plusarg", UVM_LOW)
                bfm_enable = 1;
            end
        end else begin
            // Default: disable BFM driving to prevent interference
            `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving disabled by default - use +BFM_AUTO_DRIVE=1 to enable", UVM_LOW)
            bfm_enable = 0;
        end
        
        if (bfm_enable) begin
            fork
                drive_axi_transactions();
            join_none
        end
    end
    
    // Task to enable/disable driving from external control  
    task set_enable(bit en);
        bfm_enable = en;
        if (en) begin
            `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving enabled", UVM_LOW)
            fork
                drive_axi_transactions();
            join_none
        end else begin
            `uvm_info("AXI_MASTER_DRIVER_BFM", "BFM driving disabled", UVM_LOW)
        end
    endtask

endmodule : axi4_master_driver_bfm
