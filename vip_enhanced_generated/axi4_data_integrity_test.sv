//==============================================================================
// AXI4 Data Integrity Test - Warning-Free Generated  
// Generated by Enhanced VIP Generator
//==============================================================================

class axi4_data_integrity_test extends axi4_base_test;
    
    `uvm_component_utils(axi4_data_integrity_test)
    
    function new(string name = "axi4_data_integrity_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    virtual task run_phase(uvm_phase phase);
        axi4_master_write_seq write_seq;
        axi4_master_read_seq read_seq;
        
        phase.raise_objection(this);
        
        `uvm_info(get_type_name(), "Starting data integrity test", UVM_LOW)
        
        // Test different data patterns - using string literals to avoid warnings
        string test_patterns[] = '{
            "00000000000000000000000000000000", // All zeros
            "ffffffffffffffffffffffffffffffff", // All ones  
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",  // Alternating pattern
            "55555555555555555555555555555555",  // Inverse alternating
            "deadbeefcafebabedeadbeefcafebabe",  // Known pattern
            "123456789abcdef0123456789abcdef0"   // Incremental pattern
        };
        
        foreach(test_patterns[i]) begin
            automatic int master_idx = i % 2;
            bit [63:0] test_addr = 64'h0001_0000 + (i * 256);
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("pattern_write_%0d", i));
            write_seq.start_address = test_addr;
            write_seq.burst_length = 1;
            write_seq.burst_size = 16; // 128-bit transfer
            write_seq.test_data_pattern = test_patterns[i]; // String assignment - no warning
            write_seq.enable_data_check = 1;
            write_seq.start(env.master_agent[master_idx].sequencer);
            #50ns;
            
            // Read back and verify
            read_seq = axi4_master_read_seq::type_id::create($sformatf("pattern_read_%0d", i));
            read_seq.start_address = test_addr;
            read_seq.burst_length = 1;
            read_seq.burst_size = 16;
            read_seq.expected_data_pattern = test_patterns[i]; // String assignment - no warning
            read_seq.enable_data_check = 1;
            read_seq.start(env.master_agent[master_idx].sequencer);
            #50ns;
        end
        
        // Test incremental data with safe formatting
        for (int addr_offset = 0; addr_offset < 64; addr_offset++) begin
            automatic int master_idx = addr_offset % 2;
            bit [63:0] addr = 64'h0001_2000 + (addr_offset * 64);
            bit [63:0] expected_data = addr ^ 64'hA5A5A5A5_5A5A5A5A;
            
            write_seq = axi4_master_write_seq::type_id::create($sformatf("incr_write_%0d", addr_offset));
            write_seq.start_address = addr;
            write_seq.burst_length = 1;
            write_seq.burst_size = 8;
            write_seq.test_data_pattern = $sformatf("%h", expected_data); // Safe formatting
            write_seq.start(env.master_agent[master_idx].sequencer);
            #25ns;
            
            read_seq = axi4_master_read_seq::type_id::create($sformatf("incr_read_%0d", addr_offset));
            read_seq.start_address = addr;
            read_seq.burst_length = 1;
            read_seq.burst_size = 8;
            read_seq.expected_data_pattern = $sformatf("%h", expected_data); // Safe formatting
            read_seq.start(env.master_agent[master_idx].sequencer);
            #25ns;
        end
        
        `uvm_info(get_type_name(), "Completed data integrity test", UVM_LOW)
        
        phase.drop_objection(this);
    endtask
    
endclass : axi4_data_integrity_test
